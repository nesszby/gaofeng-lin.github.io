<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Welcome to my Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-15T08:07:10.080Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Gaofeng Lin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux知识点</title>
    <link href="http://example.com/2022/01/15/Linux%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://example.com/2022/01/15/Linux%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-01-15T08:06:24.154Z</published>
    <updated>2022-01-15T08:07:10.080Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#fen-qu-gua-zai">分区+挂载</a><ul><li><a href="#fen-qu">分区</a></li><li><a href="#gua-zai">挂载</a></li><li><a href="#jie-chu-gua-zai">解除挂载</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="fen-qu-gua-zai">分区+挂载</span><a href="#fen-qu-gua-zai" class="header-anchor">#</a></h1><h2><span id="fen-qu">分区</span><a href="#fen-qu" class="header-anchor">#</a></h2><p>详细信息：<a href="https://blog.csdn.net/qq_30604989/article/details/81163270">来源该博客</a><br><img src="https://img-blog.csdnimg.cn/edd06e4319f24f1092d6f7bba9955937.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ol><li>在linux下，一个硬盘要先分区，然后才能挂载到目录上。和windows相同。</li></ol><p> <img src="https://img-blog.csdnimg.cn/a8ef1355fa2f4595a7b69da0b0bb50ec.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2><span id="gua-zai">挂载</span><a href="#gua-zai" class="header-anchor">#</a></h2><p><img src="https://img-blog.csdnimg.cn/0189f5afb0f24dde85c540fc5b8c887f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br></pre></td></tr></table></figure><p>这一步是对sdb这个磁盘分区。<br><img src="https://img-blog.csdnimg.cn/bde5f9eba20b477bbeb551a9cb4bc246.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>接下来是格式化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t ext4 /dev/sdb1</span><br></pre></td></tr></table></figure><p>挂载：将分区和目录联系起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount 设备名 目录名</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sdb1 /home/newdisk</span><br></pre></td></tr></table></figure><p>这个方法重启会失效，设置永久挂载。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/fstab</span><br></pre></td></tr></table></figure><h2><span id="jie-chu-gua-zai">解除挂载</span><a href="#jie-chu-gua-zai" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount 设备名</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/d9ca57a5c9bf44589498a26a8baea9e5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#fen-qu-gua-zai&quot;&gt;分区+挂载&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#fen-qu&quot;&gt;分区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#gua-zai&quot;&gt;挂</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="运维" scheme="http://example.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="持续集成" scheme="http://example.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://example.com/2022/01/15/linux%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/01/15/linux%E5%91%BD%E4%BB%A4/</id>
    <published>2022-01-15T08:02:41.233Z</published>
    <updated>2022-01-15T08:05:58.056Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#fu-zhi-yi-dong-wen-jian-wen-jian-gai-ming">复制/移动文件、文件改名</a></li><li><a href="#cha-kan-duan-kou">查看端口</a><ul><li><a href="#cha-kan-mou-ge-fu-wu-de-zhuang-tai">查看某个服务的状态</a></li><li><a href="#lsof-i-duan-kou-hao">lsof -i:端口号</a></li><li><a href="#netstat-tunlp-grep-duan-kou-hao-br">netstat -tunlp | grep 端口号  <br></a></li><li><a href="#kill-sha-si-jin-cheng">kill(杀死进程)</a></li><li><a href="#telnet-jian-ce-duan-kou-shi-fou-ke-yong">telnet(检测端口是否可用)</a></li></ul></li><li><a href="#touch-ming-ling-chuang-jian-wen-jian">touch命令(创建文件)</a></li><li><a href="#cat-ming-ling-xian-shi-wen-jian-nei-rong">cat命令(显示文件内容)</a></li><li><a href="#centos7-te-xing">Centos7特性</a></li><li><a href="#fang-huo-qiang">防火墙</a><ul><li><a href="#kai-qi-duan-kou-yi-80-wei-li">开启端口（以80为例）</a></li><li><a href="#chong-qi-fang-huo-qiang">重启防火墙</a></li></ul></li><li><a href="#xiu-gai-zhu-ji-ming">修改主机名</a><ul><li><a href="#debian-ubuntu-xi-lie">debian/ubuntu系列</a></li><li><a href="#redhat-centos-xi-lie">redhat/centos系列</a></li></ul></li><li><a href="#vim-xiang-guan-cao-zuo">vim相关操作</a><ul><li><a href="#fu-zhi">复制</a></li><li><a href="#nian-tie">粘贴</a></li><li><a href="#shan-chu">删除</a></li><li><a href="#cha-zhao">查找</a></li><li><a href="#she-zhi-xing-hao">设置行号</a></li><li><a href="#tiao-dao-zhi-ding-xing">跳到指定行</a></li><li><a href="#wen-jian-shang-xia-fan-zhuan">文件上下翻转</a></li><li><a href="#che-xiao-shang-yi-bu-cao-zuo">撤销上一步操作</a></li><li><a href="#vim-bian-ji">vim编辑</a></li><li><a href="#duo-chuang-kou-gong-neng">多窗口功能</a></li><li><a href="#suo-jin">缩进</a></li></ul></li><li><a href="#she-zhi-ssh-tong-guo-mi-yao-deng-lu">设置 SSH 通过密钥登录</a><ul><li><a href="#zhi-zuo-mi-yao-dui">制作密钥对</a></li><li><a href="#zai-fu-wu-qi-shang-an-zhuang-gong-yao">在服务器上安装公钥</a></li><li><a href="#she-zhi-ssh-da-kai-mi-yao-deng-lu-gong-neng">设置 SSH，打开密钥登录功能</a></li><li><a href="#jiang-si-yao-xia-zai-dao-ke-hu-duan-ran-hou-zhuan-huan-wei-putty-neng-shi-yong-de-ge-shi">将私钥下载到客户端，然后转换为 PuTTY 能使用的格式</a></li><li><a href="#ssh-ke-hu-duan-xshell-deng-lu-linux-fu-wu-qi">ssh客户端–xshell登录linux服务器</a></li><li><a href="#ssh-keygen-ming-ling-xiang-jie">ssh-keygen命令详解</a></li></ul></li><li><a href="#centos-qi-dong-ting-zhi-chong-qi-kai-ji-zi-qi-dong-fu-wu">Centos 启动/停止/重启/开机自启动服务</a></li><li><a href="#wen-jian-nei-rong-fu-gai-zhui-jia-nei-rong-cat-ming-ling">文件内容覆盖/追加内容（cat命令）</a></li><li><a href="#linux-zhong-de-he-he">linux中的&amp;&amp; 和 &amp;，| 和 ||</a></li><li><a href="#rpm-ming-ling">rpm命令</a></li><li><a href="#cha-kan-xi-tong-ban-ben">查看系统版本</a><ul><li><a href="#centos">centos</a></li></ul></li><li><a href="#geng-huan-yum-yuan">更换yum源</a></li></ul><!-- tocstop --></div><h1><span id="fu-zhi-yi-dong-wen-jian-wen-jian-gai-ming">复制/移动文件、文件改名</span><a href="#fu-zhi-yi-dong-wen-jian-wen-jian-gai-ming" class="header-anchor">#</a></h1><ol><li><code>cp /xx/xx(a)  /xx/xx(a)</code>   :复制   ~~~~  //将a复制到b</li><li><code>mv /xx /xx /xx/xx</code> :剪切</li><li><code>mv 旧文件夹名 新文件夹名</code>   //更改名字</li></ol><h1><span id="cha-kan-duan-kou">查看端口</span><a href="#cha-kan-duan-kou" class="header-anchor">#</a></h1><h2><span id="cha-kan-mou-ge-fu-wu-de-zhuang-tai">查看某个服务的状态</span><a href="#cha-kan-mou-ge-fu-wu-de-zhuang-tai" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service ‘servicename’ status</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd status //查看sshd服务的状态，可以看到它的进程号，如果不需要可以kill 杀死</span><br></pre></td></tr></table></figure><h2><span id="lsof-i-duan-kou-hao">lsof -i:端口号</span><a href="#lsof-i-duan-kou-hao" class="header-anchor">#</a></h2><p><img src="https://img-blog.csdnimg.cn/76c06a2619c04918af8a7331869739fd.png" alt="在这里插入图片描述"><br>可以看到 8000 端口已经被轻 nodejs 服务占用。</p><p><img src="https://img-blog.csdnimg.cn/a9bdaa252c8c4083baf16c1e664416ac.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2><span id="netstat-tunlp-grep-duan-kou-hao">netstat -tunlp | grep 端口号  <br></span><a href="#netstat-tunlp-grep-duan-kou-hao" class="header-anchor">#</a></h2><p><strong>用于显示 tcp，udp 的端口和进程等相关情况</strong></p><blockquote><p>-t (tcp) 仅显示tcp相关选项<br>-u (udp)仅显示udp相关选项<br>-n 拒绝显示别名，能显示数字的全部转化为数字<br>-l 仅列出在Listen(监听)的服务状态<br>-p 显示建立相关链接的程序名</p></blockquote><p><img src="https://img-blog.csdnimg.cn/b16427d1c6cc430080b1dae37360358c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2><span id="kill-sha-si-jin-cheng">kill(杀死进程)</span><a href="#kill-sha-si-jin-cheng" class="header-anchor">#</a></h2><p><img src="https://img-blog.csdnimg.cn/e228676961554ebaa0725d3cad3b14c6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2><span id="telnet-jian-ce-duan-kou-shi-fou-ke-yong">telnet(检测端口是否可用)</span><a href="#telnet-jian-ce-duan-kou-shi-fou-ke-yong" class="header-anchor">#</a></h2><p>有时我们想知道端口是否开启。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tenlet ip 端口</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/46ee47447ace457e95d472fef5ea9ea8.png" alt="在这里插入图片描述">上图表示：80端口开放，8899端口未开放。</p><h1><span id="touch-ming-ling-chuang-jian-wen-jian">touch命令(创建文件)</span><a href="#touch-ming-ling-chuang-jian-wen-jian" class="header-anchor">#</a></h1><p><code>touch</code>命令用于修改文件或者目录的时间属性，包括存取时间和更改时间，若文件不存在，系统会建立一个新的文件。</p><p>创建一个空白文件，如果文件已经存在，它将更改文件的访问时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch /tmp/file.txt</span><br></pre></td></tr></table></figure><p>创建多个文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch /tmp/file1.txt /tmp/file2.txt /tmp/file3.txt</span><br></pre></td></tr></table></figure><p>修改文件的修改时间并查看文件属性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch -m /tmp/file.txt &amp;&amp; stat /tmp/file.txt</span><br></pre></td></tr></table></figure><p>同时修改访问时间和修改时间并设置一个特定的访问与修改时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch -am -t 202007010000.00 /tmp/file.txt &amp;&amp; stat /tmp/file.txt</span><br></pre></td></tr></table></figure><h1><span id="cat-ming-ling-xian-shi-wen-jian-nei-rong">cat命令(显示文件内容)</span><a href="#cat-ming-ling-xian-shi-wen-jian-nei-rong" class="header-anchor">#</a></h1><p><code>cat</code>命令属于文件管理，用于连接文件并打印到标准输出设备上，<code>cat</code>经常用来显示文件的内容，注意，当文件较大时，文本在屏幕上迅速闪过，会出现滚屏现象，此时往往看不清所显示的内容，为了控制滚屏，可以按<code>Ctrl+S</code>键停止滚屏，按<code>Ctrl+Q</code>键可以恢复滚屏，此外可以用<code>more</code>等命令进行读文件并分页显示。</p><p>使用<code>cat</code>命令创建一个文件，输入文件信息后按<code>Ctrl+D</code>输出<code>EOF</code>标识后结束输入。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; file.txt</span><br></pre></td></tr></table></figure><p>输出<code>file.txt</code>文件中的内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt</span><br></pre></td></tr></table></figure><p>同时输出<code>file.txt</code>与<code>file2.txt</code>文件中的内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt file2.txt</span><br></pre></td></tr></table></figure><p>把<code>file.txt</code>文件的内容加上行号后追加到<code>file2.txt</code>文件中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n file.txt &gt;&gt; file2.txt</span><br></pre></td></tr></table></figure><p>清空<code>file2.txt</code>文件，<code>/dev/null</code>称为空设备，是一个特殊的设备文件，其会丢弃一切写入其中的数据，但报告写入操作成功，读取它则会立即得到一个<code>EOF</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/null &gt; file2.txt</span><br></pre></td></tr></table></figure><p>将<code>file.txt</code>与<code>file2.txt</code>文件内容合并输出到<code>file3.txt</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt file2.txt &gt; file3.txt</span><br></pre></td></tr></table></figure><h1><span id="centos7-te-xing">Centos7特性</span><a href="#centos7-te-xing" class="header-anchor">#</a></h1><p>服务相关命令使用systemctl，之前的版本是service</p><blockquote><p>systemctl (stop/restart/start)  (服务)<br>systemctl restart nginx</p></blockquote><h1><span id="fang-huo-qiang">防火墙</span><a href="#fang-huo-qiang" class="header-anchor">#</a></h1><h2><span id="kai-qi-duan-kou-yi-80-wei-li">开启端口（以80为例）</span><a href="#kai-qi-duan-kou-yi-80-wei-li" class="header-anchor">#</a></h2><blockquote><p>firewall-cmd –zone=public –add-port=80/tcp –permanent</p></blockquote><h2><span id="chong-qi-fang-huo-qiang">重启防火墙</span><a href="#chong-qi-fang-huo-qiang" class="header-anchor">#</a></h2><blockquote><p>systemctl restart firewalld.service</p></blockquote><p><strong>不同的系统命令可能不同</strong></p><h1><span id="xiu-gai-zhu-ji-ming">修改主机名</span><a href="#xiu-gai-zhu-ji-ming" class="header-anchor">#</a></h1><h2><span id="debian-ubuntu-xi-lie">debian/ubuntu系列</span><a href="#debian-ubuntu-xi-lie" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">第一步：</span><br><span class="line">vi /etc/hostname</span><br><span class="line">写入</span><br><span class="line"></span><br><span class="line">HOSTNAME=yourhostname</span><br><span class="line">保存后执行以下：</span><br><span class="line"></span><br><span class="line">hostname yourhostname</span><br><span class="line"> 查看设置后的hostname</span><br><span class="line">hostname</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第二步：</span><br><span class="line">vi /etc/hosts</span><br><span class="line">修改成新的主机名</span><br></pre></td></tr></table></figure><h2><span id="redhat-centos-xi-lie">redhat/centos系列</span><a href="#redhat-centos-xi-lie" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/network</span><br><span class="line">输入以下：</span><br><span class="line"></span><br><span class="line">HOSTNAME=yourhostname</span><br><span class="line">保存后执行以下：</span><br><span class="line"></span><br><span class="line">hostname yourhostname</span><br><span class="line"> 查看设置后的hostname</span><br><span class="line">hostname</span><br></pre></td></tr></table></figure><h1><span id="vim-xiang-guan-cao-zuo">vim相关操作</span><a href="#vim-xiang-guan-cao-zuo" class="header-anchor">#</a></h1><h2><span id="fu-zhi">复制</span><a href="#fu-zhi" class="header-anchor">#</a></h2><p>1）单行复制</p><p>在命令模式下，将光标移动到将要复制的行处，按“yy”进行复制；</p><p>2）多行复制 在命令模式下，将光标移动到将要复制的首行处，按“nyy”复制n行；其中n为1、2、3……</p><p>【yy】 复制光标所在的那一行<br>【nyy】 复制光标所在的向下n行</p><h2><span id="nian-tie">粘贴</span><a href="#nian-tie" class="header-anchor">#</a></h2><p>在命令模式下，将光标移动到将要粘贴的行处，按“p”进行粘贴</p><p>【p,P】 p为将已经复制的数据在光标下一行粘贴；P为将已经复制的数据在光标上一行粘贴</p><h2><span id="shan-chu">删除</span><a href="#shan-chu" class="header-anchor">#</a></h2><p>删除一行：dd</p><p>删除一个单词/光标之后的单词剩余部分：dw</p><p>删除当前字符：x</p><p>光标之后的该行部分：d$</p><p>文本删除</p><p>dd 删除一行</p><p>d$ 删除以当前字符开始的一行字符</p><p>ndd 删除以当前行开始的n行</p><p>dw 删除以当前字符开始的一个字</p><p>ndw 删除以当前字符开始的n个字</p><h2><span id="cha-zhao">查找</span><a href="#cha-zhao" class="header-anchor">#</a></h2><p>【/word】 在文件中查找内容为word的字符串（向下查找）<br>【?word】 在文件中查找内容为word的字符串（向上查找）<br>【[n]】 表示重复查找动作，即查找下一个<br>【[N]】 反向查找下一个</p><p>搜索后，我们打开别的文件，发现也被高亮了，怎么关闭高亮？</p><p>命令模式下，输入:nohlsearch  也可以:set nohlsearch； 当然，可以简写，noh或者set noh。<br>PS：nohlsearch是（no highlight search缩写）</p><h2><span id="she-zhi-xing-hao">设置行号</span><a href="#she-zhi-xing-hao" class="header-anchor">#</a></h2><p>如果编辑后，又想显示行号，同样操作按一下esc键，并输入:（冒号），输入set number    ，并按回车键，完成后即显示行号</p><h2><span id="tiao-dao-zhi-ding-xing">跳到指定行</span><a href="#tiao-dao-zhi-ding-xing" class="header-anchor">#</a></h2><p>在知道所查找的内容在文件中的具体位置时可以使用以下命令直接定位：<br>跳到文件指定行：比如跳到66行</p><p>66+G（也就是66+shift+g）<br>当然你可以选择另一种跳转方式：</p><p>命令行输入“ : n ” 然后回车<br>跳到文件第一行：gg （两个小写的G）</p><p>跳到文件最后一行：shift+g （也就是G）</p><h2><span id="wen-jian-shang-xia-fan-zhuan">文件上下翻转</span><a href="#wen-jian-shang-xia-fan-zhuan" class="header-anchor">#</a></h2><p>页翻转可以直接使用PgUp和PgDn</p><p>向前滚动一屏：Ctrl+F</p><p>向后滚动一屏：Ctrl+B</p><p>向前滚动半屏：Ctrl+D（向下）</p><p>向后滚动半屏：Ctrl+U（向上）</p><p>向下滚动一行，保持当前光标不动：Ctrl+E</p><p>向上滚动一行，保持当前光标不动：Ctrl+Y</p><p>当前行滚动：<br>当前行移动到屏幕顶部并滚动：Z+Enter<br>滚动指定行到屏幕顶部： 10Z+Enter（指定第十行）<br>当前行移动到屏幕中央并滚动：Z + .<br>当前行移动到屏幕底部并滚动：Z + -<br>当前屏幕操作：<br>H：大写h，移动到当前屏幕首行；nH移动到首行下的第n行<br>M：大写m，移动到当前屏幕中间行<br>L：大写l，移动到当前屏幕末行；nL移动到末行上面的第n行</p><h2><span id="che-xiao-shang-yi-bu-cao-zuo">撤销上一步操作</span><a href="#che-xiao-shang-yi-bu-cao-zuo" class="header-anchor">#</a></h2><p>【u】 撤消上一个操作<br>【[Ctrl] + r】 多次撤消<br>【.】 这是小数点键，重复上一个操作</p><p>  缩进：</p><p>  插入模式下，ctrl+shift+d 减少缩进，ctrl+shift+t 增加缩进</p><h2><span id="vim-bian-ji">vim编辑</span><a href="#vim-bian-ji" class="header-anchor">#</a></h2><p>1、进入插入模式（６个命令）<br>【i】 从目前光标所在处插入<br>【I】 从目前光标<br>【a】 从当前光标所在的下一个字符处开始插入<br>【A】 从光标所在行的最后一个字符处开始插入<br>【o】 英文小写字母o，在目前光标所在行的下一行处插入新的一行并开始插入<br>【O】 英文大写字母O，在目前光标所在行的上一行处插入新的一行并开始插入</p><p> 2、进入替换模式（2个命令）<br>【r】 只会替换光标所在的那一个字符一次<br>【R】 会一直替换光标所在字符，直到按下[ESC]键为止<br>【[ESC]】 退出编辑模式回到一般模式</p><p>  3、一般模式切换到命令行模式<br>【:w】 保存文件<br>【:w!】 若文件为只读，强制保存文件<br>【:q】 离开vi<br>【:q!】 不保存强制离开vi<br>【:wq】 保存后离开<br>【:wq!】 强制保存后离开<br>【:! command】 暂时离开vi到命令行下执行一个命令后的显示结果<br>【:set nu】 显示行号<br>【:set nonu】 取消显示行号<br>【:w newfile】 另存为<br>【:set fileencoding】 查看当前文件编码格式<br>【:set fileencoding=utf-8】 设置当前文件编码格式为utf-8，也可以设置成其他编码格式<br>【:set fileformat】 查看当前文件的断行格式（dos\windows,unix或macintosh）<br>【:set fileformat=unix】 将当前文件的断行格式设置为unix格式</p><h2><span id="duo-chuang-kou-gong-neng">多窗口功能</span><a href="#duo-chuang-kou-gong-neng" class="header-anchor">#</a></h2><p>【:sp [filename]】 打开一个新窗口，显示新文件，若只输入:sp，则两窗口显示同一个文件<br>【[Ctrl] + w + j】 光标移动到下方窗口<br>【[Ctrl] + w + k】 光标移动到上方窗口<br>【[Ctrl] + w + q】 离开当前窗口</p><h2><span id="suo-jin">缩进</span><a href="#suo-jin" class="header-anchor">#</a></h2><p>批量缩进</p><p>在程序代码界面，按esc，退出编辑模式，到命令模式，并在英语输入法下输入“：”</p><p>将所要批量缩进的行号写上，按照格式：“行号1，行号2&gt;”输入命令，如要将2至9行批量缩进一个tab值，则命令为“2,9&gt;”</p><p>输入完毕后，按回车可以执行，就可以看到2至9行全部缩进了一个tab值了，同样的，如果要缩回来一个tab值，则用命令“行号1，行号2&lt;”即可</p><p>可视模式缩进</p><p>方法二是在可视模式下选择要移动的列，操作为，esc从编辑模式退到命令模式，将光标移到需要缩进的行的行首，然后按shift+v，可以看到该行已被选中，且左下角提示为“可视”</p><p>此时，按键盘上的上下左右方向键，如这里按向下的箭头，选中所有需要批量缩进的行</p><p>选择好了之后，按shift+&gt;,是向前缩进一个tab值，按shift+&lt;，则是缩回一个tab值，</p><h1><span id="she-zhi-ssh-tong-guo-mi-yao-deng-lu">设置 SSH 通过密钥登录</span><a href="#she-zhi-ssh-tong-guo-mi-yao-deng-lu" class="header-anchor">#</a></h1><h2><span id="zhi-zuo-mi-yao-dui">制作密钥对</span><a href="#zhi-zuo-mi-yao-dui" class="header-anchor">#</a></h2><blockquote><p>我们一般使用 PuTTY 等 SSH 客户端来远程管理 Linux<br>服务器。但是，一般的密码方式登录，容易有密码被暴力破解的问题。所以，一般我们会将 SSH 的端口设置为默认的 22 以外的端口，或者禁用<br>root 账户登录。其实，有一个更好的办法来保证安全，而且让你可以放心地用 root 账户从远程登录——那就是通过密钥方式登录。</p><p>密钥形式登录的原理是：利用密钥生成器制作一对密钥——一只公钥和一只私钥。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。这样一来，没有私钥，任何人都无法通过<br>SSH 暴力破解你的密码来远程登录到系统。此外，如果将公钥复制到其他账户甚至主机，利用私钥也可以登录。</p><p>下面来讲解如何在 Linux 服务器上制作密钥对，将公钥添加给账户，设置 SSH，最后通过客户端登录。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">首先在服务器上制作密钥对。首先用密码登录到你打算使用密钥登录的账户，然后执行以下命令：</span><br><span class="line"></span><br><span class="line">[root@host ~]$ ssh-keygen  &lt;== 建立密钥对</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/root/.ssh/id_rsa): &lt;== 按 Enter。如果输入其它字符，比如test，那么生产的私钥是test，公钥是test.pub。说白了就是让你输入密钥文件名，不输入就采用默认的。</span><br><span class="line">Created directory &#x27;/root/.ssh&#x27;.</span><br><span class="line">Enter passphrase (empty for no passphrase): &lt;== 输入密钥锁码，后续使用私钥登录的时候会要求输密码，建议输入；或直接按 Enter 留空</span><br><span class="line">Enter same passphrase again: &lt;== 再输入一遍密钥锁码</span><br><span class="line">Your identification has been saved in /root/.ssh/id_rsa. &lt;== 私钥</span><br><span class="line">Your public key has been saved in /root/.ssh/id_rsa.pub. &lt;== 公钥</span><br><span class="line">The key fingerprint is:</span><br><span class="line">0f:d3:e7:1a:1c:bd:5c:03:f1:19:f1:22:df:9b:cc:08 root@host</span><br><span class="line">密钥锁码在使用私钥时必须输入，这样就可以保护私钥不被盗用。当然，也可以留空，实现无密码登录。</span><br><span class="line"></span><br><span class="line">现在，在 root 用户的家目录中生成了一个 .ssh 的隐藏目录，内含两个密钥文件。id_rsa 为私钥，id_rsa.pub 为公钥。</span><br></pre></td></tr></table></figure><h2><span id="zai-fu-wu-qi-shang-an-zhuang-gong-yao">在服务器上安装公钥</span><a href="#zai-fu-wu-qi-shang-an-zhuang-gong-yao" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">键入以下命令，在服务器上安装公钥：</span><br><span class="line"></span><br><span class="line">[root@host ~]$ cd .ssh</span><br><span class="line">[root@host .ssh]$ cat id_rsa.pub &gt;&gt; authorized_keys</span><br><span class="line">如此便完成了公钥的安装。为了确保连接成功，请保证以下文件权限正确：</span><br><span class="line"></span><br><span class="line">[root@host .ssh]$ chmod 600 authorized_keys</span><br><span class="line">[root@host .ssh]$ chmod 700 ~/.ssh</span><br></pre></td></tr></table></figure><h2><span id="she-zhi-ssh-da-kai-mi-yao-deng-lu-gong-neng">设置 SSH，打开密钥登录功能</span><a href="#she-zhi-ssh-da-kai-mi-yao-deng-lu-gong-neng" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">编辑 /etc/ssh/sshd_config 文件，进行如下设置：</span><br><span class="line"></span><br><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">另外，请留意 root 用户能否通过 SSH 登录：</span><br><span class="line"></span><br><span class="line">PermitRootLogin yes</span><br><span class="line">当你完成全部设置，并以密钥方式登录成功后，再禁用密码登录：</span><br><span class="line"></span><br><span class="line">PasswordAuthentication no</span><br><span class="line">最后，重启 SSH 服务：</span><br><span class="line"></span><br><span class="line">[root@host .ssh]$ service sshd restart</span><br></pre></td></tr></table></figure><h2><span id="jiang-si-yao-xia-zai-dao-ke-hu-duan-ran-hou-zhuan-huan-wei-putty-neng-shi-yong-de-ge-shi">将私钥下载到客户端，然后转换为 PuTTY 能使用的格式</span><a href="#jiang-si-yao-xia-zai-dao-ke-hu-duan-ran-hou-zhuan-huan-wei-putty-neng-shi-yong-de-ge-shi" class="header-anchor">#</a></h2><p>使用 WinSCP、SFTP 等工具将私钥文件 id_rsa 下载到客户端机器上。然后打开 PuTTYGen，单击 Actions 中的 Load 按钮，载入你刚才下载到的私钥文件。如果你刚才设置了密钥锁码，这时则需要输入。</p><p>载入成功后，PuTTYGen 会显示密钥相关的信息。在 Key comment 中键入对密钥的说明信息，然后单击 Save private key 按钮即可将私钥文件存放为 PuTTY 能使用的格式。</p><p>今后，当你使用 PuTTY 登录时，可以在左侧的 Connection -&gt; SSH -&gt; Auth 中的 Private key file for authentication: 处选择你的私钥文件，然后即可登录了，过程中只需输入密钥锁码即可。</p><h2><span id="ssh-ke-hu-duan-xshell-deng-lu-linux-fu-wu-qi">ssh客户端–xshell登录linux服务器</span><a href="#ssh-ke-hu-duan-xshell-deng-lu-linux-fu-wu-qi" class="header-anchor">#</a></h2><p>将服务器上生成的私钥，id_rsa下载到本地。<br><img src="https://img-blog.csdnimg.cn/8aa2ee35095b499c9cddaf21b877ca01.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/a96ed4029057488f9ee7a6b9acae0fd3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2><span id="ssh-keygen-ming-ling-xiang-jie">ssh-keygen命令详解</span><a href="#ssh-keygen-ming-ling-xiang-jie" class="header-anchor">#</a></h2><p>这条命令目的是为了本地机器ssh登录远程服务器无需输入密码</p><p><strong>1.ssh-keygen</strong></p><blockquote><p>SSH 为 Secure Shell 的缩写，SSH 为建立在应用层基础上的安全协议。SSH<br>是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。<br><br><br>从客户端来看，SSH提供两种级别的安全验证：<br><br><br>第一种级别（基于口令的安全验证）：只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人”这种方式的攻击。<br>    <br><br>第二种级别（基于密匙的安全验证）ssh-keygen：需要依靠密匙，你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。用这种方式，你必须知道自己密匙的口令。但是，与第一种级别相比，第二种级别不需要在网络上传送口令。第二种级别不仅加密所有传送的数据，而且“中间人”这种攻击方式也是不可能的（因为他没有你的私人密匙）。但是整个登录的过程可能需要10秒。<br><br>    ssh-keygen有很多的参数，比如这里的-t -b -C都是他的一些参数</p></blockquote><p><strong>2.-t rsa</strong></p><blockquote><p>-t即指定密钥的类型，密钥的类型有两种，一种是RSA，一种是DSA：<br><br>RSA：RSA加密算法是一种非对称加密算法，是由三个麻省理工的牛人弄出来的，RSA是他们三个人姓的开头首字母组合。<br><br>DSA：Digital Signature Algorithm (DSA)是Schnorr和ElGamal签名算法的变种。<br><br>为了让两个linux机器之间使用ssh不需要用户名和密码。所以采用了数字签名RSA或者DSA来完成这个操作。ssh-keygen默认使用rsa密钥，所以不加-t rsa也行，如果你想生成dsa密钥，就需要加参数-t dsa。</p></blockquote><p><strong>3.-b 4096</strong></p><blockquote><p>-b 指定密钥长度。对于RSA密钥，最小要求768位，默认是2048位。命令中的4096指的是RSA密钥长度为4096位。<br><br>DSA密钥必须恰好是1024位(FIPS 186-2 标准的要求)。</p></blockquote><p><strong>这里额外补充一个知识</strong></p><blockquote><p>命令后面还可以增加-C “注释内容”<br><br>-C表示要提供一个新注释，用于识别这个密钥，可以是任何内容,一个用来识别的key</p></blockquote><p><strong>小结：当你创建ssh的时候：-t 表示密钥的类型 ，-b表示密钥的长度，-C 用于识别这个密钥的注释 ，这个注释你可以输入任何内容</strong></p><h1><span id="centos-qi-dong-ting-zhi-chong-qi-kai-ji-zi-qi-dong-fu-wu">Centos 启动/停止/重启/开机自启动服务</span><a href="#centos-qi-dong-ting-zhi-chong-qi-kai-ji-zi-qi-dong-fu-wu" class="header-anchor">#</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">systemctl start sshd //启动ssh服务</span><br><span class="line"></span><br><span class="line">systemctl stop sshd //停止ssh服务</span><br><span class="line"> </span><br><span class="line">systemctl restart sshd //重启ssh服务</span><br><span class="line"></span><br><span class="line">systemctl enable sshd //开机自启动ssh服务</span><br><span class="line"></span><br><span class="line">docker 和其他服务也适用</span><br></pre></td></tr></table></figure><h1><span id="wen-jian-nei-rong-fu-gai-zhui-jia-nei-rong-cat-ming-ling">文件内容覆盖/追加内容（cat命令）</span><a href="#wen-jian-nei-rong-fu-gai-zhui-jia-nei-rong-cat-ming-ling" class="header-anchor">#</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat  textfile1 &gt; textfile2 //使用“&gt;” 重定向后 文件 中原本的内容会被覆盖</span><br><span class="line"></span><br><span class="line">cat  textfile1 &gt;&gt; textfile2 //&quot;&gt;&gt;&quot; 代表 将输出的内容已追加的方式重定向到文件</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>cat 原单词concatenate(用途是连接文件或标准输入并打印。)<br>cat 命令用于将所有文件内容打印到屏幕上。<br>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 文件</span><br></pre></td></tr></table></figure><h1><span id="linux-zhong-de-amp-amp-he-amp-he">linux中的&amp;&amp; 和 &amp;，| 和 ||</span><a href="#linux-zhong-de-amp-amp-he-amp-he" class="header-anchor">#</a></h1><blockquote><p>在linux中，&amp;和&amp;&amp;,|和||介绍如下：<br><br><br>&amp;  表示任务在后台执行，如要在后台运行redis-server,则有  redis-server &amp;<br><br><br>&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令 ，如 echo ‘1‘ &amp;&amp; echo ‘2’<br><br><br>| 表示管道，上一条命令的输出，作为下一条命令参数，如 echo ‘yes’ | wc -l<br><br><br>|| 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo “fail”</p></blockquote><p>具体案例：<br>1.rpm -qa | grep mysql</p><blockquote><p>rpm -qa会输出符合筛选条件的软件套件，然后使用grep 筛选与mysql相关的软件套件</p></blockquote><h1><span id="rpm-ming-ling">rpm命令</span><a href="#rpm-ming-ling" class="header-anchor">#</a></h1><blockquote><p>Linux rpm 命令用于管理套件。<br><br><br>rpm（英文全拼：redhat package manager） 原本是 Red Hat Linux 发行版专门用来管理 Linux<br>各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux<br>易于安装，升级，间接提升了 Linux 的适用度。<br><br>因为是redhat的，所以这个命令对ubuntu不适用，一般就是centos用，看看是否安装了或有某个软件的套件</p></blockquote><p>实例：</p><p>1.安装软件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># rpm -hvi dejagnu-1.4.2-10.noarch.rpm </span><br><span class="line">警告：dejagnu-1.4.2-10.noarch.rpm: V3 DSA 签名：NOKEY, key ID db42a60e</span><br><span class="line">准备...           </span><br><span class="line">########################################### [100%]</span><br></pre></td></tr></table></figure><p>2.显示软件安装信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># rpm -qi dejagnu-1.4.2-10.noarch.rpm</span><br><span class="line"></span><br><span class="line">【第1次更新 教程、类似命令关联】</span><br></pre></td></tr></table></figure><p>3.检查是否已经安装过mysql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br></pre></td></tr></table></figure><p>4.删除mysql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps mysql-libs-5.1.73-5.el6_6.x86_64  </span><br><span class="line">//-e&lt;套件档&gt;或--erase&lt;套件档&gt; 　删除指定的套件。</span><br><span class="line">//--nodeps 　不验证套件档的相互关联性。</span><br></pre></td></tr></table></figure><h1><span id="cha-kan-xi-tong-ban-ben">查看系统版本</span><a href="#cha-kan-xi-tong-ban-ben" class="header-anchor">#</a></h1><h2><span id="centos">centos</span><a href="#centos" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br></pre></td></tr></table></figure><h1><span id="geng-huan-yum-yuan">更换yum源</span><a href="#geng-huan-yum-yuan" class="header-anchor">#</a></h1><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/centos/">更换为清华源</a></p><ol><li>建议先备份 /etc/yum.repos.d/ 内的文件（CentOS 7 及之前为 CentOS-Base.repo，CentOS 8 为CentOS-Linux-*.repo）</li><li>然后编辑 /etc/yum.repos.d/ 中的相应文件，在 mirrorlist= 开头行前面加 # 注释掉；并将 baseurl= 开头行取消注释（如果被注释的话），把该行内的域名（例如mirror.centos.org）替换为 mirrors.tuna.tsinghua.edu.cn。</li><li>以上步骤可以被下方的命令一步完成</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -e &#x27;s|^mirrorlist=|#mirrorlist=|g&#x27; \</span><br><span class="line">        -e &#x27;s|^#baseurl=http://mirror.centos.org|baseurl=https://mirrors.tuna.tsinghua.edu.cn|g&#x27; \</span><br><span class="line">        -i.bak \</span><br><span class="line">        /etc/yum.repos.d/CentOS-*.repo</span><br></pre></td></tr></table></figure><blockquote><p>注意其中的*通配符，如果只需要替换一些文件中的源，请自行增删。<br><br><br>注意，如果需要启用其中一些 repo，需要将其中的 enabled=0 改为 enabled=1。<br><br></p></blockquote><p>4.最后，更新软件包缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum makecache</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#fu-zhi-yi-dong-wen-jian-wen-jian-gai-ming&quot;&gt;复制/移动文件、文件改名&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#cha-kan-d</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="运维" scheme="http://example.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins知识点</title>
    <link href="http://example.com/2022/01/15/Jenkins%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://example.com/2022/01/15/Jenkins%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-01-15T07:59:58.635Z</published>
    <updated>2022-01-15T08:00:56.587Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#liu-shui-xian-yu-fa-zhao-bu-dao-mo-ban">流水线语法找不到模板</a></li><li><a href="#publish-over-ssh-lian-jie-shi-bai">Publish over ssh连接失败</a></li><li><a href="#wu-fa-zhi-xing-yuan-cheng-jiao-ben">无法执行远程脚本</a></li></ul><!-- tocstop --></div><h1><span id="liu-shui-xian-yu-fa-zhao-bu-dao-mo-ban">流水线语法找不到模板</span><a href="#liu-shui-xian-yu-fa-zhao-bu-dao-mo-ban" class="header-anchor">#</a></h1><p><img src="https://img-blog.csdnimg.cn/e93ad73b8c094398bdfc1b49f5388317.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>有时候在“流水线语言”板块找不到模板，即使安装了相对于的插件。如上图，安装了<strong>publish over ssh插件</strong>就会出现这个选项，但是当时没有。</p><p><strong>解决办法：</strong><br>重启jenkins。初始域名后面加/restart</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip:port/restart</span><br></pre></td></tr></table></figure><h1><span id="publish-over-ssh-lian-jie-shi-bai">Publish over ssh连接失败</span><a href="#publish-over-ssh-lian-jie-shi-bai" class="header-anchor">#</a></h1><p><img src="https://img-blog.csdnimg.cn/72c9e5709ded45fcadfc75afc94e0baf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>解决办法：</strong><br>这里要填密钥的密码</p><h1><span id="wu-fa-zhi-xing-yuan-cheng-jiao-ben">无法执行远程脚本</span><a href="#wu-fa-zhi-xing-yuan-cheng-jiao-ben" class="header-anchor">#</a></h1><blockquote><p>背景：<br>创建一个jenkins作业，通过ssh在另一台服务器上运行脚本，实现从harbor仓库拉取docker镜像，并运行。<br><br><br>问题： 运行jenkins作业/流水线，在对应的服务器没有镜像和运行的容器，且构建过程没有错误输出。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/833850a8163b42f79d14e14b9551c356.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>分析：<br>由于是照着黑马程序员的视频和资料来的，由于输出的信息不太一样，以为是哪里操作有问题，或者脚本不对，但是重复所有过程和按照网上教程修改脚本均没有成功。然后单独运行脚本，发现出错，类似于下图。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/635aed74d26a41bc84833f34bef37f50.png" alt="在这里插入图片描述"></p><blockquote><p><strong>反应过来是因为Docker没有把Harbor加入信任列表中</strong>，</p><p><br> 加入就好</p><p><code>vim /etc/docker/daemon.json </code></p><p><br> 再次构建出现了错误信息，搜索得知是因为这个命令默认有个时间限制，超过这个时间限制就会出错，断开，类似于联网超时。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/cf2801f8c63a42bb8e91adf61a3f8590.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p><strong>把时间改为0就好</strong></p></blockquote><p><img src="https://img-blog.csdnimg.cn/30e99ed138474b01800e583e61389dfd.png" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#liu-shui-xian-yu-fa-zhao-bu-dao-mo-ban&quot;&gt;流水线语法找不到模板&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#publish-over-s</summary>
      
    
    
    
    <category term="Jenkins" scheme="http://example.com/categories/Jenkins/"/>
    
    
    <category term="运维" scheme="http://example.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Jenkins" scheme="http://example.com/tags/Jenkins/"/>
    
    <category term="持续集成" scheme="http://example.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux Shell 命令</title>
    <link href="http://example.com/2022/01/15/Linux%20Shell%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/01/15/Linux%20Shell%E5%91%BD%E4%BB%A4/</id>
    <published>2022-01-15T07:49:30.400Z</published>
    <updated>2022-01-15T07:59:27.924Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#shi-ji-ming-ling-fen-xi">实际命令分析</a><ul><li><a href="#git-log-follow-pretty-format-h-wen-jian-ming-xargs-i-sh-c-git-show-wen-jian-ming-wen-jian-ming">git log –follow –pretty=format:%H 文件名 | xargs -I{} sh -c ‘git show {}:文件名 &gt; 文件名.{}’</a></li><li><a href="#git-branch-r-xargs-d-n1-grep-v-origin-xargs-i-sh-c-mkdir-c-users-76585-desktop-try">git branch -r | xargs -d/ -n1 | grep -v ‘origin’ | xargs -I{} sh -c ‘mkdir “C:\Users\76585\Desktop\try{}” ‘</a></li></ul></li><li><a href="#dai-ma-fen-xi">代码分析</a><ul><li><a href="#du-qu-wen-jian-jia-zhong-de-wen-jian-ming-bing-cun-ru-lie-biao">读取文件夹中的文件名，并存入列表</a></li></ul></li><li><a href="#bian-liang">变量</a><ul><li><a href="#huo-qu-bian-liang-zi-fu-chuan-chang-du">获取变量字符串长度</a></li><li><a href="#bian-liang-jie-qu">变量截取</a></li><li><a href="#bian-liang-de-zi-fu-chuan-ti-huan">变量的字符串替换</a></li><li><a href="#shan-chu-zi-fu-chuan">删除字符串</a></li><li><a href="#bian-liang-wei-kong-shi-fu-mo-ren-zhi">变量为空时赋默认值</a></li><li><a href="#zi-fu-chuan-pin-jie">字符串拼接</a></li><li><a href="#dan-yin-hao-nei-yin-ru-bian-liang">单引号内引入变量</a></li><li><a href="#shi-zhan-tong-ji-wen-zhang-dan-ci-qing-kuang">实战：统计文章单词情况</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="shi-ji-ming-ling-fen-xi">实际命令分析</span><a href="#shi-ji-ming-ling-fen-xi" class="header-anchor">#</a></h1><h2><span id="git-log-follow-pretty-format-h-wen-jian-ming-xargs-i-sh-c-git-show-wen-jian-ming-gt-wen-jian-ming">git log –follow –pretty=format:%H 文件名 | xargs -I{} sh -c ‘git show {}:文件名 &gt; 文件名.{}’</span><a href="#git-log-follow-pretty-format-h-wen-jian-ming-xargs-i-sh-c-git-show-wen-jian-ming-gt-wen-jian-ming" class="header-anchor">#</a></h2><p>提取git中某个文件的所有版本并按顺序命名:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --follow --pretty=format:%H 文件名 | xargs -I&#123;&#125; sh -c &#x27;git show &#123;&#125;:文件名 &gt; 文件名.&#123;&#125;&#x27;</span><br></pre></td></tr></table></figure><p>简略解释版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git log --follow --pretty=format:%H </span><br><span class="line">//按照一定的格式输出 ，输出某个文件的历史提交哈希值</span><br><span class="line"></span><br><span class="line">| xargs -I&#123;&#125; </span><br><span class="line"></span><br><span class="line">//xargs 一般是和管道(I)一起使用</span><br><span class="line"> //-I&#123;&#125; //xargs 的一个选项 -I，使用 -I 指定一个替换字符串 &#123;&#125;，这个字符串在 xargs 扩展时会被替换掉；对应这里，前面输出的是哈希值，这里面&quot;&#123;&#125;&quot;代表的就是哈希值，后面的&quot;&#123;&#125;&quot;也是前面的哈希值。</span><br><span class="line"></span><br><span class="line">sh -c </span><br><span class="line">//暂时不清，下面有解释</span><br><span class="line"></span><br><span class="line">git show &#123;&#125;:文件名 &gt; 文件名.&#123;&#125; </span><br><span class="line"> //git show &#x27;哈希值&#x27;:文件名：输出这次提交，这个文件夹的内容， &quot;&gt;&quot; 将内容输出到 后面的文件中，并覆盖后面文件内容。</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>| xargs -I{} sh c</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|  //表示管道，上一条命令的输出，作为下一条命令参数，如 echo ‘yes’ | wc -l</span><br><span class="line"></span><br><span class="line">xargs -I //</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sh -c</span><br><span class="line"></span><br><span class="line">Linux使用 echo 并配合命令重定向是实现向文件中写入信息的快捷方式。</span><br><span class="line">【新建空文件】</span><br><span class="line">方式一 : $ touch test.sh</span><br><span class="line">方式二 : $ echo “” &gt; test.sh</span><br><span class="line">【写内容到文件】</span><br><span class="line">如 test.sh 文件中内容：</span><br><span class="line">$ echo “信息” &gt; test.sh</span><br><span class="line"></span><br><span class="line">但有时会出现权限不够的问题，这时就可以使用 sh -c</span><br><span class="line"></span><br><span class="line">利用 “sh -c” 命令，它可以让 bash 将一个字串作为完整的命令来执行，这样就可以将 sudo 的影响范围扩展到整条命令。具体用法如下：</span><br><span class="line">$ sudo sh -c ‘echo “第二条内容” &gt;&gt; test.sh’</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="git-branch-r-xargs-d-n1-grep-v-origin-xargs-i-sh-c-mkdir-c-users-76585-desktop-try">git branch -r | xargs -d/ -n1 | grep -v ‘origin’ | xargs -I{} sh -c ‘mkdir “C:\Users\76585\Desktop\try{}” ‘</span><a href="#git-branch-r-xargs-d-n1-grep-v-origin-xargs-i-sh-c-mkdir-c-users-76585-desktop-try" class="header-anchor">#</a></h2><blockquote><p>用途：给每一个远程分支建立单独的文件夹，文件名就是分支名</p></blockquote><p>分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.  git branch -r //显示远程分支。注意，本地分支可能只有一个，master这种。但远程分支可能有很多个。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. | xargs -d/ -n1 // -d -n都是xargs的参数，详细可以去查文档。-d/  以&quot;/&quot;为分隔符；-n1，每行输出一个。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. grep -v &#x27;origin&#x27; // 遇到origin就不显示（删除这个字符串）。</span><br></pre></td></tr></table></figure><p>冷知识：在Windows下运行sh文件，在当前路径下，<code>./</code>;<br>如果是非当前路径，<code>c/xx/xxx/1.sh  //绝对路径到sh文件就好，前面不用加./</code> </p><h1><span id="dai-ma-fen-xi">代码分析</span><a href="#dai-ma-fen-xi" class="header-anchor">#</a></h1><h2><span id="du-qu-wen-jian-jia-zhong-de-wen-jian-ming-bing-cun-ru-lie-biao">读取文件夹中的文件名，并存入列表</span><a href="#du-qu-wen-jian-jia-zhong-de-wen-jian-ming-bing-cun-ru-lie-biao" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#读取文件夹中的文件名，并存入列表</span><br><span class="line"></span><br><span class="line">i=0</span><br><span class="line">for dir in $(ls &#x27;C:\Users\76585\Desktop\cfdname1&#x27;)</span><br><span class="line">do</span><br><span class="line">    </span><br><span class="line">    # echo $dir &gt;&gt; arr[$i]</span><br><span class="line">    arr[$i]=$dir</span><br><span class="line">    i=$(($i+1))</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;$&#123;arr[@]&#125;&quot;</span><br></pre></td></tr></table></figure><p><strong>注意的点：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.for 循环循环体只能卸载do done之间，之前把 i 写在了for 和 do之间报错</span><br><span class="line"></span><br><span class="line">2.变量初始化不要放在函数体，不然每次循环都清 0 了。</span><br><span class="line"></span><br><span class="line">3.变量自增加方法：</span><br><span class="line">a=\$(($a+1))</span><br><span class="line"></span><br><span class="line">a=$[$a+1]</span><br><span class="line"></span><br><span class="line">a=\`expr $a + 1`</span><br><span class="line"></span><br><span class="line">let a++</span><br><span class="line"></span><br><span class="line">let a+=1</span><br><span class="line"></span><br><span class="line">((a++))</span><br><span class="line"></span><br><span class="line">4.打印数组的方法：$&#123;my_array[*]&#125; 或者 $&#123;my_array[@]&#125;</span><br></pre></td></tr></table></figure><h1><span id="bian-liang">变量</span><a href="#bian-liang" class="header-anchor">#</a></h1><h2><span id="huo-qu-bian-liang-zi-fu-chuan-chang-du">获取变量字符串长度</span><a href="#huo-qu-bian-liang-zi-fu-chuan-chang-du" class="header-anchor">#</a></h2><p>想要知道 “<a href="http://www.baidu.com&quot;/">www.baidu.com&quot;</a> 的变量net的长度十分简单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ net=&quot;www.baidu.com&quot;</span><br><span class="line">[Neptuneyt]$ echo $&#123;#net&#125;</span><br><span class="line">13</span><br></pre></td></tr></table></figure><p>当然，在Shell中获取字符串变量的长度的方法有许多种，但是下图法一作为一种系统内建的方法是最快的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ echo $&#123;#net&#125;</span><br><span class="line">13</span><br><span class="line">[Neptuneyt]$ echo $&#123;net&#125;|wc -L</span><br><span class="line">13</span><br><span class="line">[Neptuneyt]$ expr length $&#123;net&#125;</span><br><span class="line">13</span><br><span class="line">[Neptuneyt]$ echo $&#123;net&#125;|awk &#x27;&#123;print length($0)&#125;&#x27;</span><br><span class="line">13</span><br></pre></td></tr></table></figure><h2><span id="bian-liang-jie-qu">变量截取</span><a href="#bian-liang-jie-qu" class="header-anchor">#</a></h2><p><strong>指定位置截取字符串</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ net=&quot;www.baidu.com&quot;</span><br><span class="line">[Neptuneyt]$ # 从第4个字符截取到baidu</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:4:5&#125; #从第4个字符.开始截取5个字符</span><br><span class="line">baidu</span><br><span class="line">[Neptuneyt]$ # 截取baidu.com</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:4&#125;   #起始位置后不接截取字符长度则默认截取之后所有的</span><br><span class="line">baidu.com</span><br><span class="line">[Neptuneyt]$ # 用倒数截取com</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:0-3&#125; #从倒数第三个字符截取到末尾</span><br><span class="line">com</span><br><span class="line">[Neptuneyt]$ echo $&#123;net: -3&#125; #另外的写法，一定要注意冒号和-3之间有空格</span><br><span class="line">com</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:-3&#125;  #不加空格，截取失败</span><br><span class="line">www.baidu.com</span><br></pre></td></tr></table></figure><p><strong>匹配字符串截取</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ echo $net</span><br><span class="line">www.baidu.com</span><br><span class="line"></span><br><span class="line"># 删除匹配字符串的左边，留下剩余部分</span><br><span class="line">[Neptuneyt]$ echo $&#123;net#*.&#125; #这里用*.表示匹配到www.，用一个#表示删除匹配到的字符串，留下剩余的部分</span><br><span class="line">baidu.com</span><br><span class="line"></span><br><span class="line"># 用2个#号表示尽可能多的删除匹配到的字符串</span><br><span class="line">[Neptuneyt]$ echo $&#123;net##*.&#125;</span><br><span class="line">com</span><br><span class="line"></span><br><span class="line"># 同理也可以匹配字符串的右边，留下剩余部分</span><br><span class="line">[Neptuneyt]$ echo $&#123;net%.*&#125; #用.*匹配到.com,用%删除</span><br><span class="line">www.baidu</span><br><span class="line"></span><br><span class="line"># 用2个%号表示尽可能多的删除匹配到的字符串</span><br><span class="line">[Neptuneyt]$ echo $&#123;net%%.*&#125;    #因为2个%，这里.*表示匹配到最长的.baidu.com</span><br></pre></td></tr></table></figure><p>总的来说:<br><code>#*chr</code>表示删除从左到右第一个遇到的字符chr及其左侧的字符<br><code>##*chr</code>表示删除从左到右最后一个遇到的字符chr及其左侧的字符（贪婪模式）<br><code>%chr*</code>表示删除从右向左第一个遇到的字符chr及其右侧的字符<br><code>%%chr*</code>表示删除从右到左最后一个遇到的字符chr及其右侧的字符（贪婪模式）<br>在键盘上，#在$符的左边，%号在$符的右边，为了便于记忆，大家因此可以记住#删除左边字符，%删除右边字符</p><h2><span id="bian-liang-de-zi-fu-chuan-ti-huan">变量的字符串替换</span><a href="#bian-liang-de-zi-fu-chuan-ti-huan" class="header-anchor">#</a></h2><p>想要将net的 baidu替换成google怎么写呢？只需<code>$&#123;net/baidu/google&#125;</code>即可，需要注意的是原变量并未修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ echo $&#123;net/baidu/google&#125; #/匹配字符/替换字符</span><br><span class="line">www.google.com</span><br><span class="line">[Neptuneyt]$ echo $net  #原变量并未修改</span><br><span class="line">www.baidu.com</span><br></pre></td></tr></table></figure><p>如果是替换所有匹配到的字符，应该通过<code>$&#123;variable//pattern/sub&#125;</code><br>例如将net的.替换为-或/：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ echo $&#123;net//./-&#125;</span><br><span class="line">www-baidu-com</span><br><span class="line">[Neptuneyt]$ echo $&#123;net//.//&#125;</span><br><span class="line">www/baidu/com</span><br></pre></td></tr></table></figure><p>除此之外，还有两种专门针对字符串开头和结尾的替换方式<br>只替换开头匹配的字符串<code>$&#123;variable/#pattern/sub&#125;</code><br>只替换结尾匹配的字符串<code>$&#123;variable/%pattern/sub&#125;</code><br>例如对于<code>add=www.xiaomi.com.www</code>的开头或者结尾的<code>www</code>替换为<code>-</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ add=www.xiaomi.com.www</span><br><span class="line">[Neptuneyt]$ echo $&#123;add/#www/-&#125;</span><br><span class="line">-.xiaomi.com.www</span><br><span class="line">[Neptuneyt]$ echo $&#123;add/%www/-&#125;</span><br><span class="line">www.xiaomi.com.-</span><br></pre></td></tr></table></figure><h2><span id="shan-chu-zi-fu-chuan">删除字符串</span><a href="#shan-chu-zi-fu-chuan" class="header-anchor">#</a></h2><p>其实学会了替换字符串删除字符串就更简单了，只需将替换部分写成空即可，即<code>$&#123;variable/pattern/null&#125;</code>，例如将net的第一个.删除，只需</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ echo $&#123;net/./&#125;</span><br><span class="line">wwwbaidu.com</span><br><span class="line">[Neptuneyt]$ echo $&#123;net/.&#125;  #最后一个/可以不用写</span><br><span class="line">wwwbaidu.com</span><br></pre></td></tr></table></figure><p>若要删除所有匹配到的只需即<code>$&#123;variable//pattern&#125;</code>，例如将<code>net</code>的.都删除，只需</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ echo $&#123;net//.&#125;</span><br><span class="line">wwwbaiducom</span><br></pre></td></tr></table></figure><h2><span id="bian-liang-wei-kong-shi-fu-mo-ren-zhi">变量为空时赋默认值</span><a href="#bian-liang-wei-kong-shi-fu-mo-ren-zhi" class="header-anchor">#</a></h2><p>当我们在写脚本时往往需要给脚本传递一些参数，在Shell中传递参数十分简单，只需利用特殊的位置参数变量诸如<code>$1,$2,$3...$&#123;10&#125;...</code>即可，例如，以下脚本传递2个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># PassArgument.sh</span><br><span class="line">#!/bin/env bash</span><br><span class="line"># pass 2 arguments</span><br><span class="line">arg1=$1</span><br><span class="line">arg2=$2</span><br><span class="line">echo $arg1 $arg2</span><br><span class="line"></span><br><span class="line">[Neptuneyt]$ bash PassArgument.sh Hello word #参数以空格隔开</span><br><span class="line">Hello word</span><br></pre></td></tr></table></figure><p>有时候，我们想省掉最后一个参数，让它使用默认值，这个时候只需通过<code>$&#123;variable:=&#39;default value&#39;&#125;</code>即可，即当变量有值的时候则使用原值，若没有值则使用括号中默认定义好的值。例如，如下脚本表示当第二个参数为空时默认使用定义好的值“word”,否则是用户自己传递的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># PassArgument.sh</span><br><span class="line">#!/bin/env bash</span><br><span class="line">arg1=$1</span><br><span class="line">arg2=$2</span><br><span class="line">echo $arg1 $&#123;arg2:=&#x27;word&#x27;&#125;  #第二个参数设置默认值</span><br><span class="line"></span><br><span class="line">[Neptuneyt]$ bash PassArgument.sh Hello #第二个参数为空时使用默认值</span><br><span class="line">Hello word</span><br><span class="line">[Neptuneyt]$ bash PassArgument.sh Hello Shell   #第二个参数不为空时使用参数传递的值</span><br><span class="line">Hello Shell</span><br></pre></td></tr></table></figure><p>除了<code>$&#123;variable:=&#39;default value&#39;&#125;</code>外，还有<code>$&#123;variable:-&#39;default value&#39;&#125;</code>,<code>$&#123;variable:+&#39;default value&#39;&#125;</code>和<code>$&#123;variable:？&#39;default value&#39;&#125;</code>，它们有什么区别呢？<br>对于<code>$&#123;variable:=&#39;default value&#39;&#125;</code>，表示变量为空时把默认值赋值给该变量，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ net=</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:=&#x27;www.baidu.com&#x27;&#125;</span><br><span class="line">www.baidu.com</span><br><span class="line">[Neptuneyt]$ echo $net</span><br><span class="line">www.baidu.com</span><br></pre></td></tr></table></figure><p>对于<code>$&#123;variable:-&#39;default value&#39;&#125;</code>,表示变量为空时返回默认值<strong>但是并不把默认值赋值给该变量</strong>， 例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ net=</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:-&#x27;www.baidu.com&#x27;&#125;</span><br><span class="line">www.baidu.com</span><br><span class="line">[Neptuneyt]$ echo $net  #此时，变量依旧为空</span><br></pre></td></tr></table></figure><p>对于<code>$&#123;variable:+&#39;default value&#39;&#125;</code>,则表示变量不为空时，返回默认值，并且也不重新赋值，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ net=www.baidu.com</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:+&#x27;www.google.com&#x27;&#125;</span><br><span class="line">www.google.com</span><br><span class="line">[Neptuneyt]$ echo $net  #不改变变量原值</span><br><span class="line">www.baidu.com</span><br></pre></td></tr></table></figure><p>最后，对于<code>$&#123;variable:？&#39;default value&#39;&#125;</code>,则表示当变量为空时，使用bash风格的报错，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ net=</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:?&#x27;error:null value&#x27;&#125;</span><br><span class="line">-bash: net: error:null value</span><br></pre></td></tr></table></figure><h2><span id="zi-fu-chuan-pin-jie">字符串拼接</span><a href="#zi-fu-chuan-pin-jie" class="header-anchor">#</a></h2><p>在 PHP 中，使用.即可连接两个字符串；<br>在 JavaScript 中，使用+即可将两个字符串合并为一个。<br>在 Shell 中你不需要使用任何运算符，将两个字符串并排放在一起就能实现拼接，非常简单粗暴。请看下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">name=&quot;Shell&quot;</span><br><span class="line">url=&quot;http://c.biancheng.net/shell/&quot;</span><br><span class="line">str1=$name$url  #中间不能有空格</span><br><span class="line">str2=&quot;$name $url&quot;  #如果被双引号包围，那么中间可以有空格</span><br><span class="line">str3=$name&quot;: &quot;$url  #中间可以出现别的字符串</span><br><span class="line">str4=&quot;$name: $url&quot;  #这样写也可以</span><br><span class="line">str5=&quot;$&#123;name&#125;Script: $&#123;url&#125;index.html&quot;  #这个时候需要给变量名加上大括号</span><br><span class="line">echo $str1</span><br><span class="line">echo $str2</span><br><span class="line">echo $str3</span><br><span class="line">echo $str4</span><br><span class="line">echo $str5</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">Shellhttp://c.biancheng.net/shell/</span><br><span class="line">Shell http://c.biancheng.net/shell/</span><br><span class="line">Shell: http://c.biancheng.net/shell/</span><br><span class="line">Shell: http://c.biancheng.net/shell/</span><br><span class="line">ShellScript: http://c.biancheng.net/shell/index.html</span><br></pre></td></tr></table></figure><p>对于第 7 行代码，$name 和 $url 之间之所以不能出现空格，是因为当字符串不被任何一种引号包围时，遇到空格就认为字符串结束了，空格后边的内容会作为其他变量或者命令解析，这一点在《Shell字符串》中已经提到。</p><p>对于第 10 行代码，加{ }是为了帮助解释器识别变量的边界，这一点在《Shell变量》中已经提到。</p><h2><span id="dan-yin-hao-nei-yin-ru-bian-liang">单引号内引入变量</span><a href="#dan-yin-hao-nei-yin-ru-bian-liang" class="header-anchor">#</a></h2><p><strong>方法：单引号内嵌套单引号即可使用变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">i=10</span><br><span class="line">echo $i</span><br><span class="line">echo &#x27;$i&#x27;</span><br><span class="line">echo &#x27;$i is : &#x27;$i&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">执行结果</span><br><span class="line"></span><br><span class="line"># ./test.sh </span><br><span class="line">10</span><br><span class="line">$i</span><br><span class="line">$i is : 10</span><br></pre></td></tr></table></figure><h2><span id="shi-zhan-tong-ji-wen-zhang-dan-ci-qing-kuang">实战：统计文章单词情况</span><a href="#shi-zhan-tong-ji-wen-zhang-dan-ci-qing-kuang" class="header-anchor">#</a></h2><p>这里想要统计Martin Luther King在1963年著名的<strong>I have a dream</strong>演讲中都使用了哪些词，哪些是高频词，单词字长如何。<br><img src="https://img-blog.csdnimg.cn/4f3976bb28594f89ab73d74c1d5b4448.png" alt="在这里插入图片描述"><br>思路：<br>高频词统计：将所有单词单行输出，删除空行，删除<code>,./?</code>等非字母符号，用sort排序后使用uniq统计即可。<br>字长频数统计：将所有单词单行输出，删除空行，删除<code>,./?</code>等非字母符号，使用while循环遍历每个单词，使用`$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#shi-ji-ming-ling-fen-xi&quot;&gt;实际命令分析&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#git-log-follow-pretty-format-h-wen</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="运维" scheme="http://example.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>前端知识</title>
    <link href="http://example.com/2022/01/15/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2022/01/15/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86/</id>
    <published>2022-01-15T07:40:47.822Z</published>
    <updated>2022-01-15T07:47:11.320Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#react">React</a><ul><li><a href="#qi-dong-liu-cheng">启动流程</a></li><li><a href="#react-router-dom-lu-you">react-router-dom路由</a><ul><li><a href="#an-zhuang">安装</a></li><li><a href="#ji-ben-cao-zuo">基本操作</a></li></ul></li></ul></li><li><a href="#javascript">Javascript</a><ul><li><a href="#jian-tou-han-shu">箭头函数</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="react">React</span><a href="#react" class="header-anchor">#</a></h1><h2><span id="qi-dong-liu-cheng">启动流程</span><a href="#qi-dong-liu-cheng" class="header-anchor">#</a></h2><p>重点关注三个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">src/App.js //实现 React 组件</span><br><span class="line"></span><br><span class="line">src/index.js // React 世界的入口</span><br><span class="line"></span><br><span class="line">public/index.html //挂载的页面</span><br></pre></td></tr></table></figure><p>1.index.html</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个是一个模板文件，里面有过id为root的div标签，会被index.js文件中的JSX替换这个DOM节点。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c8637d56e86b4868a275d4a01a1db9c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>2.index.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">关键就是这个ReactDOM.render()</span><br><span class="line"></span><br><span class="line">简单来说，ReactDOM.render() 会使用你的 JSX 来替换你的 HTML 中的一个 DOM 节点。这</span><br><span class="line">样你就可以很容易地把 React 集成到每一个其他的应用中。ReactDOM.render() 可以在你的</span><br><span class="line">应用中被多次使用。你可以在多个地方使用它来加载简单的 JSX 语法、单个 React 组件、</span><br><span class="line">多个 React 组件或者整个应用。但是在一个纯 React 的应用中，你只会使用一次用来加载你</span><br><span class="line">的整个组件树。</span><br><span class="line">ReactDOM.render() 有两个传入参数。第一个是准备渲染的 JSX。第二个参数指定了 React</span><br><span class="line">应用在你的 HTML 中的放置的位置。这个位置是一个 id=&#x27;root&#x27; 的元素。你可以在文件</span><br><span class="line">public/index.html 中找到这个 id 属性</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5a6381d4f99b4a56b00f07e3ee28f9c7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>3.App.js<br>在inde.js文件里面，ReactDOM.render() 总会很好地渲染你的 App 组件。一般来说，某个组件叫xxx，那么他的代码就叫xxx.js。要想知道页面被渲染成什么样，就看看里面内容。<br><img src="https://img-blog.csdnimg.cn/378a772ce66d41e9b70b563c6319a470.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2><span id="react-router-dom-lu-you">react-router-dom路由</span><a href="#react-router-dom-lu-you" class="header-anchor">#</a></h2><p><a href="https://www.jianshu.com/p/8954e9fb0c7e">原文章链接</a><br>来源：简书</p><p><strong>使用背景：使用React构建的单页面应用，要想实现页面间的跳转，首先想到的就是使用路由。在React中，常用的有两个包可以实现这个需求，那就是react-router和react-router-dom。本文主要针对react-router-dom进行说明。</strong></p><h3><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor">#</a></h3><p>首先进入项目目录，使用npm安装react-router-dom：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install react-router-dom --save-dev //这里可以使用cnpm代替npm命令；</span><br><span class="line"></span><br><span class="line">//--save-dev 标记表示该 node 包只是用作开发环境的一部分，并不会被作为你产品代码的一</span><br><span class="line">部分发布。哪种 node 包适用这个场景呢？设想你需要一些 node 包辅助测试你的应用，然</span><br><span class="line">后需要通过 npm 来安装这些包，但是不希望他们混入产品代码里面。测试过程应该只会发</span><br><span class="line">生在开发阶段，而不是在线上部署运行的时候。因为那个时候已经用不到测试代码了，你</span><br><span class="line">的应用应该已经被测试完而且可以被你的用户使用了。这可能是你唯一的使用 --save-dev</span><br><span class="line">的场景。</span><br></pre></td></tr></table></figure><h3><span id="ji-ben-cao-zuo">基本操作</span><a href="#ji-ben-cao-zuo" class="header-anchor">#</a></h3><p>然后我们新建两个页面，分别命名为“home”和“detail”。在页面中编写如下代码：<br>detail.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default class Home extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a&gt;去detail&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>home.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default class Home extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a&gt;回到home&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再新建一个路由组件，命名为“Router.js”，并编写如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123;HashRouter, Route, Switch&#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line">import Home from &#x27;../home&#x27;;</span><br><span class="line">import Detail from &#x27;../detail&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const BasicRoute = () =&gt; (</span><br><span class="line">    &lt;HashRouter&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route exact path=&quot;/detail&quot; component=&#123;Detail&#125;/&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">    &lt;/HashRouter&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">export default BasicRoute;</span><br></pre></td></tr></table></figure><p>如上代码定义了一个纯路由组件，将两个页面组件Home和Detail使用Route组件包裹，外面套用Switch作路由匹配，当路由组件检测到地址栏与Route的path匹配时，就会自动加载响应的页面。<br>然后在入口文件中——我这里指定的是index.js——编写如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">import Router from &#x27;./router/router&#x27;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Router/&gt;,</span><br><span class="line">  document.getElementById(&#x27;root&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这里相当于向页面返回了一个路由组件。我们先运行项目看一下效果，在地址栏输入“<a href="http://localhost:3000/#/%E2%80%9D%EF%BC%9A">http://localhost:3000/#/”：</a><br><img src="https://img-blog.csdnimg.cn/37aee935c7534aa39a98acfcf884e278.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>输入“<a href="http://localhost:3000/#/detail%E2%80%9D%EF%BC%9A">http://localhost:3000/#/detail”：</a><br><img src="https://img-blog.csdnimg.cn/891f1a191f764e2295b057870300cd76.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>通过a标签跳转</strong><br>可以看到其实路由已经开始工作了，接下来我们再来做页面间的跳转。在home.js和detail.js中，我们修改如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    export default class Home extends React.Component &#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                &lt;a href=&#x27;#/detail&#x27;&gt;去detail&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>home.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default class Home extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a href=&#x27;#/&#x27;&gt;回到home&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新打包运行，在浏览器地址栏输入“<a href="http://localhost:3000/%E2%80%9D%EF%BC%8C%E8%AF%95%E8%AF%95%E7%9C%8B%E9%A1%B5%E9%9D%A2%E8%83%BD%E5%90%A6%E6%AD%A3%E5%B8%B8%E8%B7%B3%E8%BD%AC%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%8D%E8%83%BD%EF%BC%8C%E8%AF%B7%E6%8C%89%E6%AD%A5%E9%AA%A4%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%A3%80%E6%9F%A5%E4%BB%A3%E7%A0%81%E6%98%AF%E5%90%A6%E6%9C%89%E8%AF%AF%E3%80%82%E4%BB%A5%E4%B8%8A%E6%98%AF%E4%BD%BF%E7%94%A8a%E6%A0%87%E7%AD%BE%E7%9A%84href%E8%BF%9B%E8%A1%8C%E9%A1%B5%E9%9D%A2%E9%97%B4%E8%B7%B3%E8%BD%AC%EF%BC%8C%E6%AD%A4%E5%A4%96react-router-dom%E8%BF%98%E6%8F%90%E4%BE%9B%E4%BA%86%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E8%B7%B3%E8%BD%AC%E9%A1%B5%E9%9D%A2%E3%80%82">http://localhost:3000/”，试试看页面能否正常跳转。如果不能，请按步骤一步一步检查代码是否有误。以上是使用a标签的href进行页面间跳转，此外react-router-dom还提供了通过函数的方式跳转页面。</a></p><p><strong>通过函数跳转</strong></p><p>首先我们需要修改router.js中的两处代码：<br>然后在home.js中：<br>import React from ‘react’;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">import &#123;HashRouter, Route, Switch, hashHistory&#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line">...</span><br><span class="line">&lt;HashRouter history=&#123;hashHistory&#125;&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在a标签下面添加一个按钮并加上onClick事件，通过this.props.history.push这个函数跳转到detail页面。在路由组件中加入的代码就是将history这个对象注册到组件的props中去，然后就可以在子组件中通过props调用history的push方法跳转页面。</p><p>很多场景下，我们还需要在页面跳转的同时传递参数，在react-router-dom中，同样提供了两种方式进行传参。</p><p>链接：<a href="https://www.jianshu.com/p/8954e9fb0c7e">https://www.jianshu.com/p/8954e9fb0c7e</a><br>来源：简书</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default class Home extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a href=&#x27;#/detail&#x27;&gt;去detail&lt;/a&gt;</span><br><span class="line">                &lt;button onClick=&#123;() =&gt; this.props.history.push(&#x27;detail&#x27;)&#125;&gt;通过函数跳转&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>url传参</strong><br>在router.js中，修改如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;Route exact path=&quot;/detail/:id&quot; component=&#123;Detail&#125;/&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后修改detail.js，使用this.props.match.params获取url传过来的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">    console.log(this.props.match.params);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在地址栏输入“<a href="http://localhost:3000/#/detail/3%E2%80%9D%EF%BC%8C%E6%89%93%E5%BC%80%E6%8E%A7%E5%88%B6%E5%8F%B0%EF%BC%9A">http://localhost:3000/#/detail/3”，打开控制台：</a><br><img src="https://img-blog.csdnimg.cn/d803a9af4817410c8649c09bbf06cdea.png" alt="在这里插入图片描述"><br>可以看到传过去的id=3已经被获取到了。react-router-dom就是通过“/:”去匹配url传递的参数。</p><p><strong>隐式传参</strong><br>此外还可以通过push函数隐式传参。</p><p>修改home.js代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default class Home extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a href=&#x27;#/detail/3&#x27;&gt;去detail&lt;/a&gt;</span><br><span class="line">                    &lt;button onClick=&#123;() =&gt; this.props.history.push(&#123;</span><br><span class="line">                        pathname: &#x27;/detail&#x27;,</span><br><span class="line">                        state: &#123;</span><br><span class="line">                            id: 3</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)&#125;&gt;通过函数跳转&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在detail.js中，就可以使用this.props.history.location.state获取home传过来的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    //console.log(this.props.match.params);</span><br><span class="line">    console.log(this.props.history.location.state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳转后打开控制台可以看到参数被打印：<br><img src="https://img-blog.csdnimg.cn/972fb5894c804e8c9203fc6d304cf0c5.png" alt="在这里插入图片描述"><br><strong>嵌套路由</strong></p><p>嵌套路由的适用场景还是比较多的，接下来就来介绍一下实现方法。<br>首先在Vue中实现嵌套路由，只需要将配置文件写成children嵌套，然后在需要展示子路由的位置加上<router-view></router-view>即可。React中应该如何实现呢？其实原理和Vue类似，只需要在父级路由中包含子路由即可。这样说可能很多同学会一头雾水，直接上代码（不使用上面的例子）：</p><p>首先定义父级组件MainLayout</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#x27;./MainLayout.scss&#x27;;</span><br><span class="line"></span><br><span class="line">const &#123; Header, Sider, Content &#125; = Layout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default class MainLayout extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&#x27;main-layout&#x27;&gt;</span><br><span class="line">                父组件</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义子组件Home：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;useState&#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123;Modal, Select&#125; from &quot;antd&quot;;</span><br><span class="line">import &#123;connect&#125; from &#x27;react-redux&#x27;;</span><br><span class="line">import &#123;addCount&#125; from &#x27;../../servers/home&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Home(props) &#123;</span><br><span class="line">    const [visible, setVisible] = useState(false);</span><br><span class="line">    const &#123;countNum: &#123;count&#125;, dispatch&#125; = props;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            子组件</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Home;</span><br></pre></td></tr></table></figure><p>然后将它们添加进路由router.js，并且关联父子关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123;HashRouter, Route, Switch&#125; from &quot;react-router-dom&quot;;</span><br><span class="line">import Home from &#x27;../pages/Home/Home&#x27;;</span><br><span class="line">import MainLayout from &#x27;../layout/MainLayout&#x27;;</span><br><span class="line"></span><br><span class="line">const BasicRouter = () =&gt; (</span><br><span class="line">    &lt;HashRouter&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=&quot;/index&quot; component=&#123;</span><br><span class="line">                &lt;MainLayout&gt;</span><br><span class="line">                  &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">                  &lt;Route exact path=&quot;/index&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">                  &lt;Route path=&quot;/index/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">                &lt;/MainLayout&gt;</span><br><span class="line">             &#125;/&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">    &lt;/HashRouter&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default BasicRouter;</span><br></pre></td></tr></table></figure><p>在MainLayout中，修改如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#x27;./MainLayout.scss&#x27;;</span><br><span class="line"></span><br><span class="line">const &#123; Header, Sider, Content &#125; = Layout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default class MainLayout extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&#x27;main-layout&#x27;&gt;</span><br><span class="line">                &#123;this.props.children&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，一个嵌套路由就完成了。</p><h1><span id="javascript">Javascript</span><a href="#javascript" class="header-anchor">#</a></h1><h2><span id="jian-tou-han-shu">箭头函数</span><a href="#jian-tou-han-shu" class="header-anchor">#</a></h2><p>箭头函数本质还是函数，我们来看看他与JavaScript中普通函数的区别，先看看写法上的区别。<br><img src="https://img-blog.csdnimg.cn/2b6243000b0d48f69f6baf1e77293818.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>解释</strong><br>写箭头函数，我们记住一个顺序就好，参数、箭头、函数体、这个顺序记住就足够了，参数、箭头、函数体、这三个是必须的，函数名可以没有，但这三项必须有，一些简写的方式也是简写这三项里的东西。</p><p><strong>简写</strong><br>1、只有一个参数时，() 可省略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//不简写</span><br><span class="line">var demo = (x) =&gt;&#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//简写</span><br><span class="line">var demo = x =&gt;&#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、函数体只有一句时， {} 可以省略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//不简写</span><br><span class="line">var demo = (x) =&gt;&#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//简写</span><br><span class="line">var demo = x =&gt; console.log(x);</span><br></pre></td></tr></table></figure><p>3、函数体只有一条返回语句时，{} 和 return 都可以省略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//不简写</span><br><span class="line">var demo = (x) =&gt; &#123;</span><br><span class="line">     return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//简写</span><br><span class="line">var demo = (x) =&gt; x;   </span><br><span class="line"></span><br><span class="line">//注意别写成这样  </span><br><span class="line">var demo = (x) =&gt;&#123; x &#125;;  </span><br><span class="line">//或者 这样  </span><br><span class="line">var demo = (x) =&gt; return  x;  </span><br><span class="line">//要省略就都省略，不省略就都不省，别省一半,不然会出错的。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>箭头函数放 参数 的地方就在 () 内，<br>没有参数，() 必须写，<br>一个参数，() 可写可不写，<br>多个参数，() 必须写。</p><p>箭头函数放 函数体 的地方在 {}内，<br>函数体 就 一句 {} 可写可不写，<br>函数体 不止一句，{} 必须写。</p><p>如果不知道，() {} 写不写，该不该省略，那就写，写了不会错。</p><p><strong>箭头函数 如果要返回一个对象，要简写的话， 需要用()包住这个对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//不简写</span><br><span class="line">var demo = () =&gt;&#123; </span><br><span class="line">    return &#123;x:1&#125;;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">//简写</span><br><span class="line">var demo = () =&gt;(&#123;x:1&#125;);</span><br></pre></td></tr></table></figure><p>为什么会这样？因为如果不加 () ，那{ } 就表示的是语法块，不是表示一个对象，而加上()，按照规范来说，() 里面 { } 就会被解析为对象了。</p><p>对于 {x:1} 这个情况，他不仅可以表示一个对象，这个对象有个x属性，值为1，也可以表示为语法块中含有 名为 x 的 label，忘记 label语法的话，可以看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label">这里</a><br>如果不是很明白，可以看看这个<a href="https://www.zhihu.com/question/40902815">回答</a>，应该会理解的更加深刻。<br>所以这也解释了为什么会出现下面代码中的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 不报错</span><br><span class="line">var demo = () =&gt;&#123;x:1&#125;;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">var demo = (y) =&gt;&#123;y,x:1&#125;;</span><br></pre></td></tr></table></figure><p><strong>对象的方法用 箭头函数写时，this 的指向 可能和你想的不一样</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.name=&#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">    show_name:() =&gt;&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">obj.show_name(); //window</span><br></pre></td></tr></table></figure><p>JavaScript使用的是函数作用域，在上面这段代码中对象的括号是不能封闭作用域的，所以此时的this还是指向window。<br>我们换成普通函数看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.name=&#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">    show_name: function ()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">obj.show_name();  //obj</span><br></pre></td></tr></table></figure><p>换成普通函数，this 就不是指向window，而是指向 obj 对象了</p><p>箭头函数 与 普通函数 其他的区别</p><blockquote><p>1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。<br> 2、箭头函数 this不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。<br>  3、箭头函数 不能用 new关键字来实例化对象，不然会报错。<br>  4、箭头函数没有arguments对象。</p></blockquote><p>1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.name = &#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">    show_name:function ()&#123;</span><br><span class="line">        function fn ()&#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.show_name();  // window</span><br></pre></td></tr></table></figure><p>声明一个 obj 对象，有一个name属性 与 show_name方法，上面这段代码，我的本意是想显示 obj对象的name， 但是没和我想的一样，一般我们会用 一个变量 self 或者 that 之类的留住this,像这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">window.name = &#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">    show_name:function ()&#123;</span><br><span class="line">        //留住this</span><br><span class="line">        var that = this;</span><br><span class="line">        function fn ()&#123;</span><br><span class="line">            console.log(that.name);</span><br><span class="line">        &#125;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.show_name();  //obj</span><br></pre></td></tr></table></figure><p>通常来说，箭头函数内部的this就是外层代码块的this</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.name = &#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">    show_name:function ()&#123;</span><br><span class="line">        var fn = () =&gt; &#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.show_name(); //obj</span><br></pre></td></tr></table></figure><p>2、箭头函数 this 不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.name = &#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">function show_name()&#123;</span><br><span class="line">    //这里 show_name 是一个普通的全局函数，所以他的this指window</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">//用了 call 方法，把 show_nam 的this 指向了 obj 对象</span><br><span class="line">show_name.call(obj);  //obj</span><br></pre></td></tr></table></figure><p>箭头函数 this 不可变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.name = &#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">var show_name = () =&gt; &#123;</span><br><span class="line">    //这里 show_name 是箭头函数，他的this指window，并且不会变</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">//用了 call 方法，但是 this 没变，所以打印了 window</span><br><span class="line">show_name.call(obj);  //window</span><br></pre></td></tr></table></figure><p>3、箭头函数 不能用 new 关键字来实例化对象，不然会报错，箭头函数的this 不可变，new 也改变不了 this的 指向，而且更为重要的是，箭头函数内部并没有 [[Construct]] 方法，所以会没有原型属性（prototype），所以箭头函数没法当构造函数。</p><p><img src="https://img-blog.csdnimg.cn/7803115884ae4f6ab5f8d4cd73cfe038.png" alt="在这里插入图片描述"><br>4、箭头函数没有arguments对象，不能通过arguments对象访问传入参数，但是可以用rest参数实现<br>。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters">不了解的看这里</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var demo = (...theArgs) =&gt; theArgs;</span><br><span class="line">demo(1,2,3); //[1,2,3]</span><br></pre></td></tr></table></figure><p><strong>总结</strong><br>在来看一遍 箭头函数 与 普通函数，除了写法上的区别</p><blockquote><p>1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。<br>2、箭头函数 this不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。<br>3、箭头函数 不能用 new关键字来实例化对象，不然会报错。<br>4、箭头函数没有arguments对象。</p></blockquote><p>可以看出，最重要的区别还是 在 this 上，所以要想用好 箭头函数，还是要对 this 有一定认识的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#react&quot;&gt;React&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#qi-dong-liu-cheng&quot;&gt;启动流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#react-</summary>
      
    
    
    
    <category term="前端开发" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/08/1/"/>
    <id>http://example.com/2022/01/08/1/</id>
    <published>2022-01-08T08:01:18.144Z</published>
    <updated>2022-01-08T08:01:09.895Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#1">1.一级目录</a></p><p><a href="#1.1">1.1二级目录</a>　　</p><p><a href="#1.1.1">1.1.1三级目录</a></p><h2><span id="yi-ji-mu-lu"> 一级目录 </span><a href="#yi-ji-mu-lu" class="header-anchor">#</a></h2><h4><span id="er-ji-mu-lu"> 二级目录 </span><a href="#er-ji-mu-lu" class="header-anchor">#</a></h4><h5><span id="san-ji-mu-lu"> 三级目录 </span><a href="#san-ji-mu-lu" class="header-anchor">#</a></h5>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1.一级目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#1.1&quot;&gt;1.1二级目录&lt;/a&gt;
　　&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#1.1.1&quot;&gt;1.1.1三级目录&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;yi-ji-mu-lu&quot;&gt; 一级目录 &lt;</summary>
      
    
    
    
    
  </entry>
  
</feed>
