<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Welcome to my Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-15T08:00:56.587Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Gaofeng Lin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jenkins知识点</title>
    <link href="http://example.com/2022/01/15/Jenkins%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://example.com/2022/01/15/Jenkins%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-01-15T07:59:58.635Z</published>
    <updated>2022-01-15T08:00:56.587Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#liu-shui-xian-yu-fa-zhao-bu-dao-mo-ban">流水线语法找不到模板</a></li><li><a href="#publish-over-ssh-lian-jie-shi-bai">Publish over ssh连接失败</a></li><li><a href="#wu-fa-zhi-xing-yuan-cheng-jiao-ben">无法执行远程脚本</a></li></ul><!-- tocstop --></div><h1><span id="liu-shui-xian-yu-fa-zhao-bu-dao-mo-ban">流水线语法找不到模板</span><a href="#liu-shui-xian-yu-fa-zhao-bu-dao-mo-ban" class="header-anchor">#</a></h1><p><img src="https://img-blog.csdnimg.cn/e93ad73b8c094398bdfc1b49f5388317.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>有时候在“流水线语言”板块找不到模板，即使安装了相对于的插件。如上图，安装了<strong>publish over ssh插件</strong>就会出现这个选项，但是当时没有。</p><p><strong>解决办法：</strong><br>重启jenkins。初始域名后面加/restart</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip:port/restart</span><br></pre></td></tr></table></figure><h1><span id="publish-over-ssh-lian-jie-shi-bai">Publish over ssh连接失败</span><a href="#publish-over-ssh-lian-jie-shi-bai" class="header-anchor">#</a></h1><p><img src="https://img-blog.csdnimg.cn/72c9e5709ded45fcadfc75afc94e0baf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>解决办法：</strong><br>这里要填密钥的密码</p><h1><span id="wu-fa-zhi-xing-yuan-cheng-jiao-ben">无法执行远程脚本</span><a href="#wu-fa-zhi-xing-yuan-cheng-jiao-ben" class="header-anchor">#</a></h1><blockquote><p>背景：<br>创建一个jenkins作业，通过ssh在另一台服务器上运行脚本，实现从harbor仓库拉取docker镜像，并运行。<br><br><br>问题： 运行jenkins作业/流水线，在对应的服务器没有镜像和运行的容器，且构建过程没有错误输出。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/833850a8163b42f79d14e14b9551c356.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>分析：<br>由于是照着黑马程序员的视频和资料来的，由于输出的信息不太一样，以为是哪里操作有问题，或者脚本不对，但是重复所有过程和按照网上教程修改脚本均没有成功。然后单独运行脚本，发现出错，类似于下图。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/635aed74d26a41bc84833f34bef37f50.png" alt="在这里插入图片描述"></p><blockquote><p><strong>反应过来是因为Docker没有把Harbor加入信任列表中</strong>，</p><p><br> 加入就好</p><p><code>vim /etc/docker/daemon.json </code></p><p><br> 再次构建出现了错误信息，搜索得知是因为这个命令默认有个时间限制，超过这个时间限制就会出错，断开，类似于联网超时。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/cf2801f8c63a42bb8e91adf61a3f8590.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p><strong>把时间改为0就好</strong></p></blockquote><p><img src="https://img-blog.csdnimg.cn/30e99ed138474b01800e583e61389dfd.png" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#liu-shui-xian-yu-fa-zhao-bu-dao-mo-ban&quot;&gt;流水线语法找不到模板&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#publish-over-s</summary>
      
    
    
    
    <category term="Jenkins" scheme="http://example.com/categories/Jenkins/"/>
    
    
    <category term="运维" scheme="http://example.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Jenkins" scheme="http://example.com/tags/Jenkins/"/>
    
    <category term="持续集成" scheme="http://example.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux Shell 命令</title>
    <link href="http://example.com/2022/01/15/Linux%20Shell%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/01/15/Linux%20Shell%E5%91%BD%E4%BB%A4/</id>
    <published>2022-01-15T07:49:30.400Z</published>
    <updated>2022-01-15T07:59:27.924Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#shi-ji-ming-ling-fen-xi">实际命令分析</a><ul><li><a href="#git-log-follow-pretty-format-h-wen-jian-ming-xargs-i-sh-c-git-show-wen-jian-ming-wen-jian-ming">git log –follow –pretty=format:%H 文件名 | xargs -I{} sh -c ‘git show {}:文件名 &gt; 文件名.{}’</a></li><li><a href="#git-branch-r-xargs-d-n1-grep-v-origin-xargs-i-sh-c-mkdir-c-users-76585-desktop-try">git branch -r | xargs -d/ -n1 | grep -v ‘origin’ | xargs -I{} sh -c ‘mkdir “C:\Users\76585\Desktop\try{}” ‘</a></li></ul></li><li><a href="#dai-ma-fen-xi">代码分析</a><ul><li><a href="#du-qu-wen-jian-jia-zhong-de-wen-jian-ming-bing-cun-ru-lie-biao">读取文件夹中的文件名，并存入列表</a></li></ul></li><li><a href="#bian-liang">变量</a><ul><li><a href="#huo-qu-bian-liang-zi-fu-chuan-chang-du">获取变量字符串长度</a></li><li><a href="#bian-liang-jie-qu">变量截取</a></li><li><a href="#bian-liang-de-zi-fu-chuan-ti-huan">变量的字符串替换</a></li><li><a href="#shan-chu-zi-fu-chuan">删除字符串</a></li><li><a href="#bian-liang-wei-kong-shi-fu-mo-ren-zhi">变量为空时赋默认值</a></li><li><a href="#zi-fu-chuan-pin-jie">字符串拼接</a></li><li><a href="#dan-yin-hao-nei-yin-ru-bian-liang">单引号内引入变量</a></li><li><a href="#shi-zhan-tong-ji-wen-zhang-dan-ci-qing-kuang">实战：统计文章单词情况</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="shi-ji-ming-ling-fen-xi">实际命令分析</span><a href="#shi-ji-ming-ling-fen-xi" class="header-anchor">#</a></h1><h2><span id="git-log-follow-pretty-format-h-wen-jian-ming-xargs-i-sh-c-git-show-wen-jian-ming-gt-wen-jian-ming">git log –follow –pretty=format:%H 文件名 | xargs -I{} sh -c ‘git show {}:文件名 &gt; 文件名.{}’</span><a href="#git-log-follow-pretty-format-h-wen-jian-ming-xargs-i-sh-c-git-show-wen-jian-ming-gt-wen-jian-ming" class="header-anchor">#</a></h2><p>提取git中某个文件的所有版本并按顺序命名:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --follow --pretty=format:%H 文件名 | xargs -I&#123;&#125; sh -c &#x27;git show &#123;&#125;:文件名 &gt; 文件名.&#123;&#125;&#x27;</span><br></pre></td></tr></table></figure><p>简略解释版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git log --follow --pretty=format:%H </span><br><span class="line">//按照一定的格式输出 ，输出某个文件的历史提交哈希值</span><br><span class="line"></span><br><span class="line">| xargs -I&#123;&#125; </span><br><span class="line"></span><br><span class="line">//xargs 一般是和管道(I)一起使用</span><br><span class="line"> //-I&#123;&#125; //xargs 的一个选项 -I，使用 -I 指定一个替换字符串 &#123;&#125;，这个字符串在 xargs 扩展时会被替换掉；对应这里，前面输出的是哈希值，这里面&quot;&#123;&#125;&quot;代表的就是哈希值，后面的&quot;&#123;&#125;&quot;也是前面的哈希值。</span><br><span class="line"></span><br><span class="line">sh -c </span><br><span class="line">//暂时不清，下面有解释</span><br><span class="line"></span><br><span class="line">git show &#123;&#125;:文件名 &gt; 文件名.&#123;&#125; </span><br><span class="line"> //git show &#x27;哈希值&#x27;:文件名：输出这次提交，这个文件夹的内容， &quot;&gt;&quot; 将内容输出到 后面的文件中，并覆盖后面文件内容。</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>| xargs -I{} sh c</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|  //表示管道，上一条命令的输出，作为下一条命令参数，如 echo ‘yes’ | wc -l</span><br><span class="line"></span><br><span class="line">xargs -I //</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sh -c</span><br><span class="line"></span><br><span class="line">Linux使用 echo 并配合命令重定向是实现向文件中写入信息的快捷方式。</span><br><span class="line">【新建空文件】</span><br><span class="line">方式一 : $ touch test.sh</span><br><span class="line">方式二 : $ echo “” &gt; test.sh</span><br><span class="line">【写内容到文件】</span><br><span class="line">如 test.sh 文件中内容：</span><br><span class="line">$ echo “信息” &gt; test.sh</span><br><span class="line"></span><br><span class="line">但有时会出现权限不够的问题，这时就可以使用 sh -c</span><br><span class="line"></span><br><span class="line">利用 “sh -c” 命令，它可以让 bash 将一个字串作为完整的命令来执行，这样就可以将 sudo 的影响范围扩展到整条命令。具体用法如下：</span><br><span class="line">$ sudo sh -c ‘echo “第二条内容” &gt;&gt; test.sh’</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="git-branch-r-xargs-d-n1-grep-v-origin-xargs-i-sh-c-mkdir-c-users-76585-desktop-try">git branch -r | xargs -d/ -n1 | grep -v ‘origin’ | xargs -I{} sh -c ‘mkdir “C:\Users\76585\Desktop\try{}” ‘</span><a href="#git-branch-r-xargs-d-n1-grep-v-origin-xargs-i-sh-c-mkdir-c-users-76585-desktop-try" class="header-anchor">#</a></h2><blockquote><p>用途：给每一个远程分支建立单独的文件夹，文件名就是分支名</p></blockquote><p>分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.  git branch -r //显示远程分支。注意，本地分支可能只有一个，master这种。但远程分支可能有很多个。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. | xargs -d/ -n1 // -d -n都是xargs的参数，详细可以去查文档。-d/  以&quot;/&quot;为分隔符；-n1，每行输出一个。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. grep -v &#x27;origin&#x27; // 遇到origin就不显示（删除这个字符串）。</span><br></pre></td></tr></table></figure><p>冷知识：在Windows下运行sh文件，在当前路径下，<code>./</code>;<br>如果是非当前路径，<code>c/xx/xxx/1.sh  //绝对路径到sh文件就好，前面不用加./</code> </p><h1><span id="dai-ma-fen-xi">代码分析</span><a href="#dai-ma-fen-xi" class="header-anchor">#</a></h1><h2><span id="du-qu-wen-jian-jia-zhong-de-wen-jian-ming-bing-cun-ru-lie-biao">读取文件夹中的文件名，并存入列表</span><a href="#du-qu-wen-jian-jia-zhong-de-wen-jian-ming-bing-cun-ru-lie-biao" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#读取文件夹中的文件名，并存入列表</span><br><span class="line"></span><br><span class="line">i=0</span><br><span class="line">for dir in $(ls &#x27;C:\Users\76585\Desktop\cfdname1&#x27;)</span><br><span class="line">do</span><br><span class="line">    </span><br><span class="line">    # echo $dir &gt;&gt; arr[$i]</span><br><span class="line">    arr[$i]=$dir</span><br><span class="line">    i=$(($i+1))</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;$&#123;arr[@]&#125;&quot;</span><br></pre></td></tr></table></figure><p><strong>注意的点：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.for 循环循环体只能卸载do done之间，之前把 i 写在了for 和 do之间报错</span><br><span class="line"></span><br><span class="line">2.变量初始化不要放在函数体，不然每次循环都清 0 了。</span><br><span class="line"></span><br><span class="line">3.变量自增加方法：</span><br><span class="line">a=\$(($a+1))</span><br><span class="line"></span><br><span class="line">a=$[$a+1]</span><br><span class="line"></span><br><span class="line">a=\`expr $a + 1`</span><br><span class="line"></span><br><span class="line">let a++</span><br><span class="line"></span><br><span class="line">let a+=1</span><br><span class="line"></span><br><span class="line">((a++))</span><br><span class="line"></span><br><span class="line">4.打印数组的方法：$&#123;my_array[*]&#125; 或者 $&#123;my_array[@]&#125;</span><br></pre></td></tr></table></figure><h1><span id="bian-liang">变量</span><a href="#bian-liang" class="header-anchor">#</a></h1><h2><span id="huo-qu-bian-liang-zi-fu-chuan-chang-du">获取变量字符串长度</span><a href="#huo-qu-bian-liang-zi-fu-chuan-chang-du" class="header-anchor">#</a></h2><p>想要知道 “<a href="http://www.baidu.com&quot;/">www.baidu.com&quot;</a> 的变量net的长度十分简单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ net=&quot;www.baidu.com&quot;</span><br><span class="line">[Neptuneyt]$ echo $&#123;#net&#125;</span><br><span class="line">13</span><br></pre></td></tr></table></figure><p>当然，在Shell中获取字符串变量的长度的方法有许多种，但是下图法一作为一种系统内建的方法是最快的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ echo $&#123;#net&#125;</span><br><span class="line">13</span><br><span class="line">[Neptuneyt]$ echo $&#123;net&#125;|wc -L</span><br><span class="line">13</span><br><span class="line">[Neptuneyt]$ expr length $&#123;net&#125;</span><br><span class="line">13</span><br><span class="line">[Neptuneyt]$ echo $&#123;net&#125;|awk &#x27;&#123;print length($0)&#125;&#x27;</span><br><span class="line">13</span><br></pre></td></tr></table></figure><h2><span id="bian-liang-jie-qu">变量截取</span><a href="#bian-liang-jie-qu" class="header-anchor">#</a></h2><p><strong>指定位置截取字符串</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ net=&quot;www.baidu.com&quot;</span><br><span class="line">[Neptuneyt]$ # 从第4个字符截取到baidu</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:4:5&#125; #从第4个字符.开始截取5个字符</span><br><span class="line">baidu</span><br><span class="line">[Neptuneyt]$ # 截取baidu.com</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:4&#125;   #起始位置后不接截取字符长度则默认截取之后所有的</span><br><span class="line">baidu.com</span><br><span class="line">[Neptuneyt]$ # 用倒数截取com</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:0-3&#125; #从倒数第三个字符截取到末尾</span><br><span class="line">com</span><br><span class="line">[Neptuneyt]$ echo $&#123;net: -3&#125; #另外的写法，一定要注意冒号和-3之间有空格</span><br><span class="line">com</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:-3&#125;  #不加空格，截取失败</span><br><span class="line">www.baidu.com</span><br></pre></td></tr></table></figure><p><strong>匹配字符串截取</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ echo $net</span><br><span class="line">www.baidu.com</span><br><span class="line"></span><br><span class="line"># 删除匹配字符串的左边，留下剩余部分</span><br><span class="line">[Neptuneyt]$ echo $&#123;net#*.&#125; #这里用*.表示匹配到www.，用一个#表示删除匹配到的字符串，留下剩余的部分</span><br><span class="line">baidu.com</span><br><span class="line"></span><br><span class="line"># 用2个#号表示尽可能多的删除匹配到的字符串</span><br><span class="line">[Neptuneyt]$ echo $&#123;net##*.&#125;</span><br><span class="line">com</span><br><span class="line"></span><br><span class="line"># 同理也可以匹配字符串的右边，留下剩余部分</span><br><span class="line">[Neptuneyt]$ echo $&#123;net%.*&#125; #用.*匹配到.com,用%删除</span><br><span class="line">www.baidu</span><br><span class="line"></span><br><span class="line"># 用2个%号表示尽可能多的删除匹配到的字符串</span><br><span class="line">[Neptuneyt]$ echo $&#123;net%%.*&#125;    #因为2个%，这里.*表示匹配到最长的.baidu.com</span><br></pre></td></tr></table></figure><p>总的来说:<br><code>#*chr</code>表示删除从左到右第一个遇到的字符chr及其左侧的字符<br><code>##*chr</code>表示删除从左到右最后一个遇到的字符chr及其左侧的字符（贪婪模式）<br><code>%chr*</code>表示删除从右向左第一个遇到的字符chr及其右侧的字符<br><code>%%chr*</code>表示删除从右到左最后一个遇到的字符chr及其右侧的字符（贪婪模式）<br>在键盘上，#在$符的左边，%号在$符的右边，为了便于记忆，大家因此可以记住#删除左边字符，%删除右边字符</p><h2><span id="bian-liang-de-zi-fu-chuan-ti-huan">变量的字符串替换</span><a href="#bian-liang-de-zi-fu-chuan-ti-huan" class="header-anchor">#</a></h2><p>想要将net的 baidu替换成google怎么写呢？只需<code>$&#123;net/baidu/google&#125;</code>即可，需要注意的是原变量并未修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ echo $&#123;net/baidu/google&#125; #/匹配字符/替换字符</span><br><span class="line">www.google.com</span><br><span class="line">[Neptuneyt]$ echo $net  #原变量并未修改</span><br><span class="line">www.baidu.com</span><br></pre></td></tr></table></figure><p>如果是替换所有匹配到的字符，应该通过<code>$&#123;variable//pattern/sub&#125;</code><br>例如将net的.替换为-或/：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ echo $&#123;net//./-&#125;</span><br><span class="line">www-baidu-com</span><br><span class="line">[Neptuneyt]$ echo $&#123;net//.//&#125;</span><br><span class="line">www/baidu/com</span><br></pre></td></tr></table></figure><p>除此之外，还有两种专门针对字符串开头和结尾的替换方式<br>只替换开头匹配的字符串<code>$&#123;variable/#pattern/sub&#125;</code><br>只替换结尾匹配的字符串<code>$&#123;variable/%pattern/sub&#125;</code><br>例如对于<code>add=www.xiaomi.com.www</code>的开头或者结尾的<code>www</code>替换为<code>-</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ add=www.xiaomi.com.www</span><br><span class="line">[Neptuneyt]$ echo $&#123;add/#www/-&#125;</span><br><span class="line">-.xiaomi.com.www</span><br><span class="line">[Neptuneyt]$ echo $&#123;add/%www/-&#125;</span><br><span class="line">www.xiaomi.com.-</span><br></pre></td></tr></table></figure><h2><span id="shan-chu-zi-fu-chuan">删除字符串</span><a href="#shan-chu-zi-fu-chuan" class="header-anchor">#</a></h2><p>其实学会了替换字符串删除字符串就更简单了，只需将替换部分写成空即可，即<code>$&#123;variable/pattern/null&#125;</code>，例如将net的第一个.删除，只需</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ echo $&#123;net/./&#125;</span><br><span class="line">wwwbaidu.com</span><br><span class="line">[Neptuneyt]$ echo $&#123;net/.&#125;  #最后一个/可以不用写</span><br><span class="line">wwwbaidu.com</span><br></pre></td></tr></table></figure><p>若要删除所有匹配到的只需即<code>$&#123;variable//pattern&#125;</code>，例如将<code>net</code>的.都删除，只需</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ echo $&#123;net//.&#125;</span><br><span class="line">wwwbaiducom</span><br></pre></td></tr></table></figure><h2><span id="bian-liang-wei-kong-shi-fu-mo-ren-zhi">变量为空时赋默认值</span><a href="#bian-liang-wei-kong-shi-fu-mo-ren-zhi" class="header-anchor">#</a></h2><p>当我们在写脚本时往往需要给脚本传递一些参数，在Shell中传递参数十分简单，只需利用特殊的位置参数变量诸如<code>$1,$2,$3...$&#123;10&#125;...</code>即可，例如，以下脚本传递2个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># PassArgument.sh</span><br><span class="line">#!/bin/env bash</span><br><span class="line"># pass 2 arguments</span><br><span class="line">arg1=$1</span><br><span class="line">arg2=$2</span><br><span class="line">echo $arg1 $arg2</span><br><span class="line"></span><br><span class="line">[Neptuneyt]$ bash PassArgument.sh Hello word #参数以空格隔开</span><br><span class="line">Hello word</span><br></pre></td></tr></table></figure><p>有时候，我们想省掉最后一个参数，让它使用默认值，这个时候只需通过<code>$&#123;variable:=&#39;default value&#39;&#125;</code>即可，即当变量有值的时候则使用原值，若没有值则使用括号中默认定义好的值。例如，如下脚本表示当第二个参数为空时默认使用定义好的值“word”,否则是用户自己传递的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># PassArgument.sh</span><br><span class="line">#!/bin/env bash</span><br><span class="line">arg1=$1</span><br><span class="line">arg2=$2</span><br><span class="line">echo $arg1 $&#123;arg2:=&#x27;word&#x27;&#125;  #第二个参数设置默认值</span><br><span class="line"></span><br><span class="line">[Neptuneyt]$ bash PassArgument.sh Hello #第二个参数为空时使用默认值</span><br><span class="line">Hello word</span><br><span class="line">[Neptuneyt]$ bash PassArgument.sh Hello Shell   #第二个参数不为空时使用参数传递的值</span><br><span class="line">Hello Shell</span><br></pre></td></tr></table></figure><p>除了<code>$&#123;variable:=&#39;default value&#39;&#125;</code>外，还有<code>$&#123;variable:-&#39;default value&#39;&#125;</code>,<code>$&#123;variable:+&#39;default value&#39;&#125;</code>和<code>$&#123;variable:？&#39;default value&#39;&#125;</code>，它们有什么区别呢？<br>对于<code>$&#123;variable:=&#39;default value&#39;&#125;</code>，表示变量为空时把默认值赋值给该变量，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ net=</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:=&#x27;www.baidu.com&#x27;&#125;</span><br><span class="line">www.baidu.com</span><br><span class="line">[Neptuneyt]$ echo $net</span><br><span class="line">www.baidu.com</span><br></pre></td></tr></table></figure><p>对于<code>$&#123;variable:-&#39;default value&#39;&#125;</code>,表示变量为空时返回默认值<strong>但是并不把默认值赋值给该变量</strong>， 例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ net=</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:-&#x27;www.baidu.com&#x27;&#125;</span><br><span class="line">www.baidu.com</span><br><span class="line">[Neptuneyt]$ echo $net  #此时，变量依旧为空</span><br></pre></td></tr></table></figure><p>对于<code>$&#123;variable:+&#39;default value&#39;&#125;</code>,则表示变量不为空时，返回默认值，并且也不重新赋值，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ net=www.baidu.com</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:+&#x27;www.google.com&#x27;&#125;</span><br><span class="line">www.google.com</span><br><span class="line">[Neptuneyt]$ echo $net  #不改变变量原值</span><br><span class="line">www.baidu.com</span><br></pre></td></tr></table></figure><p>最后，对于<code>$&#123;variable:？&#39;default value&#39;&#125;</code>,则表示当变量为空时，使用bash风格的报错，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ net=</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:?&#x27;error:null value&#x27;&#125;</span><br><span class="line">-bash: net: error:null value</span><br></pre></td></tr></table></figure><h2><span id="zi-fu-chuan-pin-jie">字符串拼接</span><a href="#zi-fu-chuan-pin-jie" class="header-anchor">#</a></h2><p>在 PHP 中，使用.即可连接两个字符串；<br>在 JavaScript 中，使用+即可将两个字符串合并为一个。<br>在 Shell 中你不需要使用任何运算符，将两个字符串并排放在一起就能实现拼接，非常简单粗暴。请看下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">name=&quot;Shell&quot;</span><br><span class="line">url=&quot;http://c.biancheng.net/shell/&quot;</span><br><span class="line">str1=$name$url  #中间不能有空格</span><br><span class="line">str2=&quot;$name $url&quot;  #如果被双引号包围，那么中间可以有空格</span><br><span class="line">str3=$name&quot;: &quot;$url  #中间可以出现别的字符串</span><br><span class="line">str4=&quot;$name: $url&quot;  #这样写也可以</span><br><span class="line">str5=&quot;$&#123;name&#125;Script: $&#123;url&#125;index.html&quot;  #这个时候需要给变量名加上大括号</span><br><span class="line">echo $str1</span><br><span class="line">echo $str2</span><br><span class="line">echo $str3</span><br><span class="line">echo $str4</span><br><span class="line">echo $str5</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">Shellhttp://c.biancheng.net/shell/</span><br><span class="line">Shell http://c.biancheng.net/shell/</span><br><span class="line">Shell: http://c.biancheng.net/shell/</span><br><span class="line">Shell: http://c.biancheng.net/shell/</span><br><span class="line">ShellScript: http://c.biancheng.net/shell/index.html</span><br></pre></td></tr></table></figure><p>对于第 7 行代码，$name 和 $url 之间之所以不能出现空格，是因为当字符串不被任何一种引号包围时，遇到空格就认为字符串结束了，空格后边的内容会作为其他变量或者命令解析，这一点在《Shell字符串》中已经提到。</p><p>对于第 10 行代码，加{ }是为了帮助解释器识别变量的边界，这一点在《Shell变量》中已经提到。</p><h2><span id="dan-yin-hao-nei-yin-ru-bian-liang">单引号内引入变量</span><a href="#dan-yin-hao-nei-yin-ru-bian-liang" class="header-anchor">#</a></h2><p><strong>方法：单引号内嵌套单引号即可使用变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">i=10</span><br><span class="line">echo $i</span><br><span class="line">echo &#x27;$i&#x27;</span><br><span class="line">echo &#x27;$i is : &#x27;$i&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">执行结果</span><br><span class="line"></span><br><span class="line"># ./test.sh </span><br><span class="line">10</span><br><span class="line">$i</span><br><span class="line">$i is : 10</span><br></pre></td></tr></table></figure><h2><span id="shi-zhan-tong-ji-wen-zhang-dan-ci-qing-kuang">实战：统计文章单词情况</span><a href="#shi-zhan-tong-ji-wen-zhang-dan-ci-qing-kuang" class="header-anchor">#</a></h2><p>这里想要统计Martin Luther King在1963年著名的<strong>I have a dream</strong>演讲中都使用了哪些词，哪些是高频词，单词字长如何。<br><img src="https://img-blog.csdnimg.cn/4f3976bb28594f89ab73d74c1d5b4448.png" alt="在这里插入图片描述"><br>思路：<br>高频词统计：将所有单词单行输出，删除空行，删除<code>,./?</code>等非字母符号，用sort排序后使用uniq统计即可。<br>字长频数统计：将所有单词单行输出，删除空行，删除<code>,./?</code>等非字母符号，使用while循环遍历每个单词，使用`$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#shi-ji-ming-ling-fen-xi&quot;&gt;实际命令分析&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#git-log-follow-pretty-format-h-wen</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="运维" scheme="http://example.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>前端知识</title>
    <link href="http://example.com/2022/01/15/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2022/01/15/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86/</id>
    <published>2022-01-15T07:40:47.822Z</published>
    <updated>2022-01-15T07:47:11.320Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#react">React</a><ul><li><a href="#qi-dong-liu-cheng">启动流程</a></li><li><a href="#react-router-dom-lu-you">react-router-dom路由</a><ul><li><a href="#an-zhuang">安装</a></li><li><a href="#ji-ben-cao-zuo">基本操作</a></li></ul></li></ul></li><li><a href="#javascript">Javascript</a><ul><li><a href="#jian-tou-han-shu">箭头函数</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="react">React</span><a href="#react" class="header-anchor">#</a></h1><h2><span id="qi-dong-liu-cheng">启动流程</span><a href="#qi-dong-liu-cheng" class="header-anchor">#</a></h2><p>重点关注三个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">src/App.js //实现 React 组件</span><br><span class="line"></span><br><span class="line">src/index.js // React 世界的入口</span><br><span class="line"></span><br><span class="line">public/index.html //挂载的页面</span><br></pre></td></tr></table></figure><p>1.index.html</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个是一个模板文件，里面有过id为root的div标签，会被index.js文件中的JSX替换这个DOM节点。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c8637d56e86b4868a275d4a01a1db9c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>2.index.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">关键就是这个ReactDOM.render()</span><br><span class="line"></span><br><span class="line">简单来说，ReactDOM.render() 会使用你的 JSX 来替换你的 HTML 中的一个 DOM 节点。这</span><br><span class="line">样你就可以很容易地把 React 集成到每一个其他的应用中。ReactDOM.render() 可以在你的</span><br><span class="line">应用中被多次使用。你可以在多个地方使用它来加载简单的 JSX 语法、单个 React 组件、</span><br><span class="line">多个 React 组件或者整个应用。但是在一个纯 React 的应用中，你只会使用一次用来加载你</span><br><span class="line">的整个组件树。</span><br><span class="line">ReactDOM.render() 有两个传入参数。第一个是准备渲染的 JSX。第二个参数指定了 React</span><br><span class="line">应用在你的 HTML 中的放置的位置。这个位置是一个 id=&#x27;root&#x27; 的元素。你可以在文件</span><br><span class="line">public/index.html 中找到这个 id 属性</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5a6381d4f99b4a56b00f07e3ee28f9c7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>3.App.js<br>在inde.js文件里面，ReactDOM.render() 总会很好地渲染你的 App 组件。一般来说，某个组件叫xxx，那么他的代码就叫xxx.js。要想知道页面被渲染成什么样，就看看里面内容。<br><img src="https://img-blog.csdnimg.cn/378a772ce66d41e9b70b563c6319a470.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2><span id="react-router-dom-lu-you">react-router-dom路由</span><a href="#react-router-dom-lu-you" class="header-anchor">#</a></h2><p><a href="https://www.jianshu.com/p/8954e9fb0c7e">原文章链接</a><br>来源：简书</p><p><strong>使用背景：使用React构建的单页面应用，要想实现页面间的跳转，首先想到的就是使用路由。在React中，常用的有两个包可以实现这个需求，那就是react-router和react-router-dom。本文主要针对react-router-dom进行说明。</strong></p><h3><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor">#</a></h3><p>首先进入项目目录，使用npm安装react-router-dom：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install react-router-dom --save-dev //这里可以使用cnpm代替npm命令；</span><br><span class="line"></span><br><span class="line">//--save-dev 标记表示该 node 包只是用作开发环境的一部分，并不会被作为你产品代码的一</span><br><span class="line">部分发布。哪种 node 包适用这个场景呢？设想你需要一些 node 包辅助测试你的应用，然</span><br><span class="line">后需要通过 npm 来安装这些包，但是不希望他们混入产品代码里面。测试过程应该只会发</span><br><span class="line">生在开发阶段，而不是在线上部署运行的时候。因为那个时候已经用不到测试代码了，你</span><br><span class="line">的应用应该已经被测试完而且可以被你的用户使用了。这可能是你唯一的使用 --save-dev</span><br><span class="line">的场景。</span><br></pre></td></tr></table></figure><h3><span id="ji-ben-cao-zuo">基本操作</span><a href="#ji-ben-cao-zuo" class="header-anchor">#</a></h3><p>然后我们新建两个页面，分别命名为“home”和“detail”。在页面中编写如下代码：<br>detail.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default class Home extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a&gt;去detail&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>home.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default class Home extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a&gt;回到home&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再新建一个路由组件，命名为“Router.js”，并编写如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123;HashRouter, Route, Switch&#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line">import Home from &#x27;../home&#x27;;</span><br><span class="line">import Detail from &#x27;../detail&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const BasicRoute = () =&gt; (</span><br><span class="line">    &lt;HashRouter&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route exact path=&quot;/detail&quot; component=&#123;Detail&#125;/&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">    &lt;/HashRouter&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">export default BasicRoute;</span><br></pre></td></tr></table></figure><p>如上代码定义了一个纯路由组件，将两个页面组件Home和Detail使用Route组件包裹，外面套用Switch作路由匹配，当路由组件检测到地址栏与Route的path匹配时，就会自动加载响应的页面。<br>然后在入口文件中——我这里指定的是index.js——编写如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">import Router from &#x27;./router/router&#x27;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Router/&gt;,</span><br><span class="line">  document.getElementById(&#x27;root&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这里相当于向页面返回了一个路由组件。我们先运行项目看一下效果，在地址栏输入“<a href="http://localhost:3000/#/%E2%80%9D%EF%BC%9A">http://localhost:3000/#/”：</a><br><img src="https://img-blog.csdnimg.cn/37aee935c7534aa39a98acfcf884e278.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>输入“<a href="http://localhost:3000/#/detail%E2%80%9D%EF%BC%9A">http://localhost:3000/#/detail”：</a><br><img src="https://img-blog.csdnimg.cn/891f1a191f764e2295b057870300cd76.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>通过a标签跳转</strong><br>可以看到其实路由已经开始工作了，接下来我们再来做页面间的跳转。在home.js和detail.js中，我们修改如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    export default class Home extends React.Component &#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                &lt;a href=&#x27;#/detail&#x27;&gt;去detail&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>home.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default class Home extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a href=&#x27;#/&#x27;&gt;回到home&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新打包运行，在浏览器地址栏输入“<a href="http://localhost:3000/%E2%80%9D%EF%BC%8C%E8%AF%95%E8%AF%95%E7%9C%8B%E9%A1%B5%E9%9D%A2%E8%83%BD%E5%90%A6%E6%AD%A3%E5%B8%B8%E8%B7%B3%E8%BD%AC%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%8D%E8%83%BD%EF%BC%8C%E8%AF%B7%E6%8C%89%E6%AD%A5%E9%AA%A4%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%A3%80%E6%9F%A5%E4%BB%A3%E7%A0%81%E6%98%AF%E5%90%A6%E6%9C%89%E8%AF%AF%E3%80%82%E4%BB%A5%E4%B8%8A%E6%98%AF%E4%BD%BF%E7%94%A8a%E6%A0%87%E7%AD%BE%E7%9A%84href%E8%BF%9B%E8%A1%8C%E9%A1%B5%E9%9D%A2%E9%97%B4%E8%B7%B3%E8%BD%AC%EF%BC%8C%E6%AD%A4%E5%A4%96react-router-dom%E8%BF%98%E6%8F%90%E4%BE%9B%E4%BA%86%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E8%B7%B3%E8%BD%AC%E9%A1%B5%E9%9D%A2%E3%80%82">http://localhost:3000/”，试试看页面能否正常跳转。如果不能，请按步骤一步一步检查代码是否有误。以上是使用a标签的href进行页面间跳转，此外react-router-dom还提供了通过函数的方式跳转页面。</a></p><p><strong>通过函数跳转</strong></p><p>首先我们需要修改router.js中的两处代码：<br>然后在home.js中：<br>import React from ‘react’;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">import &#123;HashRouter, Route, Switch, hashHistory&#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line">...</span><br><span class="line">&lt;HashRouter history=&#123;hashHistory&#125;&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在a标签下面添加一个按钮并加上onClick事件，通过this.props.history.push这个函数跳转到detail页面。在路由组件中加入的代码就是将history这个对象注册到组件的props中去，然后就可以在子组件中通过props调用history的push方法跳转页面。</p><p>很多场景下，我们还需要在页面跳转的同时传递参数，在react-router-dom中，同样提供了两种方式进行传参。</p><p>链接：<a href="https://www.jianshu.com/p/8954e9fb0c7e">https://www.jianshu.com/p/8954e9fb0c7e</a><br>来源：简书</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default class Home extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a href=&#x27;#/detail&#x27;&gt;去detail&lt;/a&gt;</span><br><span class="line">                &lt;button onClick=&#123;() =&gt; this.props.history.push(&#x27;detail&#x27;)&#125;&gt;通过函数跳转&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>url传参</strong><br>在router.js中，修改如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;Route exact path=&quot;/detail/:id&quot; component=&#123;Detail&#125;/&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后修改detail.js，使用this.props.match.params获取url传过来的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">    console.log(this.props.match.params);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在地址栏输入“<a href="http://localhost:3000/#/detail/3%E2%80%9D%EF%BC%8C%E6%89%93%E5%BC%80%E6%8E%A7%E5%88%B6%E5%8F%B0%EF%BC%9A">http://localhost:3000/#/detail/3”，打开控制台：</a><br><img src="https://img-blog.csdnimg.cn/d803a9af4817410c8649c09bbf06cdea.png" alt="在这里插入图片描述"><br>可以看到传过去的id=3已经被获取到了。react-router-dom就是通过“/:”去匹配url传递的参数。</p><p><strong>隐式传参</strong><br>此外还可以通过push函数隐式传参。</p><p>修改home.js代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default class Home extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a href=&#x27;#/detail/3&#x27;&gt;去detail&lt;/a&gt;</span><br><span class="line">                    &lt;button onClick=&#123;() =&gt; this.props.history.push(&#123;</span><br><span class="line">                        pathname: &#x27;/detail&#x27;,</span><br><span class="line">                        state: &#123;</span><br><span class="line">                            id: 3</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)&#125;&gt;通过函数跳转&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在detail.js中，就可以使用this.props.history.location.state获取home传过来的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    //console.log(this.props.match.params);</span><br><span class="line">    console.log(this.props.history.location.state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳转后打开控制台可以看到参数被打印：<br><img src="https://img-blog.csdnimg.cn/972fb5894c804e8c9203fc6d304cf0c5.png" alt="在这里插入图片描述"><br><strong>嵌套路由</strong></p><p>嵌套路由的适用场景还是比较多的，接下来就来介绍一下实现方法。<br>首先在Vue中实现嵌套路由，只需要将配置文件写成children嵌套，然后在需要展示子路由的位置加上<router-view></router-view>即可。React中应该如何实现呢？其实原理和Vue类似，只需要在父级路由中包含子路由即可。这样说可能很多同学会一头雾水，直接上代码（不使用上面的例子）：</p><p>首先定义父级组件MainLayout</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#x27;./MainLayout.scss&#x27;;</span><br><span class="line"></span><br><span class="line">const &#123; Header, Sider, Content &#125; = Layout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default class MainLayout extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&#x27;main-layout&#x27;&gt;</span><br><span class="line">                父组件</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义子组件Home：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;useState&#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123;Modal, Select&#125; from &quot;antd&quot;;</span><br><span class="line">import &#123;connect&#125; from &#x27;react-redux&#x27;;</span><br><span class="line">import &#123;addCount&#125; from &#x27;../../servers/home&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Home(props) &#123;</span><br><span class="line">    const [visible, setVisible] = useState(false);</span><br><span class="line">    const &#123;countNum: &#123;count&#125;, dispatch&#125; = props;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            子组件</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Home;</span><br></pre></td></tr></table></figure><p>然后将它们添加进路由router.js，并且关联父子关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123;HashRouter, Route, Switch&#125; from &quot;react-router-dom&quot;;</span><br><span class="line">import Home from &#x27;../pages/Home/Home&#x27;;</span><br><span class="line">import MainLayout from &#x27;../layout/MainLayout&#x27;;</span><br><span class="line"></span><br><span class="line">const BasicRouter = () =&gt; (</span><br><span class="line">    &lt;HashRouter&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=&quot;/index&quot; component=&#123;</span><br><span class="line">                &lt;MainLayout&gt;</span><br><span class="line">                  &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">                  &lt;Route exact path=&quot;/index&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">                  &lt;Route path=&quot;/index/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">                &lt;/MainLayout&gt;</span><br><span class="line">             &#125;/&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">    &lt;/HashRouter&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default BasicRouter;</span><br></pre></td></tr></table></figure><p>在MainLayout中，修改如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#x27;./MainLayout.scss&#x27;;</span><br><span class="line"></span><br><span class="line">const &#123; Header, Sider, Content &#125; = Layout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default class MainLayout extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&#x27;main-layout&#x27;&gt;</span><br><span class="line">                &#123;this.props.children&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，一个嵌套路由就完成了。</p><h1><span id="javascript">Javascript</span><a href="#javascript" class="header-anchor">#</a></h1><h2><span id="jian-tou-han-shu">箭头函数</span><a href="#jian-tou-han-shu" class="header-anchor">#</a></h2><p>箭头函数本质还是函数，我们来看看他与JavaScript中普通函数的区别，先看看写法上的区别。<br><img src="https://img-blog.csdnimg.cn/2b6243000b0d48f69f6baf1e77293818.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>解释</strong><br>写箭头函数，我们记住一个顺序就好，参数、箭头、函数体、这个顺序记住就足够了，参数、箭头、函数体、这三个是必须的，函数名可以没有，但这三项必须有，一些简写的方式也是简写这三项里的东西。</p><p><strong>简写</strong><br>1、只有一个参数时，() 可省略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//不简写</span><br><span class="line">var demo = (x) =&gt;&#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//简写</span><br><span class="line">var demo = x =&gt;&#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、函数体只有一句时， {} 可以省略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//不简写</span><br><span class="line">var demo = (x) =&gt;&#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//简写</span><br><span class="line">var demo = x =&gt; console.log(x);</span><br></pre></td></tr></table></figure><p>3、函数体只有一条返回语句时，{} 和 return 都可以省略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//不简写</span><br><span class="line">var demo = (x) =&gt; &#123;</span><br><span class="line">     return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//简写</span><br><span class="line">var demo = (x) =&gt; x;   </span><br><span class="line"></span><br><span class="line">//注意别写成这样  </span><br><span class="line">var demo = (x) =&gt;&#123; x &#125;;  </span><br><span class="line">//或者 这样  </span><br><span class="line">var demo = (x) =&gt; return  x;  </span><br><span class="line">//要省略就都省略，不省略就都不省，别省一半,不然会出错的。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>箭头函数放 参数 的地方就在 () 内，<br>没有参数，() 必须写，<br>一个参数，() 可写可不写，<br>多个参数，() 必须写。</p><p>箭头函数放 函数体 的地方在 {}内，<br>函数体 就 一句 {} 可写可不写，<br>函数体 不止一句，{} 必须写。</p><p>如果不知道，() {} 写不写，该不该省略，那就写，写了不会错。</p><p><strong>箭头函数 如果要返回一个对象，要简写的话， 需要用()包住这个对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//不简写</span><br><span class="line">var demo = () =&gt;&#123; </span><br><span class="line">    return &#123;x:1&#125;;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">//简写</span><br><span class="line">var demo = () =&gt;(&#123;x:1&#125;);</span><br></pre></td></tr></table></figure><p>为什么会这样？因为如果不加 () ，那{ } 就表示的是语法块，不是表示一个对象，而加上()，按照规范来说，() 里面 { } 就会被解析为对象了。</p><p>对于 {x:1} 这个情况，他不仅可以表示一个对象，这个对象有个x属性，值为1，也可以表示为语法块中含有 名为 x 的 label，忘记 label语法的话，可以看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label">这里</a><br>如果不是很明白，可以看看这个<a href="https://www.zhihu.com/question/40902815">回答</a>，应该会理解的更加深刻。<br>所以这也解释了为什么会出现下面代码中的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 不报错</span><br><span class="line">var demo = () =&gt;&#123;x:1&#125;;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">var demo = (y) =&gt;&#123;y,x:1&#125;;</span><br></pre></td></tr></table></figure><p><strong>对象的方法用 箭头函数写时，this 的指向 可能和你想的不一样</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.name=&#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">    show_name:() =&gt;&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">obj.show_name(); //window</span><br></pre></td></tr></table></figure><p>JavaScript使用的是函数作用域，在上面这段代码中对象的括号是不能封闭作用域的，所以此时的this还是指向window。<br>我们换成普通函数看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.name=&#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">    show_name: function ()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">obj.show_name();  //obj</span><br></pre></td></tr></table></figure><p>换成普通函数，this 就不是指向window，而是指向 obj 对象了</p><p>箭头函数 与 普通函数 其他的区别</p><blockquote><p>1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。<br> 2、箭头函数 this不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。<br>  3、箭头函数 不能用 new关键字来实例化对象，不然会报错。<br>  4、箭头函数没有arguments对象。</p></blockquote><p>1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.name = &#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">    show_name:function ()&#123;</span><br><span class="line">        function fn ()&#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.show_name();  // window</span><br></pre></td></tr></table></figure><p>声明一个 obj 对象，有一个name属性 与 show_name方法，上面这段代码，我的本意是想显示 obj对象的name， 但是没和我想的一样，一般我们会用 一个变量 self 或者 that 之类的留住this,像这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">window.name = &#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">    show_name:function ()&#123;</span><br><span class="line">        //留住this</span><br><span class="line">        var that = this;</span><br><span class="line">        function fn ()&#123;</span><br><span class="line">            console.log(that.name);</span><br><span class="line">        &#125;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.show_name();  //obj</span><br></pre></td></tr></table></figure><p>通常来说，箭头函数内部的this就是外层代码块的this</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.name = &#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">    show_name:function ()&#123;</span><br><span class="line">        var fn = () =&gt; &#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.show_name(); //obj</span><br></pre></td></tr></table></figure><p>2、箭头函数 this 不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.name = &#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">function show_name()&#123;</span><br><span class="line">    //这里 show_name 是一个普通的全局函数，所以他的this指window</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">//用了 call 方法，把 show_nam 的this 指向了 obj 对象</span><br><span class="line">show_name.call(obj);  //obj</span><br></pre></td></tr></table></figure><p>箭头函数 this 不可变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.name = &#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">var show_name = () =&gt; &#123;</span><br><span class="line">    //这里 show_name 是箭头函数，他的this指window，并且不会变</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">//用了 call 方法，但是 this 没变，所以打印了 window</span><br><span class="line">show_name.call(obj);  //window</span><br></pre></td></tr></table></figure><p>3、箭头函数 不能用 new 关键字来实例化对象，不然会报错，箭头函数的this 不可变，new 也改变不了 this的 指向，而且更为重要的是，箭头函数内部并没有 [[Construct]] 方法，所以会没有原型属性（prototype），所以箭头函数没法当构造函数。</p><p><img src="https://img-blog.csdnimg.cn/7803115884ae4f6ab5f8d4cd73cfe038.png" alt="在这里插入图片描述"><br>4、箭头函数没有arguments对象，不能通过arguments对象访问传入参数，但是可以用rest参数实现<br>。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters">不了解的看这里</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var demo = (...theArgs) =&gt; theArgs;</span><br><span class="line">demo(1,2,3); //[1,2,3]</span><br></pre></td></tr></table></figure><p><strong>总结</strong><br>在来看一遍 箭头函数 与 普通函数，除了写法上的区别</p><blockquote><p>1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。<br>2、箭头函数 this不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。<br>3、箭头函数 不能用 new关键字来实例化对象，不然会报错。<br>4、箭头函数没有arguments对象。</p></blockquote><p>可以看出，最重要的区别还是 在 this 上，所以要想用好 箭头函数，还是要对 this 有一定认识的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#react&quot;&gt;React&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#qi-dong-liu-cheng&quot;&gt;启动流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#react-</summary>
      
    
    
    
    <category term="前端开发" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/08/1/"/>
    <id>http://example.com/2022/01/08/1/</id>
    <published>2022-01-08T08:01:18.144Z</published>
    <updated>2022-01-08T08:01:09.895Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#1">1.一级目录</a></p><p><a href="#1.1">1.1二级目录</a>　　</p><p><a href="#1.1.1">1.1.1三级目录</a></p><h2><span id="yi-ji-mu-lu"> 一级目录 </span><a href="#yi-ji-mu-lu" class="header-anchor">#</a></h2><h4><span id="er-ji-mu-lu"> 二级目录 </span><a href="#er-ji-mu-lu" class="header-anchor">#</a></h4><h5><span id="san-ji-mu-lu"> 三级目录 </span><a href="#san-ji-mu-lu" class="header-anchor">#</a></h5>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1.一级目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#1.1&quot;&gt;1.1二级目录&lt;/a&gt;
　　&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#1.1.1&quot;&gt;1.1.1三级目录&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;yi-ji-mu-lu&quot;&gt; 一级目录 &lt;</summary>
      
    
    
    
    
  </entry>
  
</feed>
