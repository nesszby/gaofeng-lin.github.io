<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Welcome to my Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-28T15:49:19.127Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Gaofeng Lin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java常用语法</title>
    <link href="http://example.com/2022/01/28/java%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2022/01/28/java%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</id>
    <published>2022-01-27T16:00:00.000Z</published>
    <updated>2022-01-28T15:49:19.127Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="zi-fu-chuan-cao-zuo">字符串操作</span><a href="#zi-fu-chuan-cao-zuo" class="header-anchor">#</a></h1><h2><span id="fan-hui-zhi-ding-suo-yin-chu-de-zi-fu">返回指定索引处的字符</span><a href="#fan-hui-zhi-ding-suo-yin-chu-de-zi-fu" class="header-anchor">#</a></h2><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        String s = &quot;www.runoob.com&quot;;</span><br><span class="line">        char result = s.charAt(6);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1><span id="chang-yong-fang-fa">常用方法</span><a href="#chang-yong-fang-fa" class="header-anchor">#</a></h1><h2><span id="fan-hui-liang-ge-can-shu-de-zui-da-zhi">返回两个参数的最大值</span><a href="#fan-hui-liang-ge-can-shu-de-zui-da-zhi" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max(12.123, 18.456) //括号内两个数为相同数据类型</span><br></pre></td></tr></table></figure><h2><span id="ha-xi-biao">哈希表</span><a href="#ha-xi-biao" class="header-anchor">#</a></h2><p><strong>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。</strong></p><blockquote><p>HashMap 的 key 与 value 类型可以相同也可以不同，可以是字符串（String）类型的 key 和value，也可以是整型（Integer）的 key 和字符串（String）类型的 value。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 引入 HashMap 类      </span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">public class RunoobTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建 HashMap 对象 Sites</span><br><span class="line">        HashMap&lt;Integer, String&gt; Sites = new HashMap&lt;Integer, String&gt;();</span><br><span class="line">        // 添加键值对</span><br><span class="line">        Sites.put(1, &quot;Google&quot;);</span><br><span class="line">        Sites.put(2, &quot;Runoob&quot;);</span><br><span class="line">        Sites.put(3, &quot;Taobao&quot;);</span><br><span class="line">        Sites.put(4, &quot;Zhihu&quot;);</span><br><span class="line">        System.out.println(Sites.get(3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="chuang-jian-shu-zu">创建数组</span><a href="#chuang-jian-shu-zu" class="header-anchor">#</a></h1><h2><span id="er-wei-shu-zu">二维数组</span><a href="#er-wei-shu-zu" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//声明int类型的二维数组</span><br><span class="line">int[][] intArray;</span><br><span class="line"></span><br><span class="line">//创建一个三行四列的int类型数组</span><br><span class="line">intArray = new int[3][4];</span><br><span class="line"></span><br><span class="line">//声明数组的同时进行创建</span><br><span class="line">char[][] ch = new char[3][5];</span><br><span class="line"></span><br><span class="line">/二维数组的初始化</span><br><span class="line">int[][] num = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;9,8,7&#125;&#125;;</span><br><span class="line"></span><br><span class="line">//获取行和列</span><br><span class="line">num.length //行数</span><br><span class="line">num[0].length //列数</span><br><span class="line"></span><br><span class="line">//循环输出二维数组的内容</span><br><span class="line">for(int i=0;i&lt;num1.length;i++)&#123;</span><br><span class="line">    for(int j=0;j&lt;num1[i].length;j++)&#123;</span><br><span class="line">         System.out.print(num1[i][j]+&quot; &quot;);</span><br><span class="line">       &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;zi-fu-chuan-cao-zuo&quot;&gt;字符串操作&lt;/span&gt;&lt;a href=&quot;#zi-fu-chuan-cao-zuo&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;fan-hui-zhi-ding</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>算法总结</title>
    <link href="http://example.com/2022/01/26/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/01/26/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2022-01-25T16:00:00.000Z</published>
    <updated>2022-01-26T04:28:44.673Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="dong-tai-gui-hua-jie-ti-kuang-jia">动态规划解题框架</span><a href="#dong-tai-gui-hua-jie-ti-kuang-jia" class="header-anchor">#</a></h1><p>若确定给定问题具有重叠子问题和最优子结构，那么就可以使用动态规划求解。总体上看，求解可分为四步：</p><p><strong>1.状态定义</strong>： 构建问题最优解模型，包括问题最优解的定义、有哪些计算解的自变量；</p><p><strong>2.初始状态</strong>： 确定基础子问题的解（即已知解），原问题和子问题的解都是以基础子问题的解为起始点，在迭代计算中得到的；</p><p><strong>3.转移方程</strong>： 确定原问题的解与子问题的解之间的关系是什么，以及使用何种选择规则从子问题最优解组合中选出原问题最优解；</p><p><strong>4.返回值：</strong> 确定应返回的问题的解是什么，即动态规划在何处停止迭代；</p><p>完成以上步骤后，便容易写出对应的解题代码。</p><h2><span id="shi-li-fei-bo-na-qi-shu-lie">示例：斐波那契数列</span><a href="#shi-li-fei-bo-na-qi-shu-lie" class="header-anchor">#</a></h2><p>状态定义：一维 dp 列表，设第 ii个斐波那契数为 dp[i]；</p><p>初始状态：已知第 0 , 1个斐波那契数分别为 dp[0] = 0, dp[1] =  1 ；</p><p>转移方程：后一个数字等于前两个数字之和，即</p><p>dp[i]=dp[i−1]+dp[i−2]</p><p>返回值：需求取的第 n 个斐波那契数 dp[n] ；</p><h2><span id="shi-li-dan-gao-zui-gao-shou-jie">示例：蛋糕最高售价</span><a href="#shi-li-dan-gao-zui-gao-shou-jie" class="header-anchor">#</a></h2><p>状态定义：一维 dp 列表，设重量为 i 蛋糕的售价为 p(i) ，重量为 ii蛋糕切分后的最高售价为 dp[i] ；</p><p>初始状态：已知重量为 0 蛋糕的最高售价为 0 ，重量为 1 的蛋糕最高售价为 p(1) ；</p><p>转移方程：dp[n] 为 n 种切分组合中的最高售价组合，即</p><p><img src="https://img-blog.csdnimg.cn/100853ca38094c5997762c0b693ff41a.png" alt="在这里插入图片描述"></p><p>返回值：需求取的重量为 n 的蛋糕最高售价 dp[n] ；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;dong-tai-gui-hua-jie-ti-kuang-jia&quot;&gt;动态规划解题框架&lt;/span&gt;&lt;a href=&quot;#dong-tai-gui-hua-jie-ti-kuang-jia&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h1</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>下载过慢</title>
    <link href="http://example.com/2022/01/15/%E4%B8%8B%E8%BD%BD%E8%BF%87%E6%85%A2/"/>
    <id>http://example.com/2022/01/15/%E4%B8%8B%E8%BD%BD%E8%BF%87%E6%85%A2/</id>
    <published>2022-01-15T08:20:48.571Z</published>
    <updated>2022-01-15T08:30:18.479Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="windows">Windows</span><a href="#windows" class="header-anchor">#</a></h1><h2><span id="liu-lan-qi">浏览器</span><a href="#liu-lan-qi" class="header-anchor">#</a></h2><p>windows不要开全局模式，使用命令行下载会出一些问题。用直连或者PAC模式，用浏览器代理，使用插件switchyomega</p><h2><span id="npm">npm</span><a href="#npm" class="header-anchor">#</a></h2><p>npm在windows下载过慢一般两个办法，换源或设置代理，linux也是这个思路。</p><h3><span id="she-zhi-dai-li">设置代理</span><a href="#she-zhi-dai-li" class="header-anchor">#</a></h3><p>先打开小飞机。使用命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set proxy http://server:port</span><br></pre></td></tr></table></figure><blockquote><p>server一般就是127.0.0.1<br>port一般是1080</p></blockquote><p>因为是在本地使用的，所以server为localhost</p><p>查看状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config list</span><br></pre></td></tr></table></figure><p>删除代理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config delete proxy</span><br></pre></td></tr></table></figure><h3><span id="huan-yuan">换源</span><a href="#huan-yuan" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>如果淘宝源不好，可以尝试清华源</p><h3><span id="she-zhi-dai-li-he-huan-yuan-de-qu-bie">设置代理和换源的区别</span><a href="#she-zhi-dai-li-he-huan-yuan-de-qu-bie" class="header-anchor">#</a></h3><blockquote><p>代理的话，是设置代理服务器，代理服务器帮你转发下载请求；镜像源的话，是镜像站点已经提前镜像(下载)了所有的npm包，你是直接从它的服务器上获取到的包</p></blockquote><h2><span id="git-linux-xiang-tong">git(linux相同)</span><a href="#git-linux-xiang-tong" class="header-anchor">#</a></h2><p>使用http方法 clone代码超时。<br>解决办法 ：使用代理。<br>因为github是国外的，http/https访问国外网址经常超时，类似与youtube , google。</p><p><img src="https://img-blog.csdnimg.cn/2ad73dd4498640689397880ce6fdb9e2.png#pic_center" alt="在这里插入图片描述"><br>查看设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><h1><span id="linux-xia-she-zhi-dai-li">Linux下设置代理</span><a href="#linux-xia-she-zhi-dai-li" class="header-anchor">#</a></h1><p>换源的方法和windows一样，设置代理有些不同。</p><h2><span id="npm-she-zhi-dai-li">npm设置代理</span><a href="#npm-she-zhi-dai-li" class="header-anchor">#</a></h2><p>需要下载代理客户端–clash<br>可以去Github直接搜索。<br><img src="https://img-blog.csdnimg.cn/8986f5c2d1ec4c1eb9143f50a80b613e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>这里面有个关键的东西：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O config.yml https://dingyue.suying666.info/link/1mrTmf9SI8DxkW5c?clash=1&amp;log-level=info</span><br></pre></td></tr></table></figure><p>http那一块是由厂家提供的，每个厂家的不一样。</p><p>按照这个教程会生成两个配置文件，.yml和.yaml。把yml里面的内容复制到.yaml，再删除yml。.yaml是新版的。</p><p>如果这个时候输出的信息不大对，或者无法使用clahs dashboard 访问，可能是配置文件有问题。</p><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./clash -f 配置文件</span><br></pre></td></tr></table></figure><p>可以看到是否有错误。</p><p>关于clash的命令可以使用help来尝试。</p><h2><span id="npm-cha-kan-yi-ge-bao-de-ban-ben-xin-xi">npm 查看一个包的版本信息</span><a href="#npm-cha-kan-yi-ge-bao-de-ban-ben-xin-xi" class="header-anchor">#</a></h2><p><strong>假设现在我们已经成功下载了jquery，过了一段时间，我忘记了下载的jquery的版本信息，这个时候，我们就需要查看本地下载的jquery版本信息，怎么做呢？</strong></p><p>第一种方式：<code>npm ls jquery</code> 即可（查看本地安装的jQuery），下面我的本地没有安装jquery，所以返回empty的结果；</p><p>第二种方式：<code>npm ls jquery -g</code> (查看全局安装的jquery)</p><p>有了npm 我们能够简单的一段代码就下载我们需要的包，但是包是不断更新的，</p><p>所以我们要关注包的版本信息；</p><p><strong>现在，假设我们需要 jquery ，但是jquery现在有很多版本，我们如何通过npm查看呢？<br>要知道，现在的jquery包在npm服务器的上，我们使用下面的命令查看：</strong></p><p>一种方式：使用<code>npm view jquery versions</code>这种方式可以查看npm服务器上所有的jquery版本信息；</p><p>第二种方式：使用<code>npm view jquery version</code>这种方式只能查看jquery的最新的版本是哪一个；</p><p>第三种方式：使用<code>npm info jquery</code>这种方式和第一种类似，也可以查看jquery所有的版本，但是能查出更多的关于jquery的信息；</p><h2><span id="npm-an-zhuang-zhi-ding-ban-ben-de-bao">npm 安装指定版本的包</span><a href="#npm-an-zhuang-zhi-ding-ban-ben-de-bao" class="header-anchor">#</a></h2><p><strong>安装指定版本的jquery-1.11.2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install jquery@1.11.0</span><br></pre></td></tr></table></figure><p><strong>安装1.0中的最新版本</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install jquery@1</span><br></pre></td></tr></table></figure><p><strong>安装2.0版本中的最新版本</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install jquery@2</span><br></pre></td></tr></table></figure><h1><span id="yarn">yarn</span><a href="#yarn" class="header-anchor">#</a></h1><h2><span id="yarn-an-zhuang">yarn安装</span><a href="#yarn-an-zhuang" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn //成功</span><br><span class="line">npm install yarn //失败</span><br></pre></td></tr></table></figure><h1><span id="pip-xia-zai-guo-man">pip 下载过慢</span><a href="#pip-xia-zai-guo-man" class="header-anchor">#</a></h1><p>由于pip/pypi默认为国外源，下载和安装Python第三方库会非常慢，建议配置国内源：<br>清华源：<br><code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></p><p>然后 pip install ***</p><h1><span id="swithcyomegy-pei-zhi">swithcyomegy配置</span><a href="#swithcyomegy-pei-zhi" class="header-anchor">#</a></h1><p>目的：让浏览器既可以访问outside，访问国内网址也不慢</p><p><img src="https://img-blog.csdnimg.cn/cabf32f8757d45c58bc49ac69d58aa74.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>默认注意几个模式的选择，默认情景模式是直接连接</p><p>规则列表如果网上找的更新失败，可以去github上面找。<br><img src="https://img-blog.csdnimg.cn/57d74b4807c14dba9e65f3dd18f989f5.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/94f842edafb9435e844181e2245b3d74.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>随便选一个<br><img src="https://img-blog.csdnimg.cn/5f590171d65c488db4c6deebc57acd0b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>复制输入框里面的网址就好了。<br><img src="https://img-blog.csdnimg.cn/62667fc0fd2d4a25b932d201dcb1f7db.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>第一次更新情景模式要调成直连模式，后面换为PAC模式。然后switchyomegy换位auto switch</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;windows&quot;&gt;Windows&lt;/span&gt;&lt;a href=&quot;#windows&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;liu-lan-qi&quot;&gt;浏览器&lt;/span&gt;&lt;a href=&quot;#liu-la</summary>
      
    
    
    
    <category term="小知识" scheme="http://example.com/categories/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
    <category term="npm" scheme="http://example.com/tags/npm/"/>
    
    <category term="yarn" scheme="http://example.com/tags/yarn/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://example.com/2022/01/15/Docker/"/>
    <id>http://example.com/2022/01/15/Docker/</id>
    <published>2022-01-15T08:19:44.586Z</published>
    <updated>2022-01-15T08:30:21.008Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="docker-xia-zai">docker下载</span><a href="#docker-xia-zai" class="header-anchor">#</a></h1><h2><span id="docker-an-zhuang">Docker安装</span><a href="#docker-an-zhuang" class="header-anchor">#</a></h2><p>1）卸载旧版本<br>yum list installed | grep docker 列出当前所有docker的包<br>yum -y remove docker的包名称 卸载docker包<br>rm -rf /var/lib/docker 删除docker的所有镜像和容器<br>2）安装必要的软件包<br>sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm2<br>3）设置下载的镜像仓库<br>sudo yum-config-manager \ –add-repo \ <a href="https://download.docker.com/linux/centos/docker-ce.repo">https://download.docker.com/linux/centos/docker-ce.repo</a><br>如果下载失败，采用阿里源和清华源。（详见菜鸟教程）<br>4）列出需要安装的版本列表<br>yum list docker-ce –showduplicates | sort -r<br>5）安装指定版本（这里使用18.0.1版本）<br>sudo yum install docker-ce-18.06.1.ce<br>6）查看版本<br>docker -v<br>7）启动Docker<br>sudo systemctl start docker 启动<br>sudo systemctl enable docker 设置开机启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure><p>列出版本列表，看看是否下载成功</p><p>添加镜像地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/docker/daemon.json //没有这个文件也无妨，直接创建就好</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/cecd311ce895425cafdd7a8edf9a376a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这个地址的来源：<br>访问阿里云这个网址，要先登录：<a href="https://cr.console.aliyun.com/?spm=a2c6h.12873639.0.0.7aec4073HlA7e2#/accelerator">镜像加速页面</a></p><p><img src="https://img-blog.csdnimg.cn/641489fc54e74da0b71ef979826d1a3f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2><span id="docker-qi-dong-shi-bai">docker启动失败</span><a href="#docker-qi-dong-shi-bai" class="header-anchor">#</a></h2><p><strong>错误1：</strong><br>如图所示：<br><img src="https://img-blog.csdnimg.cn/56ed8bac9f524db3b2dbf64efaff96a0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>原因：</p><p>当时在 /etc/docker/daemon.json  添加了一行，但是忘了在第一行后面添加 “逗号”，加上就好。<br><img src="https://img-blog.csdnimg.cn/7c623f0bb0114b33a4f91a93a9da0450.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>错误2：</strong><br>docker启动失败，有一个可能就是包（jar,war）有问题。可以先单独检测下包是否可以运行。如果包不能运行，就是代码有问题。<br><strong>如果代码逻辑没有问题，甚至没有改动。可能要注意格式问题，比如少敲或多敲空格这种，这种错误往往看不出来，或者编译器没有明显的错误提示（idea对于这个问题就是标黄，但有时候又不影响，很容易不注意）</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;docker-xia-zai&quot;&gt;docker下载&lt;/span&gt;&lt;a href=&quot;#docker-xia-zai&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;docker-an-zhuang&quot;&gt;Docke</summary>
      
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="运维" scheme="http://example.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="http://example.com/2022/01/15/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://example.com/2022/01/15/%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2022-01-15T08:18:29.011Z</published>
    <updated>2022-01-15T08:30:16.135Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="mysql">Mysql</span><a href="#mysql" class="header-anchor">#</a></h1><h2><span id="mysql-guan-wang-xia-zai-lao-ban-ben">mysql官网下载老版本</span><a href="#mysql-guan-wang-xia-zai-lao-ban-ben" class="header-anchor">#</a></h2><p><a href="https://dev.mysql.com/downloads/mysql/">下载网址，可选操作系统</a></p><p>进入后依次选择：DOWNLOADS（下载）——&gt;Community(社区)——MySQL Community Downloads<br><img src="https://img-blog.csdnimg.cn/d11d8469ebcd411faf3c9b67c4f4e02b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>进入后往下拉，如下图选择Looking for previous GA versions（寻找以前的GA版本）<br><img src="https://img-blog.csdnimg.cn/1371dd641c0e4c3ab54e10660e5907ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2><span id="centos-an-zhuang-mysql">centos安装mysql</span><a href="#centos-an-zhuang-mysql" class="header-anchor">#</a></h2><p>本地下载mysql，但是xftp上传太慢，暂未找到解决的办法，所以尝试下面这个方法。</p><p><strong>1 下载并安装MySQL官方的 Yum Repository</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</span><br></pre></td></tr></table></figure><p>使用上面的命令就直接下载了安装用的Yum Repository，大概25KB的样子，然后就可以直接yum安装了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mysql57-community-release-el7-10.noarch.rpm</span><br></pre></td></tr></table></figure><p> 之后就开始安装MySQL服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></table></figure><p>这步可能会花些时间，安装完成后就会覆盖掉之前的mariadb。<br><img src="https://img-blog.csdnimg.cn/000f9e71988a495bb16d7f886050e5f7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>至此MySQL就安装完成了，然后是对MySQL的一些设置。</p><p><strong>2 MySQL数据库设置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start  mysqld.service // 首先启动MySQL</span><br><span class="line"></span><br><span class="line">systemctl status mysqld.service //查看MySQL运行状态</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/acda61b3da8b4837ad7bdf9020468ea1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>此时MySQL已经开始正常运行，不过要想进入MySQL还得先找出此时root用户的密码，通过如下命令可以在日志文件中找出密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;password&quot; /var/log/mysqld.log</span><br></pre></td></tr></table></figure><p> 如下命令进入数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>输入初始密码，此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;new password&#x27;;</span><br><span class="line">//密码需要设置复杂点，不然会报错。原因是因为MySQL有密码设置的规范，具体是与validate_password_policy的值有关：</span><br></pre></td></tr></table></figure><p><strong>3.密码修改</strong><br><em><strong>上面那一步修改是必须的，否则没法二次修改密码</strong></em></p><p>先进入mysql</p><p>查看 mysql 初始的密码策略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;validate_password%&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/0d3db11aae794c05adf48c94ade4094b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>首先需要设置密码的验证强度等级，设置 validate_password_policy 的全局参数为 LOW 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global validate_password_policy=LOW; </span><br></pre></td></tr></table></figure><p>当前密码长度为 8 ，如果不介意的话就不用修改了，按照通用的来讲，设置为 6 位的密码，设置 validate_password_length 的全局参数为 6 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global validate_password_length=6;</span><br></pre></td></tr></table></figure><p>现在可以为 mysql 设置简单密码了，只要满足六位的长度即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p>注：在默认密码的长度最小值为 4 ，由 大/小写字母各一个 + 阿拉伯数字一个 + 特殊字符一个， 只要设置密码的长度小于 3<br>，都将自动设值为 4 ，如下图：</p><br><p>关于 mysql 密码策略相关参数；<br> 1）、validate_password_length  固定密码的总长度；<br>2）、validate_password_dictionary_file 指定密码验证的文件路径；<br>3）、validate_password_mixed_case_count  整个密码中至少要包含大/小写字母的总个数；<br>4）、validate_password_number_count  整个密码中至少要包含阿拉伯数字的个数；<br>5）、validate_password_policy 指定密码的强度验证等级，默认为 MEDIUM； 关于<br>validate_password_policy 的取值： 0/LOW：只验证长度； 1/MEDIUM：验证长度、数字、大小写、特殊字符；<br>2/STRONG：验证长度、数字、大小写、特殊字符、字典文件；<br>6）、validate_password_special_char_count 整个密码中至少要包含特殊字符的个数；</p></blockquote><h2><span id="navicat-lian-jie-mysql-chu-xian-1130-host-xxx-is-not-allowed-to-connect-to-this-mysql-server">Navicat连接mysql出现1130 - Host XXX is not allowed to connect to this MySQL server</span><a href="#navicat-lian-jie-mysql-chu-xian-1130-host-xxx-is-not-allowed-to-connect-to-this-mysql-server" class="header-anchor">#</a></h2><p>接上一条，安装完成后，navicat无法正常连接，这是由于Mysql配置了不支持远程连接引起的。</p><p><strong>1.在安装Mysql数据库的主机上登录root用户</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>2.依次执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line"> </span><br><span class="line">select host from user where user=&#x27;root&#x27;;</span><br></pre></td></tr></table></figure><p>可以看到当前主机配置信息为localhost.<br><img src="https://img-blog.csdnimg.cn/e4dee3a582374c6eba09244e9b947247.png" alt="在这里插入图片描述"><br>3.将Host设置为通配符%</p><p>Host列指定了允许用户登录所使用的IP，比如user=root Host=192.168.1.1。这里的意思就是说root用户只能通过192.168.1.1的客户端去访问。 user=root Host=localhost，表示只能通过本机客户端去访问。而%是个通配符，如果Host=192.168.1.%，那么就表示只要是IP地址前缀为“192.168.1.”的客户端都可以连接。如果Host=%，表示所有IP都有连接权限。 </p><p><strong>注意：在生产环境下不能为了省事将host设置为%，这样做会存在安全问题，具体的设置可以根据生产环境的IP进行设置；</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user set host = &#x27;%&#x27; where user =&#x27;root&#x27;;</span><br></pre></td></tr></table></figure><p>Host设置了“%”后便可以允许远程访问。</p><p><img src="https://img-blog.csdnimg.cn/8a3b8bb5074a4f8b9132a2eebdec3301.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>4..Host修改完成后记得执行flush privileges使配置立即生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><br>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;mysql&quot;&gt;Mysql&lt;/span&gt;&lt;a href=&quot;#mysql&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;mysql-guan-wang-xia-zai-lao-ban-ben&quot;&gt;mysql官网</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="运维" scheme="http://example.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql" scheme="http://example.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>工具（office、IDE、编辑器等）快捷键集合</title>
    <link href="http://example.com/2022/01/15/%E5%B7%A5%E5%85%B7%EF%BC%88office%E3%80%81IDE%E3%80%81%E7%BC%96%E8%BE%91%E5%99%A8%E7%AD%89%EF%BC%89%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%9B%86%E5%90%88/"/>
    <id>http://example.com/2022/01/15/%E5%B7%A5%E5%85%B7%EF%BC%88office%E3%80%81IDE%E3%80%81%E7%BC%96%E8%BE%91%E5%99%A8%E7%AD%89%EF%BC%89%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%9B%86%E5%90%88/</id>
    <published>2022-01-15T08:09:58.017Z</published>
    <updated>2022-01-15T08:30:07.645Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="jupyter">jupyter</span><a href="#jupyter" class="header-anchor">#</a></h1><h2><span id="cell-zhong-code-he-markdown-de-qie-huan">Cell中 Code 和 Markdown的切换</span><a href="#cell-zhong-code-he-markdown-de-qie-huan" class="header-anchor">#</a></h2><blockquote><p>在一个cell中（在command模式下） 按下 y, 进入Code 按下m, 进入Markdown</p></blockquote><h1><span id="vscode">VSCode</span><a href="#vscode" class="header-anchor">#</a></h1><h2><span id="kuai-su-chong-qi">快速重启</span><a href="#kuai-su-chong-qi" class="header-anchor">#</a></h2><p>打开命令面板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+shift+p</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reload Window</span><br></pre></td></tr></table></figure><h2><span id="cha-xun">查询</span><a href="#cha-xun" class="header-anchor">#</a></h2><ol><li>寻找文件夹中的文本内容 <br></li></ol><blockquote><p> 工具栏，编辑-&gt;查找</p></blockquote><ol start="2"><li>查找文件夹中的文件：</li></ol><blockquote><p>ctrl+p</p></blockquote><h2><span id="lie-xuan-ze-kuai-jie-jian">列选择快捷键</span><a href="#lie-xuan-ze-kuai-jie-jian" class="header-anchor">#</a></h2><p><img src="https://img-blog.csdnimg.cn/99fdf312492c4b4db617bfc61546bffc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h1><span id="bu-xiao-xin-guan-bi-liao-mou-ge-ye-mian">不小心关闭了某个页面</span><a href="#bu-xiao-xin-guan-bi-liao-mou-ge-ye-mian" class="header-anchor">#</a></h1><p>恢复： </p><blockquote><p>ctrl+shift+t</p></blockquote><h1><span id="ide">IDE</span><a href="#ide" class="header-anchor">#</a></h1><h2><span id="intellij-idea-kuai-su-sheng-cheng-main-fang-fa-for-xun-huan-out-shu-chu">intellij idea快速生成main方法、for循环、out输出</span><a href="#intellij-idea-kuai-su-sheng-cheng-main-fang-fa-for-xun-huan-out-shu-chu" class="header-anchor">#</a></h2><p><img src="https://img-blog.csdnimg.cn/ff17e40bd4ea43169a3ef746cbb36550.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">2.快速向下复制一行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+d</span><br></pre></td></tr></table></figure><h1><span id="kuai-su-kai-qi-powershell">快速开启powershell</span><a href="#kuai-su-kai-qi-powershell" class="header-anchor">#</a></h1><p>在需要启动powershell的文件里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shift+右键</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/a3d91843cc7245db81df0ba36eeadc29.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1><span id="everything-hen-duo-wen-jian-sou-suo-bu-dao">Everything很多文件搜索不到</span><a href="#everything-hen-duo-wen-jian-sou-suo-bu-dao" class="header-anchor">#</a></h1><p>工具-&gt;选项-&gt;左侧找”索引”-&gt;点击里面的”强制重建”</p><p>可解决这个问题，以避免卸载重装</p><h1><span id="word">Word</span><a href="#word" class="header-anchor">#</a></h1><h2><span id="xiang-mu-feng-mian-wen-ti">项目封面问题</span><a href="#xiang-mu-feng-mian-wen-ti" class="header-anchor">#</a></h2><p><img src="https://img-blog.csdnimg.cn/66dad9a8d7944bb98f925bcff19989fe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>封面经常会对不齐，可以新建一个<strong>3列表格</strong>。在表格里面调整对齐。</p><h1><span id="ppt">PPT</span><a href="#ppt" class="header-anchor">#</a></h1><h1><span id="excel">Excel</span><a href="#excel" class="header-anchor">#</a></h1><h1><span id="dai-ma-dui-bi-gong-ju">代码对比工具</span><a href="#dai-ma-dui-bi-gong-ju" class="header-anchor">#</a></h1><h2><span id="sublime">sublime</span><a href="#sublime" class="header-anchor">#</a></h2><p><img src="https://img-blog.csdnimg.cn/3d989651b0d14c65a56aea98f857013d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1><span id="ssh-ke-hu-duan">SSH客户端</span><a href="#ssh-ke-hu-duan" class="header-anchor">#</a></h1><h2><span id="mobaxterm">MobaXterm</span><a href="#mobaxterm" class="header-anchor">#</a></h2><p>选择它的原因是因为可以直接将windonws下的文件拖拽过来，不用通过专门的传输软件（xftp），且不用命令可以看到目录结构<br><img src="https://img-blog.csdnimg.cn/e86c8f5d1e0f4262a73dc4dc958a4cd8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3><span id="fu-zhi">复制</span><a href="#fu-zhi" class="header-anchor">#</a></h3><p>不用设置，MobaXTerm 里面选取内容就已经复制了，如图，白色的内容就已经成功复制了哈哈哈哈，真方便。<br><img src="https://img-blog.csdnimg.cn/ff09c618917940a79a19b1da827f9b59.png" alt="在这里插入图片描述"><br>如果不行，看看是否是这里没有勾上（在 setting 里的 Configuration里面）：<br><img src="https://img-blog.csdnimg.cn/2cbe8be79b734c069e1f1920e9080f12.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3><span id="nian-tie">粘贴</span><a href="#nian-tie" class="header-anchor">#</a></h3><p>MobaXterm默认的复制键不是 ctrl+v，当初复制服务器密码的时候老出错，一度怀疑密码错了。<br>这个快捷键可以设置</p><p><img src="https://img-blog.csdnimg.cn/cc6fb7c9545f447b902bc8af4ea94ba3.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/fa9344127b15405cbc97e18c8cb92998.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>好了，现在 复制-粘贴 就是：选中，Ctrl + V</p><h3><span id="xia-zai-wen-jian-dao-ben-di">下载文件到本地</span><a href="#xia-zai-wen-jian-dao-ben-di" class="header-anchor">#</a></h3><p>选中目标文件，右击 ，Download。<br><img src="https://img-blog.csdnimg.cn/95fc0ebdbabd46918713cb124e31ace9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3><span id="xiu-gai-zi-ti">修改字体</span><a href="#xiu-gai-zi-ti" class="header-anchor">#</a></h3><p>修改完成后要重新新建会话才会生效。<br><img src="https://img-blog.csdnimg.cn/217b607feab24741a1d55f3abd15c627.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;jupyter&quot;&gt;jupyter&lt;/span&gt;&lt;a href=&quot;#jupyter&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;cell-zhong-code-he-markdown-de-qie-hua</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="office" scheme="http://example.com/tags/office/"/>
    
    <category term="IDE" scheme="http://example.com/tags/IDE/"/>
    
    <category term="编辑器" scheme="http://example.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux知识点</title>
    <link href="http://example.com/2022/01/15/Linux%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://example.com/2022/01/15/Linux%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-01-15T08:06:24.154Z</published>
    <updated>2022-01-15T08:30:32.577Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="fen-qu-gua-zai">分区+挂载</span><a href="#fen-qu-gua-zai" class="header-anchor">#</a></h1><h2><span id="fen-qu">分区</span><a href="#fen-qu" class="header-anchor">#</a></h2><p>详细信息：<a href="https://blog.csdn.net/qq_30604989/article/details/81163270">来源该博客</a><br><img src="https://img-blog.csdnimg.cn/edd06e4319f24f1092d6f7bba9955937.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ol><li>在linux下，一个硬盘要先分区，然后才能挂载到目录上。和windows相同。</li></ol><p> <img src="https://img-blog.csdnimg.cn/a8ef1355fa2f4595a7b69da0b0bb50ec.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2><span id="gua-zai">挂载</span><a href="#gua-zai" class="header-anchor">#</a></h2><p><img src="https://img-blog.csdnimg.cn/0189f5afb0f24dde85c540fc5b8c887f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br></pre></td></tr></table></figure><p>这一步是对sdb这个磁盘分区。<br><img src="https://img-blog.csdnimg.cn/bde5f9eba20b477bbeb551a9cb4bc246.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>接下来是格式化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t ext4 /dev/sdb1</span><br></pre></td></tr></table></figure><p>挂载：将分区和目录联系起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount 设备名 目录名</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sdb1 /home/newdisk</span><br></pre></td></tr></table></figure><p>这个方法重启会失效，设置永久挂载。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/fstab</span><br></pre></td></tr></table></figure><h2><span id="jie-chu-gua-zai">解除挂载</span><a href="#jie-chu-gua-zai" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount 设备名</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/d9ca57a5c9bf44589498a26a8baea9e5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;fen-qu-gua-zai&quot;&gt;分区+挂载&lt;/span&gt;&lt;a href=&quot;#fen-qu-gua-zai&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;fen-qu&quot;&gt;分区&lt;/span&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="运维" scheme="http://example.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="持续集成" scheme="http://example.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://example.com/2022/01/15/linux%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/01/15/linux%E5%91%BD%E4%BB%A4/</id>
    <published>2022-01-15T08:02:41.233Z</published>
    <updated>2022-01-19T07:30:01.993Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="fu-zhi-yi-dong-wen-jian-wen-jian-gai-ming">复制/移动文件、文件改名</span><a href="#fu-zhi-yi-dong-wen-jian-wen-jian-gai-ming" class="header-anchor">#</a></h1><ol><li><code>cp /xx/xx(a)  /xx/xx(a)</code>   :复制   ~~~~  //将a复制到b</li><li><code>mv /xx /xx /xx/xx</code> :剪切</li><li><code>mv 旧文件夹名 新文件夹名</code>   //更改名字</li></ol><h1><span id="cha-kan-duan-kou">查看端口</span><a href="#cha-kan-duan-kou" class="header-anchor">#</a></h1><h2><span id="cha-kan-mou-ge-fu-wu-de-zhuang-tai">查看某个服务的状态</span><a href="#cha-kan-mou-ge-fu-wu-de-zhuang-tai" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service ‘servicename’ status</span><br><span class="line">//centos7以上用 systemctl</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd status //查看sshd服务的状态，可以看到它的进程号，如果不需要可以kill 杀死</span><br></pre></td></tr></table></figure><h2><span id="lsof-i-duan-kou-hao">lsof -i:端口号</span><a href="#lsof-i-duan-kou-hao" class="header-anchor">#</a></h2><p><img src="https://img-blog.csdnimg.cn/76c06a2619c04918af8a7331869739fd.png" alt="在这里插入图片描述"><br>可以看到 8000 端口已经被轻 nodejs 服务占用。</p><p><img src="https://img-blog.csdnimg.cn/a9bdaa252c8c4083baf16c1e664416ac.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2><span id="netstat-tunlp-grep-duan-kou-hao">netstat -tunlp | grep 端口号  <br></span><a href="#netstat-tunlp-grep-duan-kou-hao" class="header-anchor">#</a></h2><p><strong>用于显示 tcp，udp 的端口和进程等相关情况</strong></p><blockquote><p>-t (tcp) 仅显示tcp相关选项<br>-u (udp)仅显示udp相关选项<br>-n 拒绝显示别名，能显示数字的全部转化为数字<br>-l 仅列出在Listen(监听)的服务状态<br>-p 显示建立相关链接的程序名</p></blockquote><p><img src="https://img-blog.csdnimg.cn/b16427d1c6cc430080b1dae37360358c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2><span id="kill-sha-si-jin-cheng">kill(杀死进程)</span><a href="#kill-sha-si-jin-cheng" class="header-anchor">#</a></h2><p><img src="https://img-blog.csdnimg.cn/e228676961554ebaa0725d3cad3b14c6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2><span id="telnet-jian-ce-duan-kou-shi-fou-ke-yong">telnet(检测端口是否可用)</span><a href="#telnet-jian-ce-duan-kou-shi-fou-ke-yong" class="header-anchor">#</a></h2><p>有时我们想知道端口是否开启。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tenlet ip 端口</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/46ee47447ace457e95d472fef5ea9ea8.png" alt="在这里插入图片描述">上图表示：80端口开放，8899端口未开放。</p><h1><span id="touch-ming-ling-chuang-jian-wen-jian">touch命令(创建文件)</span><a href="#touch-ming-ling-chuang-jian-wen-jian" class="header-anchor">#</a></h1><p><code>touch</code>命令用于修改文件或者目录的时间属性，包括存取时间和更改时间，若文件不存在，系统会建立一个新的文件。</p><p>创建一个空白文件，如果文件已经存在，它将更改文件的访问时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch /tmp/file.txt</span><br></pre></td></tr></table></figure><p>创建多个文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch /tmp/file1.txt /tmp/file2.txt /tmp/file3.txt</span><br></pre></td></tr></table></figure><p>修改文件的修改时间并查看文件属性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch -m /tmp/file.txt &amp;&amp; stat /tmp/file.txt</span><br></pre></td></tr></table></figure><p>同时修改访问时间和修改时间并设置一个特定的访问与修改时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch -am -t 202007010000.00 /tmp/file.txt &amp;&amp; stat /tmp/file.txt</span><br></pre></td></tr></table></figure><h1><span id="cat-ming-ling-xian-shi-wen-jian-nei-rong">cat命令(显示文件内容)</span><a href="#cat-ming-ling-xian-shi-wen-jian-nei-rong" class="header-anchor">#</a></h1><p><code>cat</code>命令属于文件管理，用于连接文件并打印到标准输出设备上，<code>cat</code>经常用来显示文件的内容，注意，当文件较大时，文本在屏幕上迅速闪过，会出现滚屏现象，此时往往看不清所显示的内容，为了控制滚屏，可以按<code>Ctrl+S</code>键停止滚屏，按<code>Ctrl+Q</code>键可以恢复滚屏，此外可以用<code>more</code>等命令进行读文件并分页显示。</p><p>使用<code>cat</code>命令创建一个文件，输入文件信息后按<code>Ctrl+D</code>输出<code>EOF</code>标识后结束输入。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; file.txt</span><br></pre></td></tr></table></figure><p>输出<code>file.txt</code>文件中的内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt</span><br></pre></td></tr></table></figure><p>同时输出<code>file.txt</code>与<code>file2.txt</code>文件中的内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt file2.txt</span><br></pre></td></tr></table></figure><p>把<code>file.txt</code>文件的内容加上行号后追加到<code>file2.txt</code>文件中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n file.txt &gt;&gt; file2.txt</span><br></pre></td></tr></table></figure><p>清空<code>file2.txt</code>文件，<code>/dev/null</code>称为空设备，是一个特殊的设备文件，其会丢弃一切写入其中的数据，但报告写入操作成功，读取它则会立即得到一个<code>EOF</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/null &gt; file2.txt</span><br></pre></td></tr></table></figure><p>将<code>file.txt</code>与<code>file2.txt</code>文件内容合并输出到<code>file3.txt</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt file2.txt &gt; file3.txt</span><br></pre></td></tr></table></figure><h1><span id="centos7-te-xing">Centos7特性</span><a href="#centos7-te-xing" class="header-anchor">#</a></h1><p>服务相关命令使用systemctl，之前的版本是service</p><blockquote><p>systemctl (stop/restart/start)  (服务)<br>systemctl restart nginx</p></blockquote><h1><span id="fang-huo-qiang">防火墙</span><a href="#fang-huo-qiang" class="header-anchor">#</a></h1><h2><span id="kai-qi-duan-kou-yi-80-wei-li">开启端口（以80为例）</span><a href="#kai-qi-duan-kou-yi-80-wei-li" class="header-anchor">#</a></h2><blockquote><p>firewall-cmd –zone=public –add-port=80/tcp –permanent</p></blockquote><h2><span id="chong-qi-fang-huo-qiang">重启防火墙</span><a href="#chong-qi-fang-huo-qiang" class="header-anchor">#</a></h2><blockquote><p>systemctl restart firewalld.service</p></blockquote><p><strong>不同的系统命令可能不同</strong></p><h1><span id="xiu-gai-zhu-ji-ming">修改主机名</span><a href="#xiu-gai-zhu-ji-ming" class="header-anchor">#</a></h1><h2><span id="debian-ubuntu-xi-lie">debian/ubuntu系列</span><a href="#debian-ubuntu-xi-lie" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">第一步：</span><br><span class="line">vi /etc/hostname</span><br><span class="line">写入</span><br><span class="line"></span><br><span class="line">HOSTNAME=yourhostname</span><br><span class="line">保存后执行以下：</span><br><span class="line"></span><br><span class="line">hostname yourhostname</span><br><span class="line"> 查看设置后的hostname</span><br><span class="line">hostname</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第二步：</span><br><span class="line">vi /etc/hosts</span><br><span class="line">修改成新的主机名</span><br></pre></td></tr></table></figure><h2><span id="redhat-centos-xi-lie">redhat/centos系列</span><a href="#redhat-centos-xi-lie" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/network</span><br><span class="line">输入以下：</span><br><span class="line"></span><br><span class="line">HOSTNAME=yourhostname</span><br><span class="line">保存后执行以下：</span><br><span class="line"></span><br><span class="line">hostname yourhostname</span><br><span class="line"> 查看设置后的hostname</span><br><span class="line">hostname</span><br></pre></td></tr></table></figure><h1><span id="vim-xiang-guan-cao-zuo">vim相关操作</span><a href="#vim-xiang-guan-cao-zuo" class="header-anchor">#</a></h1><h2><span id="fu-zhi">复制</span><a href="#fu-zhi" class="header-anchor">#</a></h2><p>1）单行复制</p><p>在命令模式下，将光标移动到将要复制的行处，按“yy”进行复制；</p><p>2）多行复制 在命令模式下，将光标移动到将要复制的首行处，按“nyy”复制n行；其中n为1、2、3……</p><p>【yy】 复制光标所在的那一行<br>【nyy】 复制光标所在的向下n行</p><h2><span id="nian-tie">粘贴</span><a href="#nian-tie" class="header-anchor">#</a></h2><p>在命令模式下，将光标移动到将要粘贴的行处，按“p”进行粘贴</p><p>【p,P】 p为将已经复制的数据在光标下一行粘贴；P为将已经复制的数据在光标上一行粘贴</p><h2><span id="shan-chu">删除</span><a href="#shan-chu" class="header-anchor">#</a></h2><p>删除一行：dd</p><p>删除一个单词/光标之后的单词剩余部分：dw</p><p>删除当前字符：x</p><p>光标之后的该行部分：d$</p><p>文本删除</p><p>dd 删除一行</p><p>d$ 删除以当前字符开始的一行字符</p><p>ndd 删除以当前行开始的n行</p><p>dw 删除以当前字符开始的一个字</p><p>ndw 删除以当前字符开始的n个字</p><h2><span id="cha-zhao">查找</span><a href="#cha-zhao" class="header-anchor">#</a></h2><p>【/word】 在文件中查找内容为word的字符串（向下查找）<br>【?word】 在文件中查找内容为word的字符串（向上查找）<br>【[n]】 表示重复查找动作，即查找下一个<br>【[N]】 反向查找下一个</p><p>搜索后，我们打开别的文件，发现也被高亮了，怎么关闭高亮？</p><p>命令模式下，输入:nohlsearch  也可以:set nohlsearch； 当然，可以简写，noh或者set noh。<br>PS：nohlsearch是（no highlight search缩写）</p><h2><span id="she-zhi-xing-hao">设置行号</span><a href="#she-zhi-xing-hao" class="header-anchor">#</a></h2><p>如果编辑后，又想显示行号，同样操作按一下esc键，并输入:（冒号），输入set number    ，并按回车键，完成后即显示行号</p><h2><span id="tiao-dao-zhi-ding-xing">跳到指定行</span><a href="#tiao-dao-zhi-ding-xing" class="header-anchor">#</a></h2><p>在知道所查找的内容在文件中的具体位置时可以使用以下命令直接定位：<br>跳到文件指定行：比如跳到66行</p><p>66+G（也就是66+shift+g）<br>当然你可以选择另一种跳转方式：</p><p>命令行输入“ : n ” 然后回车<br>跳到文件第一行：gg （两个小写的G）</p><p>跳到文件最后一行：shift+g （也就是G）</p><h2><span id="wen-jian-shang-xia-fan-zhuan">文件上下翻转</span><a href="#wen-jian-shang-xia-fan-zhuan" class="header-anchor">#</a></h2><p>页翻转可以直接使用PgUp和PgDn</p><p>向前滚动一屏：Ctrl+F</p><p>向后滚动一屏：Ctrl+B</p><p>向前滚动半屏：Ctrl+D（向下）</p><p>向后滚动半屏：Ctrl+U（向上）</p><p>向下滚动一行，保持当前光标不动：Ctrl+E</p><p>向上滚动一行，保持当前光标不动：Ctrl+Y</p><p>当前行滚动：<br>当前行移动到屏幕顶部并滚动：Z+Enter<br>滚动指定行到屏幕顶部： 10Z+Enter（指定第十行）<br>当前行移动到屏幕中央并滚动：Z + .<br>当前行移动到屏幕底部并滚动：Z + -<br>当前屏幕操作：<br>H：大写h，移动到当前屏幕首行；nH移动到首行下的第n行<br>M：大写m，移动到当前屏幕中间行<br>L：大写l，移动到当前屏幕末行；nL移动到末行上面的第n行</p><h2><span id="che-xiao-shang-yi-bu-cao-zuo">撤销上一步操作</span><a href="#che-xiao-shang-yi-bu-cao-zuo" class="header-anchor">#</a></h2><p>【u】 撤消上一个操作<br>【[Ctrl] + r】 多次撤消<br>【.】 这是小数点键，重复上一个操作</p><p>  缩进：</p><p>  插入模式下，ctrl+shift+d 减少缩进，ctrl+shift+t 增加缩进</p><h2><span id="vim-bian-ji">vim编辑</span><a href="#vim-bian-ji" class="header-anchor">#</a></h2><p>1、进入插入模式（６个命令）<br>【i】 从目前光标所在处插入<br>【I】 从目前光标<br>【a】 从当前光标所在的下一个字符处开始插入<br>【A】 从光标所在行的最后一个字符处开始插入<br>【o】 英文小写字母o，在目前光标所在行的下一行处插入新的一行并开始插入<br>【O】 英文大写字母O，在目前光标所在行的上一行处插入新的一行并开始插入</p><p> 2、进入替换模式（2个命令）<br>【r】 只会替换光标所在的那一个字符一次<br>【R】 会一直替换光标所在字符，直到按下[ESC]键为止<br>【[ESC]】 退出编辑模式回到一般模式</p><p>  3、一般模式切换到命令行模式<br>【:w】 保存文件<br>【:w!】 若文件为只读，强制保存文件<br>【:q】 离开vi<br>【:q!】 不保存强制离开vi<br>【:wq】 保存后离开<br>【:wq!】 强制保存后离开<br>【:! command】 暂时离开vi到命令行下执行一个命令后的显示结果<br>【:set nu】 显示行号<br>【:set nonu】 取消显示行号<br>【:w newfile】 另存为<br>【:set fileencoding】 查看当前文件编码格式<br>【:set fileencoding=utf-8】 设置当前文件编码格式为utf-8，也可以设置成其他编码格式<br>【:set fileformat】 查看当前文件的断行格式（dos\windows,unix或macintosh）<br>【:set fileformat=unix】 将当前文件的断行格式设置为unix格式</p><h2><span id="duo-chuang-kou-gong-neng">多窗口功能</span><a href="#duo-chuang-kou-gong-neng" class="header-anchor">#</a></h2><p>【:sp [filename]】 打开一个新窗口，显示新文件，若只输入:sp，则两窗口显示同一个文件<br>【[Ctrl] + w + j】 光标移动到下方窗口<br>【[Ctrl] + w + k】 光标移动到上方窗口<br>【[Ctrl] + w + q】 离开当前窗口</p><h2><span id="suo-jin">缩进</span><a href="#suo-jin" class="header-anchor">#</a></h2><p>批量缩进</p><p>在程序代码界面，按esc，退出编辑模式，到命令模式，并在英语输入法下输入“：”</p><p>将所要批量缩进的行号写上，按照格式：“行号1，行号2&gt;”输入命令，如要将2至9行批量缩进一个tab值，则命令为“2,9&gt;”</p><p>输入完毕后，按回车可以执行，就可以看到2至9行全部缩进了一个tab值了，同样的，如果要缩回来一个tab值，则用命令“行号1，行号2&lt;”即可</p><p>可视模式缩进</p><p>方法二是在可视模式下选择要移动的列，操作为，esc从编辑模式退到命令模式，将光标移到需要缩进的行的行首，然后按shift+v，可以看到该行已被选中，且左下角提示为“可视”</p><p>此时，按键盘上的上下左右方向键，如这里按向下的箭头，选中所有需要批量缩进的行</p><p>选择好了之后，按shift+&gt;,是向前缩进一个tab值，按shift+&lt;，则是缩回一个tab值，</p><h1><span id="she-zhi-ssh-tong-guo-mi-yao-deng-lu">设置 SSH 通过密钥登录</span><a href="#she-zhi-ssh-tong-guo-mi-yao-deng-lu" class="header-anchor">#</a></h1><h2><span id="zhi-zuo-mi-yao-dui">制作密钥对</span><a href="#zhi-zuo-mi-yao-dui" class="header-anchor">#</a></h2><blockquote><p>我们一般使用 PuTTY 等 SSH 客户端来远程管理 Linux<br>服务器。但是，一般的密码方式登录，容易有密码被暴力破解的问题。所以，一般我们会将 SSH 的端口设置为默认的 22 以外的端口，或者禁用<br>root 账户登录。其实，有一个更好的办法来保证安全，而且让你可以放心地用 root 账户从远程登录——那就是通过密钥方式登录。</p><p>密钥形式登录的原理是：利用密钥生成器制作一对密钥——一只公钥和一只私钥。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。这样一来，没有私钥，任何人都无法通过<br>SSH 暴力破解你的密码来远程登录到系统。此外，如果将公钥复制到其他账户甚至主机，利用私钥也可以登录。</p><p>下面来讲解如何在 Linux 服务器上制作密钥对，将公钥添加给账户，设置 SSH，最后通过客户端登录。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">首先在服务器上制作密钥对。首先用密码登录到你打算使用密钥登录的账户，然后执行以下命令：</span><br><span class="line"></span><br><span class="line">[root@host ~]$ ssh-keygen  &lt;== 建立密钥对</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/root/.ssh/id_rsa): &lt;== 按 Enter。如果输入其它字符，比如test，那么生产的私钥是test，公钥是test.pub。说白了就是让你输入密钥文件名，不输入就采用默认的。</span><br><span class="line">Created directory &#x27;/root/.ssh&#x27;.</span><br><span class="line">Enter passphrase (empty for no passphrase): &lt;== 输入密钥锁码，后续使用私钥登录的时候会要求输密码，建议输入；或直接按 Enter 留空</span><br><span class="line">Enter same passphrase again: &lt;== 再输入一遍密钥锁码</span><br><span class="line">Your identification has been saved in /root/.ssh/id_rsa. &lt;== 私钥</span><br><span class="line">Your public key has been saved in /root/.ssh/id_rsa.pub. &lt;== 公钥</span><br><span class="line">The key fingerprint is:</span><br><span class="line">0f:d3:e7:1a:1c:bd:5c:03:f1:19:f1:22:df:9b:cc:08 root@host</span><br><span class="line">密钥锁码在使用私钥时必须输入，这样就可以保护私钥不被盗用。当然，也可以留空，实现无密码登录。</span><br><span class="line"></span><br><span class="line">现在，在 root 用户的家目录中生成了一个 .ssh 的隐藏目录，内含两个密钥文件。id_rsa 为私钥，id_rsa.pub 为公钥。</span><br></pre></td></tr></table></figure><h2><span id="zai-fu-wu-qi-shang-an-zhuang-gong-yao">在服务器上安装公钥</span><a href="#zai-fu-wu-qi-shang-an-zhuang-gong-yao" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">键入以下命令，在服务器上安装公钥：</span><br><span class="line"></span><br><span class="line">[root@host ~]$ cd .ssh</span><br><span class="line">[root@host .ssh]$ cat id_rsa.pub &gt;&gt; authorized_keys</span><br><span class="line">如此便完成了公钥的安装。为了确保连接成功，请保证以下文件权限正确：</span><br><span class="line"></span><br><span class="line">[root@host .ssh]$ chmod 600 authorized_keys</span><br><span class="line">[root@host .ssh]$ chmod 700 ~/.ssh</span><br></pre></td></tr></table></figure><h2><span id="she-zhi-ssh-da-kai-mi-yao-deng-lu-gong-neng">设置 SSH，打开密钥登录功能</span><a href="#she-zhi-ssh-da-kai-mi-yao-deng-lu-gong-neng" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">编辑 /etc/ssh/sshd_config 文件，进行如下设置：</span><br><span class="line"></span><br><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">另外，请留意 root 用户能否通过 SSH 登录：</span><br><span class="line"></span><br><span class="line">PermitRootLogin yes</span><br><span class="line">当你完成全部设置，并以密钥方式登录成功后，再禁用密码登录：</span><br><span class="line"></span><br><span class="line">PasswordAuthentication no</span><br><span class="line">最后，重启 SSH 服务：</span><br><span class="line"></span><br><span class="line">[root@host .ssh]$ service sshd restart</span><br></pre></td></tr></table></figure><h2><span id="jiang-si-yao-xia-zai-dao-ke-hu-duan-ran-hou-zhuan-huan-wei-putty-neng-shi-yong-de-ge-shi">将私钥下载到客户端，然后转换为 PuTTY 能使用的格式</span><a href="#jiang-si-yao-xia-zai-dao-ke-hu-duan-ran-hou-zhuan-huan-wei-putty-neng-shi-yong-de-ge-shi" class="header-anchor">#</a></h2><p>使用 WinSCP、SFTP 等工具将私钥文件 id_rsa 下载到客户端机器上。然后打开 PuTTYGen，单击 Actions 中的 Load 按钮，载入你刚才下载到的私钥文件。如果你刚才设置了密钥锁码，这时则需要输入。</p><p>载入成功后，PuTTYGen 会显示密钥相关的信息。在 Key comment 中键入对密钥的说明信息，然后单击 Save private key 按钮即可将私钥文件存放为 PuTTY 能使用的格式。</p><p>今后，当你使用 PuTTY 登录时，可以在左侧的 Connection -&gt; SSH -&gt; Auth 中的 Private key file for authentication: 处选择你的私钥文件，然后即可登录了，过程中只需输入密钥锁码即可。</p><h2><span id="ssh-ke-hu-duan-xshell-deng-lu-linux-fu-wu-qi">ssh客户端–xshell登录linux服务器</span><a href="#ssh-ke-hu-duan-xshell-deng-lu-linux-fu-wu-qi" class="header-anchor">#</a></h2><p>将服务器上生成的私钥，id_rsa下载到本地。<br><img src="https://img-blog.csdnimg.cn/8aa2ee35095b499c9cddaf21b877ca01.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/a96ed4029057488f9ee7a6b9acae0fd3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2><span id="ssh-keygen-ming-ling-xiang-jie">ssh-keygen命令详解</span><a href="#ssh-keygen-ming-ling-xiang-jie" class="header-anchor">#</a></h2><p>这条命令目的是为了本地机器ssh登录远程服务器无需输入密码</p><p><strong>1.ssh-keygen</strong></p><blockquote><p>SSH 为 Secure Shell 的缩写，SSH 为建立在应用层基础上的安全协议。SSH<br>是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。<br><br><br>从客户端来看，SSH提供两种级别的安全验证：<br><br><br>第一种级别（基于口令的安全验证）：只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人”这种方式的攻击。<br>    <br><br>第二种级别（基于密匙的安全验证）ssh-keygen：需要依靠密匙，你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。用这种方式，你必须知道自己密匙的口令。但是，与第一种级别相比，第二种级别不需要在网络上传送口令。第二种级别不仅加密所有传送的数据，而且“中间人”这种攻击方式也是不可能的（因为他没有你的私人密匙）。但是整个登录的过程可能需要10秒。<br><br>    ssh-keygen有很多的参数，比如这里的-t -b -C都是他的一些参数</p></blockquote><p><strong>2.-t rsa</strong></p><blockquote><p>-t即指定密钥的类型，密钥的类型有两种，一种是RSA，一种是DSA：<br><br>RSA：RSA加密算法是一种非对称加密算法，是由三个麻省理工的牛人弄出来的，RSA是他们三个人姓的开头首字母组合。<br><br>DSA：Digital Signature Algorithm (DSA)是Schnorr和ElGamal签名算法的变种。<br><br>为了让两个linux机器之间使用ssh不需要用户名和密码。所以采用了数字签名RSA或者DSA来完成这个操作。ssh-keygen默认使用rsa密钥，所以不加-t rsa也行，如果你想生成dsa密钥，就需要加参数-t dsa。</p></blockquote><p><strong>3.-b 4096</strong></p><blockquote><p>-b 指定密钥长度。对于RSA密钥，最小要求768位，默认是2048位。命令中的4096指的是RSA密钥长度为4096位。<br><br>DSA密钥必须恰好是1024位(FIPS 186-2 标准的要求)。</p></blockquote><p><strong>这里额外补充一个知识</strong></p><blockquote><p>命令后面还可以增加-C “注释内容”<br><br>-C表示要提供一个新注释，用于识别这个密钥，可以是任何内容,一个用来识别的key</p></blockquote><p><strong>小结：当你创建ssh的时候：-t 表示密钥的类型 ，-b表示密钥的长度，-C 用于识别这个密钥的注释 ，这个注释你可以输入任何内容</strong></p><h1><span id="centos-qi-dong-ting-zhi-chong-qi-kai-ji-zi-qi-dong-fu-wu">Centos 启动/停止/重启/开机自启动服务</span><a href="#centos-qi-dong-ting-zhi-chong-qi-kai-ji-zi-qi-dong-fu-wu" class="header-anchor">#</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">systemctl start sshd //启动ssh服务</span><br><span class="line"></span><br><span class="line">systemctl stop sshd //停止ssh服务</span><br><span class="line"> </span><br><span class="line">systemctl restart sshd //重启ssh服务</span><br><span class="line"></span><br><span class="line">systemctl enable sshd //开机自启动ssh服务</span><br><span class="line"></span><br><span class="line">docker 和其他服务也适用</span><br></pre></td></tr></table></figure><h1><span id="wen-jian-nei-rong-fu-gai-zhui-jia-nei-rong-cat-ming-ling">文件内容覆盖/追加内容（cat命令）</span><a href="#wen-jian-nei-rong-fu-gai-zhui-jia-nei-rong-cat-ming-ling" class="header-anchor">#</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat  textfile1 &gt; textfile2 //使用“&gt;” 重定向后 文件 中原本的内容会被覆盖</span><br><span class="line"></span><br><span class="line">cat  textfile1 &gt;&gt; textfile2 //&quot;&gt;&gt;&quot; 代表 将输出的内容已追加的方式重定向到文件</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>cat 原单词concatenate(用途是连接文件或标准输入并打印。)<br>cat 命令用于将所有文件内容打印到屏幕上。<br>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 文件</span><br></pre></td></tr></table></figure><h1><span id="linux-zhong-de-amp-amp-he-amp-he">linux中的&amp;&amp; 和 &amp;，| 和 ||</span><a href="#linux-zhong-de-amp-amp-he-amp-he" class="header-anchor">#</a></h1><blockquote><p>在linux中，&amp;和&amp;&amp;,|和||介绍如下：<br><br><br>&amp;  表示任务在后台执行，如要在后台运行redis-server,则有  redis-server &amp;<br><br><br>&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令 ，如 echo ‘1‘ &amp;&amp; echo ‘2’<br><br><br>| 表示管道，上一条命令的输出，作为下一条命令参数，如 echo ‘yes’ | wc -l<br><br><br>|| 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo “fail”</p></blockquote><p>具体案例：<br>1.rpm -qa | grep mysql</p><blockquote><p>rpm -qa会输出符合筛选条件的软件套件，然后使用grep 筛选与mysql相关的软件套件</p></blockquote><h1><span id="rpm-ming-ling">rpm命令</span><a href="#rpm-ming-ling" class="header-anchor">#</a></h1><blockquote><p>Linux rpm 命令用于管理套件。<br><br><br>rpm（英文全拼：redhat package manager） 原本是 Red Hat Linux 发行版专门用来管理 Linux<br>各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux<br>易于安装，升级，间接提升了 Linux 的适用度。<br><br>因为是redhat的，所以这个命令对ubuntu不适用，一般就是centos用，看看是否安装了或有某个软件的套件</p></blockquote><p>实例：</p><p>1.安装软件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># rpm -hvi dejagnu-1.4.2-10.noarch.rpm </span><br><span class="line">警告：dejagnu-1.4.2-10.noarch.rpm: V3 DSA 签名：NOKEY, key ID db42a60e</span><br><span class="line">准备...           </span><br><span class="line">########################################### [100%]</span><br></pre></td></tr></table></figure><p>2.显示软件安装信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># rpm -qi dejagnu-1.4.2-10.noarch.rpm</span><br><span class="line"></span><br><span class="line">【第1次更新 教程、类似命令关联】</span><br></pre></td></tr></table></figure><p>3.检查是否已经安装过mysql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br></pre></td></tr></table></figure><p>4.删除mysql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps mysql-libs-5.1.73-5.el6_6.x86_64  </span><br><span class="line">//-e&lt;套件档&gt;或--erase&lt;套件档&gt; 　删除指定的套件。</span><br><span class="line">//--nodeps 　不验证套件档的相互关联性。</span><br></pre></td></tr></table></figure><h1><span id="cha-kan-xi-tong-ban-ben">查看系统版本</span><a href="#cha-kan-xi-tong-ban-ben" class="header-anchor">#</a></h1><h2><span id="centos">centos</span><a href="#centos" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br></pre></td></tr></table></figure><h1><span id="geng-huan-yum-yuan">更换yum源</span><a href="#geng-huan-yum-yuan" class="header-anchor">#</a></h1><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/centos/">更换为清华源</a></p><ol><li>建议先备份 /etc/yum.repos.d/ 内的文件（CentOS 7 及之前为 CentOS-Base.repo，CentOS 8 为CentOS-Linux-*.repo）</li><li>然后编辑 /etc/yum.repos.d/ 中的相应文件，在 mirrorlist= 开头行前面加 # 注释掉；并将 baseurl= 开头行取消注释（如果被注释的话），把该行内的域名（例如mirror.centos.org）替换为 mirrors.tuna.tsinghua.edu.cn。</li><li>以上步骤可以被下方的命令一步完成</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -e &#x27;s|^mirrorlist=|#mirrorlist=|g&#x27; \</span><br><span class="line">        -e &#x27;s|^#baseurl=http://mirror.centos.org|baseurl=https://mirrors.tuna.tsinghua.edu.cn|g&#x27; \</span><br><span class="line">        -i.bak \</span><br><span class="line">        /etc/yum.repos.d/CentOS-*.repo</span><br></pre></td></tr></table></figure><blockquote><p>注意其中的*通配符，如果只需要替换一些文件中的源，请自行增删。<br><br><br>注意，如果需要启用其中一些 repo，需要将其中的 enabled=0 改为 enabled=1。<br><br></p></blockquote><p>4.最后，更新软件包缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum makecache</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;fu-zhi-yi-dong-wen-jian-wen-jian-gai-ming&quot;&gt;复制/移动文件、文件改名&lt;/span&gt;&lt;a href=&quot;#fu-zhi-yi-dong-wen-jian-wen-jian-gai-ming&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="运维" scheme="http://example.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Linux Shell 命令</title>
    <link href="http://example.com/2022/01/15/Shell%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/01/15/Shell%E5%91%BD%E4%BB%A4/</id>
    <published>2022-01-15T07:49:30.400Z</published>
    <updated>2022-01-19T07:29:25.470Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="shi-ji-ming-ling-fen-xi">实际命令分析</span><a href="#shi-ji-ming-ling-fen-xi" class="header-anchor">#</a></h1><h2><span id="git-log-follow-pretty-format-h-wen-jian-ming-xargs-i-sh-c-git-show-wen-jian-ming-gt-wen-jian-ming">git log –follow –pretty=format:%H 文件名 | xargs -I{} sh -c ‘git show {}:文件名 &gt; 文件名.{}’</span><a href="#git-log-follow-pretty-format-h-wen-jian-ming-xargs-i-sh-c-git-show-wen-jian-ming-gt-wen-jian-ming" class="header-anchor">#</a></h2><p>提取git中某个文件的所有版本并按顺序命名:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --follow --pretty=format:%H 文件名 | xargs -I&#123;&#125; sh -c &#x27;git show &#123;&#125;:文件名 &gt; 文件名.&#123;&#125;&#x27;</span><br></pre></td></tr></table></figure><p>简略解释版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">git log --follow --pretty=format:%H </span><br><span class="line">//按照一定的格式输出 ，--pretty=format:%H 输出某个文件的历史提交哈希值。</span><br><span class="line">//如果不加--pretty=format:%H，会输出哈希值，作者，时间等信息。</span><br><span class="line">//--pretty=format后面还可以跟其它值，</span><br><span class="line">//&#x27;%H&#x27;: commit hash</span><br><span class="line">//&#x27;%h&#x27;:abbreviated commit hash</span><br><span class="line">//&#x27;%T&#x27;: tree hash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| xargs -I&#123;&#125; </span><br><span class="line"></span><br><span class="line">//xargs 一般是和管道(I)一起使用</span><br><span class="line"> //-I&#123;&#125; //xargs 的一个选项 -I，使用 -I 指定一个替换字符串 &#123;&#125;，这个字符串在 xargs 扩展时会被替换掉；对应这里，前面输出的是哈希值，这里面&quot;&#123;&#125;&quot;代表的就是哈希值，后面的&quot;&#123;&#125;&quot;也是前面的哈希值。</span><br><span class="line"></span><br><span class="line">sh -c </span><br><span class="line">//暂时不清，下面有解释</span><br><span class="line"></span><br><span class="line">git show &#123;&#125;:文件名 &gt; 文件名.&#123;&#125; </span><br><span class="line"> //git show &#x27;哈希值&#x27;:文件名：输出这次提交，这个文件夹的内容， &quot;&gt;&quot; 将内容输出到 后面的文件中，并覆盖后面文件内容。</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>| xargs -I{} sh c</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|  //表示管道，上一条命令的输出，作为下一条命令参数，如 echo ‘yes’ | wc -l</span><br><span class="line"></span><br><span class="line">xargs -I //</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sh -c</span><br><span class="line"></span><br><span class="line">Linux使用 echo 并配合命令重定向是实现向文件中写入信息的快捷方式。</span><br><span class="line">【新建空文件】</span><br><span class="line">方式一 : $ touch test.sh</span><br><span class="line">方式二 : $ echo “” &gt; test.sh</span><br><span class="line">【写内容到文件】</span><br><span class="line">如 test.sh 文件中内容：</span><br><span class="line">$ echo “信息” &gt; test.sh</span><br><span class="line"></span><br><span class="line">但有时会出现权限不够的问题，这时就可以使用 sh -c</span><br><span class="line"></span><br><span class="line">利用 “sh -c” 命令，它可以让 bash 将一个字串作为完整的命令来执行，这样就可以将 sudo 的影响范围扩展到整条命令。具体用法如下：</span><br><span class="line">$ sudo sh -c ‘echo “第二条内容” &gt;&gt; test.sh’</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="git-branch-r-xargs-d-n1-grep-v-origin-xargs-i-sh-c-mkdir-c-users-76585-desktop-try">git branch -r | xargs -d/ -n1 | grep -v ‘origin’ | xargs -I{} sh -c ‘mkdir “C:\Users\76585\Desktop\try{}” ‘</span><a href="#git-branch-r-xargs-d-n1-grep-v-origin-xargs-i-sh-c-mkdir-c-users-76585-desktop-try" class="header-anchor">#</a></h2><blockquote><p>用途：给每一个远程分支建立单独的文件夹，文件名就是分支名</p></blockquote><p>分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.  git branch -r //显示远程分支。注意，本地分支可能只有一个，master这种。但远程分支可能有很多个。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. | xargs -d/ -n1 // -d -n都是xargs的参数，详细可以去查文档。-d/  以&quot;/&quot;为分隔符；-n1，每行输出一个。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. grep -v &#x27;origin&#x27; // 遇到origin就不显示（删除这个字符串）。</span><br></pre></td></tr></table></figure><p>冷知识：在Windows下运行sh文件，在当前路径下，<code>./</code>;<br>如果是非当前路径，<code>c/xx/xxx/1.sh  //绝对路径到sh文件就好，前面不用加./</code> </p><h2><span id="an-ti-jiao-xin-xi-lai-guo-lu-ti-jiao-grep">按提交信息来过滤提交 –grep</span><a href="#an-ti-jiao-xin-xi-lai-guo-lu-ti-jiao-grep" class="header-anchor">#</a></h2><p>按提交信息来过滤提交，你可以使用–grep标记。它和上面的–author标记差不多，只不过它搜索的是提交信息而不是作者。</p><p>背景：提取主干某文件的提交，因为主干都是其它author合并上去的，所有没有主干这个author，无法使用–author这个参数来过滤。但是每次合并到主干的commit 都有一句 “into avtivebranch”，根据这一句筛选即可。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log --grep=&quot;JRA-224:&quot; </span><br><span class="line">//也可以传入-i参数来忽略大小写匹配</span><br></pre></td></tr></table></figure><h1><span id="dai-ma-fen-xi">代码分析</span><a href="#dai-ma-fen-xi" class="header-anchor">#</a></h1><h2><span id="du-qu-wen-jian-jia-zhong-de-wen-jian-ming-bing-cun-ru-lie-biao">读取文件夹中的文件名，并存入列表</span><a href="#du-qu-wen-jian-jia-zhong-de-wen-jian-ming-bing-cun-ru-lie-biao" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#读取文件夹中的文件名，并存入列表</span><br><span class="line"></span><br><span class="line">i=0</span><br><span class="line">for dir in $(ls &#x27;C:\Users\76585\Desktop\cfdname1&#x27;)</span><br><span class="line">do</span><br><span class="line">    </span><br><span class="line">    # echo $dir &gt;&gt; arr[$i]</span><br><span class="line">    arr[$i]=$dir</span><br><span class="line">    i=$(($i+1))</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;$&#123;arr[@]&#125;&quot;</span><br></pre></td></tr></table></figure><p><strong>注意的点：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.for 循环循环体只能卸载do done之间，之前把 i 写在了for 和 do之间报错</span><br><span class="line"></span><br><span class="line">2.变量初始化不要放在函数体，不然每次循环都清 0 了。</span><br><span class="line"></span><br><span class="line">3.变量自增加方法：</span><br><span class="line">a=\$(($a+1))</span><br><span class="line"></span><br><span class="line">a=$[$a+1]</span><br><span class="line"></span><br><span class="line">a=\`expr $a + 1`</span><br><span class="line"></span><br><span class="line">let a++</span><br><span class="line"></span><br><span class="line">let a+=1</span><br><span class="line"></span><br><span class="line">((a++))</span><br><span class="line"></span><br><span class="line">4.打印数组的方法：$&#123;my_array[*]&#125; 或者 $&#123;my_array[@]&#125;</span><br></pre></td></tr></table></figure><h1><span id="bian-liang">变量</span><a href="#bian-liang" class="header-anchor">#</a></h1><h2><span id="huo-qu-bian-liang-zi-fu-chuan-chang-du">获取变量字符串长度</span><a href="#huo-qu-bian-liang-zi-fu-chuan-chang-du" class="header-anchor">#</a></h2><p>想要知道 “<a href="http://www.baidu.com&quot;/">www.baidu.com&quot;</a> 的变量net的长度十分简单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ net=&quot;www.baidu.com&quot;</span><br><span class="line">[Neptuneyt]$ echo $&#123;#net&#125;</span><br><span class="line">13</span><br></pre></td></tr></table></figure><p>当然，在Shell中获取字符串变量的长度的方法有许多种，但是下图法一作为一种系统内建的方法是最快的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ echo $&#123;#net&#125;</span><br><span class="line">13</span><br><span class="line">[Neptuneyt]$ echo $&#123;net&#125;|wc -L</span><br><span class="line">13</span><br><span class="line">[Neptuneyt]$ expr length $&#123;net&#125;</span><br><span class="line">13</span><br><span class="line">[Neptuneyt]$ echo $&#123;net&#125;|awk &#x27;&#123;print length($0)&#125;&#x27;</span><br><span class="line">13</span><br></pre></td></tr></table></figure><h2><span id="bian-liang-jie-qu">变量截取</span><a href="#bian-liang-jie-qu" class="header-anchor">#</a></h2><p><strong>指定位置截取字符串</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ net=&quot;www.baidu.com&quot;</span><br><span class="line">[Neptuneyt]$ # 从第4个字符截取到baidu</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:4:5&#125; #从第4个字符.开始截取5个字符</span><br><span class="line">baidu</span><br><span class="line">[Neptuneyt]$ # 截取baidu.com</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:4&#125;   #起始位置后不接截取字符长度则默认截取之后所有的</span><br><span class="line">baidu.com</span><br><span class="line">[Neptuneyt]$ # 用倒数截取com</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:0-3&#125; #从倒数第三个字符截取到末尾</span><br><span class="line">com</span><br><span class="line">[Neptuneyt]$ echo $&#123;net: -3&#125; #另外的写法，一定要注意冒号和-3之间有空格</span><br><span class="line">com</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:-3&#125;  #不加空格，截取失败</span><br><span class="line">www.baidu.com</span><br></pre></td></tr></table></figure><p><strong>匹配字符串截取</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ echo $net</span><br><span class="line">www.baidu.com</span><br><span class="line"></span><br><span class="line"># 删除匹配字符串的左边，留下剩余部分</span><br><span class="line">[Neptuneyt]$ echo $&#123;net#*.&#125; #这里用*.表示匹配到www.，用一个#表示删除匹配到的字符串，留下剩余的部分</span><br><span class="line">baidu.com</span><br><span class="line"></span><br><span class="line"># 用2个#号表示尽可能多的删除匹配到的字符串</span><br><span class="line">[Neptuneyt]$ echo $&#123;net##*.&#125;</span><br><span class="line">com</span><br><span class="line"></span><br><span class="line"># 同理也可以匹配字符串的右边，留下剩余部分</span><br><span class="line">[Neptuneyt]$ echo $&#123;net%.*&#125; #用.*匹配到.com,用%删除</span><br><span class="line">www.baidu</span><br><span class="line"></span><br><span class="line"># 用2个%号表示尽可能多的删除匹配到的字符串</span><br><span class="line">[Neptuneyt]$ echo $&#123;net%%.*&#125;    #因为2个%，这里.*表示匹配到最长的.baidu.com</span><br></pre></td></tr></table></figure><p>总的来说:<br><code>#*chr</code>表示删除从左到右第一个遇到的字符chr及其左侧的字符<br><code>##*chr</code>表示删除从左到右最后一个遇到的字符chr及其左侧的字符（贪婪模式）<br><code>%chr*</code>表示删除从右向左第一个遇到的字符chr及其右侧的字符<br><code>%%chr*</code>表示删除从右到左最后一个遇到的字符chr及其右侧的字符（贪婪模式）<br>在键盘上，#在$符的左边，%号在$符的右边，为了便于记忆，大家因此可以记住#删除左边字符，%删除右边字符</p><h2><span id="bian-liang-de-zi-fu-chuan-ti-huan">变量的字符串替换</span><a href="#bian-liang-de-zi-fu-chuan-ti-huan" class="header-anchor">#</a></h2><p>想要将net的 baidu替换成google怎么写呢？只需<code>$&#123;net/baidu/google&#125;</code>即可，需要注意的是原变量并未修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ echo $&#123;net/baidu/google&#125; #/匹配字符/替换字符</span><br><span class="line">www.google.com</span><br><span class="line">[Neptuneyt]$ echo $net  #原变量并未修改</span><br><span class="line">www.baidu.com</span><br></pre></td></tr></table></figure><p>如果是替换所有匹配到的字符，应该通过<code>$&#123;variable//pattern/sub&#125;</code><br>例如将net的.替换为-或/：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ echo $&#123;net//./-&#125;</span><br><span class="line">www-baidu-com</span><br><span class="line">[Neptuneyt]$ echo $&#123;net//.//&#125;</span><br><span class="line">www/baidu/com</span><br></pre></td></tr></table></figure><p>除此之外，还有两种专门针对字符串开头和结尾的替换方式<br>只替换开头匹配的字符串<code>$&#123;variable/#pattern/sub&#125;</code><br>只替换结尾匹配的字符串<code>$&#123;variable/%pattern/sub&#125;</code><br>例如对于<code>add=www.xiaomi.com.www</code>的开头或者结尾的<code>www</code>替换为<code>-</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ add=www.xiaomi.com.www</span><br><span class="line">[Neptuneyt]$ echo $&#123;add/#www/-&#125;</span><br><span class="line">-.xiaomi.com.www</span><br><span class="line">[Neptuneyt]$ echo $&#123;add/%www/-&#125;</span><br><span class="line">www.xiaomi.com.-</span><br></pre></td></tr></table></figure><h2><span id="shan-chu-zi-fu-chuan">删除字符串</span><a href="#shan-chu-zi-fu-chuan" class="header-anchor">#</a></h2><p>其实学会了替换字符串删除字符串就更简单了，只需将替换部分写成空即可，即<code>$&#123;variable/pattern/null&#125;</code>，例如将net的第一个.删除，只需</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ echo $&#123;net/./&#125;</span><br><span class="line">wwwbaidu.com</span><br><span class="line">[Neptuneyt]$ echo $&#123;net/.&#125;  #最后一个/可以不用写</span><br><span class="line">wwwbaidu.com</span><br></pre></td></tr></table></figure><p>若要删除所有匹配到的只需即<code>$&#123;variable//pattern&#125;</code>，例如将<code>net</code>的.都删除，只需</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ echo $&#123;net//.&#125;</span><br><span class="line">wwwbaiducom</span><br></pre></td></tr></table></figure><h2><span id="bian-liang-wei-kong-shi-fu-mo-ren-zhi">变量为空时赋默认值</span><a href="#bian-liang-wei-kong-shi-fu-mo-ren-zhi" class="header-anchor">#</a></h2><p>当我们在写脚本时往往需要给脚本传递一些参数，在Shell中传递参数十分简单，只需利用特殊的位置参数变量诸如<code>$1,$2,$3...$&#123;10&#125;...</code>即可，例如，以下脚本传递2个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># PassArgument.sh</span><br><span class="line">#!/bin/env bash</span><br><span class="line"># pass 2 arguments</span><br><span class="line">arg1=$1</span><br><span class="line">arg2=$2</span><br><span class="line">echo $arg1 $arg2</span><br><span class="line"></span><br><span class="line">[Neptuneyt]$ bash PassArgument.sh Hello word #参数以空格隔开</span><br><span class="line">Hello word</span><br></pre></td></tr></table></figure><p>有时候，我们想省掉最后一个参数，让它使用默认值，这个时候只需通过<code>$&#123;variable:=&#39;default value&#39;&#125;</code>即可，即当变量有值的时候则使用原值，若没有值则使用括号中默认定义好的值。例如，如下脚本表示当第二个参数为空时默认使用定义好的值“word”,否则是用户自己传递的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># PassArgument.sh</span><br><span class="line">#!/bin/env bash</span><br><span class="line">arg1=$1</span><br><span class="line">arg2=$2</span><br><span class="line">echo $arg1 $&#123;arg2:=&#x27;word&#x27;&#125;  #第二个参数设置默认值</span><br><span class="line"></span><br><span class="line">[Neptuneyt]$ bash PassArgument.sh Hello #第二个参数为空时使用默认值</span><br><span class="line">Hello word</span><br><span class="line">[Neptuneyt]$ bash PassArgument.sh Hello Shell   #第二个参数不为空时使用参数传递的值</span><br><span class="line">Hello Shell</span><br></pre></td></tr></table></figure><p>除了<code>$&#123;variable:=&#39;default value&#39;&#125;</code>外，还有<code>$&#123;variable:-&#39;default value&#39;&#125;</code>,<code>$&#123;variable:+&#39;default value&#39;&#125;</code>和<code>$&#123;variable:？&#39;default value&#39;&#125;</code>，它们有什么区别呢？<br>对于<code>$&#123;variable:=&#39;default value&#39;&#125;</code>，表示变量为空时把默认值赋值给该变量，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ net=</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:=&#x27;www.baidu.com&#x27;&#125;</span><br><span class="line">www.baidu.com</span><br><span class="line">[Neptuneyt]$ echo $net</span><br><span class="line">www.baidu.com</span><br></pre></td></tr></table></figure><p>对于<code>$&#123;variable:-&#39;default value&#39;&#125;</code>,表示变量为空时返回默认值<strong>但是并不把默认值赋值给该变量</strong>， 例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ net=</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:-&#x27;www.baidu.com&#x27;&#125;</span><br><span class="line">www.baidu.com</span><br><span class="line">[Neptuneyt]$ echo $net  #此时，变量依旧为空</span><br></pre></td></tr></table></figure><p>对于<code>$&#123;variable:+&#39;default value&#39;&#125;</code>,则表示变量不为空时，返回默认值，并且也不重新赋值，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ net=www.baidu.com</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:+&#x27;www.google.com&#x27;&#125;</span><br><span class="line">www.google.com</span><br><span class="line">[Neptuneyt]$ echo $net  #不改变变量原值</span><br><span class="line">www.baidu.com</span><br></pre></td></tr></table></figure><p>最后，对于<code>$&#123;variable:？&#39;default value&#39;&#125;</code>,则表示当变量为空时，使用bash风格的报错，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Neptuneyt]$ net=</span><br><span class="line">[Neptuneyt]$ echo $&#123;net:?&#x27;error:null value&#x27;&#125;</span><br><span class="line">-bash: net: error:null value</span><br></pre></td></tr></table></figure><h2><span id="zi-fu-chuan-pin-jie">字符串拼接</span><a href="#zi-fu-chuan-pin-jie" class="header-anchor">#</a></h2><p>在 PHP 中，使用.即可连接两个字符串；<br>在 JavaScript 中，使用+即可将两个字符串合并为一个。<br>在 Shell 中你不需要使用任何运算符，将两个字符串并排放在一起就能实现拼接，非常简单粗暴。请看下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">name=&quot;Shell&quot;</span><br><span class="line">url=&quot;http://c.biancheng.net/shell/&quot;</span><br><span class="line">str1=$name$url  #中间不能有空格</span><br><span class="line">str2=&quot;$name $url&quot;  #如果被双引号包围，那么中间可以有空格</span><br><span class="line">str3=$name&quot;: &quot;$url  #中间可以出现别的字符串</span><br><span class="line">str4=&quot;$name: $url&quot;  #这样写也可以</span><br><span class="line">str5=&quot;$&#123;name&#125;Script: $&#123;url&#125;index.html&quot;  #这个时候需要给变量名加上大括号</span><br><span class="line">echo $str1</span><br><span class="line">echo $str2</span><br><span class="line">echo $str3</span><br><span class="line">echo $str4</span><br><span class="line">echo $str5</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">Shellhttp://c.biancheng.net/shell/</span><br><span class="line">Shell http://c.biancheng.net/shell/</span><br><span class="line">Shell: http://c.biancheng.net/shell/</span><br><span class="line">Shell: http://c.biancheng.net/shell/</span><br><span class="line">ShellScript: http://c.biancheng.net/shell/index.html</span><br></pre></td></tr></table></figure><p>对于第 7 行代码，$name 和 $url 之间之所以不能出现空格，是因为当字符串不被任何一种引号包围时，遇到空格就认为字符串结束了，空格后边的内容会作为其他变量或者命令解析，这一点在《Shell字符串》中已经提到。</p><p>对于第 10 行代码，加{ }是为了帮助解释器识别变量的边界，这一点在《Shell变量》中已经提到。</p><h2><span id="dan-yin-hao-nei-yin-ru-bian-liang">单引号内引入变量</span><a href="#dan-yin-hao-nei-yin-ru-bian-liang" class="header-anchor">#</a></h2><p><strong>方法：单引号内嵌套单引号即可使用变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">i=10</span><br><span class="line">echo $i</span><br><span class="line">echo &#x27;$i&#x27;</span><br><span class="line">echo &#x27;$i is : &#x27;$i&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">执行结果</span><br><span class="line"></span><br><span class="line"># ./test.sh </span><br><span class="line">10</span><br><span class="line">$i</span><br><span class="line">$i is : 10</span><br></pre></td></tr></table></figure><h2><span id="shell-zhong-pan-duan-liang-ge-zi-fu-chuan-xiang-deng">shell中判断两个字符串相等</span><a href="#shell-zhong-pan-duan-liang-ge-zi-fu-chuan-xiang-deng" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line"></span><br><span class="line">read -p &quot;If you want to clean the trash?(y/n):&quot; select</span><br><span class="line">str=y</span><br><span class="line"></span><br><span class="line">if [ &quot;$select&quot; = &quot;y&quot; ]</span><br><span class="line">then</span><br><span class="line">    rm -fr $HOME/.local/share/Trash/files/*</span><br><span class="line">    echo &quot;Deleted successfully!&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;Undelete!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><strong>注意的几点：</strong><br><strong>1、if和[ ]之间要空格。</strong></p><p><strong>2、[ ]和“ ”之间要空格</strong></p><p><strong>3、“ ”和=之间要空格，</strong></p><h2><span id="shi-zhan-tong-ji-wen-zhang-dan-ci-qing-kuang">实战：统计文章单词情况</span><a href="#shi-zhan-tong-ji-wen-zhang-dan-ci-qing-kuang" class="header-anchor">#</a></h2><p>这里想要统计Martin Luther King在1963年著名的<strong>I have a dream</strong>演讲中都使用了哪些词，哪些是高频词，单词字长如何。<br><img src="https://img-blog.csdnimg.cn/4f3976bb28594f89ab73d74c1d5b4448.png" alt="在这里插入图片描述"><br>思路：<br>高频词统计：将所有单词单行输出，删除空行，删除<code>,./?</code>等非字母符号，用sort排序后使用uniq统计即可。<br>字长频数统计：将所有单词单行输出，删除空行，删除<code>,./?</code>等非字母符号，使用while循环遍历每个单词，使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#variable&#125; //统计单词长读频数。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 高频词统计</span><br><span class="line">echo &quot;高频词统计：&quot;</span><br><span class="line">echo &quot;频数&quot; &quot;单词&quot;</span><br><span class="line">tr &quot; &quot; &quot;\n&quot; &lt;IHaveADream.txt | \</span><br><span class="line">#使用tr将空格转换成换行符，使得每行一个单词，\续行符表示一行命令未写完可换行书写，切记其后什么字符也不能接，包括空格和注释</span><br><span class="line">sed -e &quot;/[^a-Z]/d;/^$/d&quot; | \</span><br><span class="line">#使用sed匹配非字母字符和空行并删除：-e 表示执行多个操作； /[^a-Z]/，双斜线//表示匹配部分，^表示匹配除开后面a-Z的所有字符，d表示对前面匹配部分删除；/^$/表示匹配空行，^、$分别表示行首和行尾</span><br><span class="line">sort |uniq -c |    \</span><br><span class="line">#排序之后使用uniq统计，-c表示统计单词出现的次数</span><br><span class="line">sort -nr | column -t|head #将次数最多的单词排在前面，-n表示按数值排序，-r从大到小倒序排，column -t表格式输出</span><br><span class="line"></span><br><span class="line"># 字长频数统计</span><br><span class="line">echo</span><br><span class="line">echo &quot;字长频数统计：&quot;</span><br><span class="line">echo &quot;频数&quot; &quot;单词长度&quot;</span><br><span class="line">tr &quot; &quot; &quot;\n&quot; &lt;IHaveADream.txt | \</span><br><span class="line">sed -e &quot;/[^a-Z]/d;/^$/d&quot; | \</span><br><span class="line">while read word</span><br><span class="line">do</span><br><span class="line">  echo $&#123;#word&#125;</span><br><span class="line">done |\</span><br><span class="line"># 用while和read每次读入一个单词，使用$&#123;#word&#125;统计单词长度</span><br><span class="line">sort |uniq -c|sort -nr|column -t|head</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/bf86067e7f744920971af70e7249ade9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;shi-ji-ming-ling-fen-xi&quot;&gt;实际命令分析&lt;/span&gt;&lt;a href=&quot;#shi-ji-ming-ling-fen-xi&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;git-log</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="运维" scheme="http://example.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins知识点</title>
    <link href="http://example.com/2022/01/14/Jenkins%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://example.com/2022/01/14/Jenkins%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-01-13T16:00:00.000Z</published>
    <updated>2022-01-16T14:48:12.321Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="liu-shui-xian-yu-fa-zhao-bu-dao-mo-ban">流水线语法找不到模板</span><a href="#liu-shui-xian-yu-fa-zhao-bu-dao-mo-ban" class="header-anchor">#</a></h1><p><img src="https://img-blog.csdnimg.cn/e93ad73b8c094398bdfc1b49f5388317.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>有时候在“流水线语言”板块找不到模板，即使安装了相对于的插件。如上图，安装了<strong>publish over ssh插件</strong>就会出现这个选项，但是当时没有。</p><p><strong>解决办法：</strong><br>重启jenkins。初始域名后面加/restart</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip:port/restart</span><br></pre></td></tr></table></figure><h1><span id="publish-over-ssh-lian-jie-shi-bai">Publish over ssh连接失败</span><a href="#publish-over-ssh-lian-jie-shi-bai" class="header-anchor">#</a></h1><p><img src="https://img-blog.csdnimg.cn/72c9e5709ded45fcadfc75afc94e0baf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>解决办法：</strong><br>这里要填密钥的密码</p><h1><span id="wu-fa-zhi-xing-yuan-cheng-jiao-ben">无法执行远程脚本</span><a href="#wu-fa-zhi-xing-yuan-cheng-jiao-ben" class="header-anchor">#</a></h1><blockquote><p>背景：<br>创建一个jenkins作业，通过ssh在另一台服务器上运行脚本，实现从harbor仓库拉取docker镜像，并运行。<br><br><br>问题： 运行jenkins作业/流水线，在对应的服务器没有镜像和运行的容器，且构建过程没有错误输出。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/833850a8163b42f79d14e14b9551c356.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>分析：<br>由于是照着黑马程序员的视频和资料来的，由于输出的信息不太一样，以为是哪里操作有问题，或者脚本不对，但是重复所有过程和按照网上教程修改脚本均没有成功。然后单独运行脚本，发现出错，类似于下图。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/635aed74d26a41bc84833f34bef37f50.png" alt="在这里插入图片描述"></p><blockquote><p><strong>反应过来是因为Docker没有把Harbor加入信任列表中</strong>，</p><p><br> 加入就好</p><p><code>vim /etc/docker/daemon.json </code></p><p><br> 再次构建出现了错误信息，搜索得知是因为这个命令默认有个时间限制，超过这个时间限制就会出错，断开，类似于联网超时。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/cf2801f8c63a42bb8e91adf61a3f8590.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p><strong>把时间改为0就好</strong></p></blockquote><p><img src="https://img-blog.csdnimg.cn/30e99ed138474b01800e583e61389dfd.png" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;liu-shui-xian-yu-fa-zhao-bu-dao-mo-ban&quot;&gt;流水线语法找不到模板&lt;/span&gt;&lt;a href=&quot;#liu-shui-xian-yu-fa-zhao-bu-dao-mo-ban&quot; class=&quot;header-ancho</summary>
      
    
    
    
    <category term="Jenkins" scheme="http://example.com/categories/Jenkins/"/>
    
    
    <category term="运维" scheme="http://example.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Jenkins" scheme="http://example.com/tags/Jenkins/"/>
    
    <category term="持续集成" scheme="http://example.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>零散知识</title>
    <link href="http://example.com/2022/01/14/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2022/01/14/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/</id>
    <published>2022-01-13T16:00:00.000Z</published>
    <updated>2022-01-16T14:48:27.186Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="windows-chong-qi-da-yin-ji-fu-wu">Windows重启打印机服务</span><a href="#windows-chong-qi-da-yin-ji-fu-wu" class="header-anchor">#</a></h1><p>有时候需要重启打印机，采用命令行的方式。</p><blockquote><p>Win+R ：services.msc  找到 Print Spooler 重启。</p></blockquote><h1><span id="win10-kai-ji-zi-qi-dong-ruan-jian">Win10开机自启动软件</span><a href="#win10-kai-ji-zi-qi-dong-ruan-jian" class="header-anchor">#</a></h1><p>把该应用程序的快捷方式放到“系统启动文件夹”里；</p><blockquote><p>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</p></blockquote><h1><span id="mo-hu-zhao-pian-bian-gao-qing">模糊照片变高清</span><a href="#mo-hu-zhao-pian-bian-gao-qing" class="header-anchor">#</a></h1><p>访问 </p><blockquote><p>bigjpg.com</p></blockquote><p>将照片扔上去就好。</p><h1><span id="win10-cha-kan-dian-nao-pei-zhi-xin-xi-he-xing-hao">Win10查看电脑配置信息和型号</span><a href="#win10-cha-kan-dian-nao-pei-zhi-xin-xi-he-xing-hao" class="header-anchor">#</a></h1><h2><span id="shi-yong-dxdiag-ming-ling-jian-cha-dian-nao-pei-zhi">使用dxdiag命令检查电脑配置</span><a href="#shi-yong-dxdiag-ming-ling-jian-cha-dian-nao-pei-zhi" class="header-anchor">#</a></h2><p> 按下键盘上的Win+R组合键，打开运行窗口，输入dxdiag，点击确定。<br> <img src="https://img-blog.csdnimg.cn/7ac995ab180c4465968809c73ea881cd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在打开的页面中就可以看到当前计算机名称、操作系统、CPU、内存等重要信息。</p><h2><span id="shi-yong-diskmtgt-msc-ming-ling-jin-ru-ci-pan-guan-li-cha-kan-ying-pan-da-xiao-ji-yi-shi-yong-de-kong-jian">使用diskmtgt.msc命令进入磁盘管理，查看硬盘大小及已使用的空间。</span><a href="#shi-yong-diskmtgt-msc-ming-ling-jin-ru-ci-pan-guan-li-cha-kan-ying-pan-da-xiao-ji-yi-shi-yong-de-kong-jian" class="header-anchor">#</a></h2><p><img src="https://img-blog.csdnimg.cn/b507309c987f41898b08f797c24c7f4c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>465.76GB就是500G的硬盘，不要怀疑是不是奸商给你的是假货，这是没有问题的，硬盘的生产厂家在生产硬盘时用的是1000进制，即1GB=1000MB；1MB=1000KB；1KB=1000B。而电脑的计算进制是1024，即1G=1024MB；1MB=1024KB；1kB=1024B，这样就会造成电脑检测出来的容量比标称容量小。</p><p>  此外，除了以上方法也可以进入设备管理器里查看电脑配置信息，步骤：右击桌面上的“计算机”–&gt;“设备管理器”，在设备管理器中就可以看见电脑配置情况了</p><p><img src="https://img-blog.csdnimg.cn/a53bf33bf4894fb7b610d2cf291071d0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;windows-chong-qi-da-yin-ji-fu-wu&quot;&gt;Windows重启打印机服务&lt;/span&gt;&lt;a href=&quot;#windows-chong-qi-da-yin-ji-fu-wu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;</summary>
      
    
    
    
    <category term="小知识" scheme="http://example.com/categories/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="IDE" scheme="http://example.com/tags/IDE/"/>
    
    <category term="编辑器" scheme="http://example.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    <category term="小知识" scheme="http://example.com/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>git操作</title>
    <link href="http://example.com/2022/01/14/git%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2022/01/14/git%E6%93%8D%E4%BD%9C/</id>
    <published>2022-01-13T16:00:00.000Z</published>
    <updated>2022-01-17T07:21:54.397Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="config-xiang-guan-ming-ling">config相关命令</span><a href="#config-xiang-guan-ming-ling" class="header-anchor">#</a></h1><h2><span id="cha-kan-pei-zhi-xin-xi">查看配置信息</span><a href="#cha-kan-pei-zhi-xin-xi" class="header-anchor">#</a></h2><ol><li>查看系统config</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system --list</span><br></pre></td></tr></table></figure><ol start="2"><li>查看当前用户（global）配置</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global  --list</span><br></pre></td></tr></table></figure><ol start="3"><li>查看当前仓库配置信息</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -- local    --list</span><br></pre></td></tr></table></figure><h2><span id="she-zhi-xiu-gai-pei-zhi-xin-xi">设置/修改配置信息</span><a href="#she-zhi-xiu-gai-pei-zhi-xin-xi" class="header-anchor">#</a></h2><p>设置用户名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;github用户名&quot;</span><br></pre></td></tr></table></figure><p>设置邮箱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;github注册邮箱&quot;</span><br></pre></td></tr></table></figure><h1><span id="cha-kan-ti-jiao-ji-lu">查看提交记录</span><a href="#cha-kan-ti-jiao-ji-lu" class="header-anchor">#</a></h1><h2><span id="cha-kan-zhi-ding-wen-jian-de-li-shi-ti-jiao-ji-lu">查看指定文件的历史提交记录</span><a href="#cha-kan-zhi-ding-wen-jian-de-li-shi-ti-jiao-ji-lu" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -- &lt;file&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/b1dc02f3dc8d4c888f7d98443524a64f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2><span id="cha-kan-mei-ci-ti-jiao-de-nei-rong-chai-yi">查看每次提交的内容差异</span><a href="#cha-kan-mei-ci-ti-jiao-de-nei-rong-chai-yi" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p -2 -- &lt;file&gt;</span><br></pre></td></tr></table></figure><blockquote><p>参数：-p 表示每次提交的内容差异，-2 则表示显示最近的两次更新。</p><p>说明：该选项除了显示基本信息之外，还在附带了每次 commit 的变化。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/381402cab6344a00b05b3a42fe128a60.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2><span id="gen-ju-ha-xi-zhi-cha-kan-xiu-gai-dai-ma-xi-jie">根据哈希值查看修改代码细节</span><a href="#gen-ju-ha-xi-zhi-cha-kan-xiu-gai-dai-ma-xi-jie" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show 哈希值</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show 哈希值 文件名 //具体某个文件的变化</span><br></pre></td></tr></table></figure><h2><span id="gen-ju-fen-zhi-huo-yong-hu-cha-kan-ti-jiao-xin-xi">根据分支或用户查看提交信息</span><a href="#gen-ju-fen-zhi-huo-yong-hu-cha-kan-ti-jiao-xin-xi" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git log 分支名</span><br><span class="line"></span><br><span class="line">git log --authot=&#x27;用户名&#x27;</span><br><span class="line">//这两个命令可以通过 | xargs  与 git show搭配用</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="dan-ci-ceng-mian-shang-de-dui-bi">单词层面上的对比</span><a href="#dan-ci-ceng-mian-shang-de-dui-bi" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --word-diff -- &lt;file&gt;</span><br></pre></td></tr></table></figure><blockquote><p>参数：–word-diff 表示获取单词层面上的对比。</p></blockquote><blockquote><p>说明：进行单词层面的对比常常是没什么用的。不过当你需要在书籍、论文这种很大的文本文件上进行对比的时候，这个功能就显出用武之地了。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/dbf8557886aa4e16905b75a0fc368c29.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>提示：新增加的单词被 {+ +} 括起来，被删除的单词被 [- -] 括起来。</strong></p><h2><span id="tu-xing-hua-cha-kan-ti-jiao-li-shi">图形化查看提交历史</span><a href="#tu-xing-hua-cha-kan-ti-jiao-li-shi" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitk -- &lt;file&gt;</span><br></pre></td></tr></table></figure><blockquote><p>说明：随 Git 一同发布的 gitk 就是这样一种工具。它是用 Tcl/Tk 写成的，基本上相当于 git log 命令的可视化版本，凡是<br>git log 可以用的选项也都能用在 gitk 上。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/b981ba602f044894b93bf19d74116145.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>**</p><blockquote><p>gitk中文乱码问题</p></blockquote><p>**<br>解决办法：<br>打开git的配置文件(根据自己安装的git目录，此处为安装在D盘)：D:\Program Files\Git\etc\gitconfig</p><p>在文件内追加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[gui]</span><br><span class="line">  encoding = utf-8</span><br></pre></td></tr></table></figure><h2><span id="ti-qu-git-zhong-mou-ge-wen-jian-de-suo-you-ban-ben-bing-an-shun-xu-ming-ming">提取git中某个文件的所有版本并按顺序命名</span><a href="#ti-qu-git-zhong-mou-ge-wen-jian-de-suo-you-ban-ben-bing-an-shun-xu-ming-ming" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --follow --pretty=format:%H 文件名 | xargs -I&#123;&#125; sh -c &#x27;git show &#123;&#125;:文件名 &gt; 文件名.&#123;&#125;&#x27;</span><br></pre></td></tr></table></figure><p><strong>文件名需要进行替换，不可直接输入 文件名 三个字</strong></p><br><p><strong>如果出现</strong> </p><blockquote><p>Did you menan ‘哈希值：路径’ aka ‘哈希值：路径’</p></blockquote><p>字眼的错误</p><p>给第二个文件名添加 <code>./</code></p><h2><span id="git-jiang-yuan-cheng-fen-zhi-an-fen-zhi-ming-zai-ben-di-jian-li-wen-jian-jia">git将远程分支按分支名在本地建立文件夹</span><a href="#git-jiang-yuan-cheng-fen-zhi-an-fen-zhi-ming-zai-ben-di-jian-li-wen-jian-jia" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r | xargs -d/ -n1 | grep -v &#x27;origin&#x27; | xargs -I&#123;&#125; sh -c &#x27;mkdir &quot;C:\Users\76585\Desktop\try\&#123;&#125;&quot; &#x27;</span><br></pre></td></tr></table></figure><p>命令分线见 <strong>博客–Linux Shell命令总结</strong></p><h1><span id="git-ji-ben-shi-yong-liu-cheng">git 基本使用流程</span><a href="#git-ji-ben-shi-yong-liu-cheng" class="header-anchor">#</a></h1><h2><span id="git-pull-yu-git-push-xiang-jie">git pull 与 git push 详解</span><a href="#git-pull-yu-git-push-xiang-jie" class="header-anchor">#</a></h2><p>1.git remote</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin url  //这里面的origin 是给远程仓库起名字，不是给本地仓库！</span><br></pre></td></tr></table></figure><p>2.git pull</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git pull 其实就是 git fetch 和 git merge FETCH_HEAD 的简写。 命令格式如下：</span><br><span class="line"></span><br><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。</span><br><span class="line"></span><br><span class="line">git pull origin master:brantest</span><br><span class="line"></span><br><span class="line">如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</span><br><span class="line"></span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>3.git push </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line"></span><br><span class="line">如果本地分支名与远程分支名相同，则可以省略冒号：</span><br><span class="line"></span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实例：<br>以下命令将本地的 master 分支推送到 origin 主机的 master 分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line">相等于：</span><br><span class="line"></span><br><span class="line">git push origin master:master</span><br><span class="line"></span><br><span class="line">如果本地版本与远程版本有差异，但又要强制推送可以使用 --force 参数：</span><br><span class="line"></span><br><span class="line">git push --force origin master</span><br><span class="line"></span><br><span class="line">删除主机的分支可以使用 --delete 参数，以下命令表示删除 origin 主机的 master 分支：</span><br><span class="line"></span><br><span class="line">git push origin --delete master</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="jiang-ben-di-dai-ma-shang-chuan-dao-yuan-cheng-cang-ku">将本地代码上传到远程仓库</span><a href="#jiang-ben-di-dai-ma-shang-chuan-dao-yuan-cheng-cang-ku" class="header-anchor">#</a></h2><p>1.（电脑里得先下载git）登录coding，新建一个仓库，点击代码浏览可以看到<br><img src="https://img-blog.csdnimg.cn/dfad51be62a440cd86b764c2e4f16487.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/7063830ad8194b8792977f5750a8d1d4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>2.在本地新建一个文件夹，作为项目根目录，再此启动 Git Bash ，进入目录，并输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>3.将本地仓库和我们在coding上创建的远程仓库对接起来，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add *yourname* *git_url*  //不用输这条，输下面那条</span><br></pre></td></tr></table></figure><p>add 后面输入你的仓库名字，自定义。git_url代表你的git地址，这里我命名为origin</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin *url* //这条指令是上面的详细版，输入这个就好。</span><br></pre></td></tr></table></figure><blockquote><p>（这里可能会出现叫你设置邮箱，和姓名，跟着提示设置就行了，或者可以选择以SSH公钥进行连接，不过得先去配置公钥）</p></blockquote><p>回车成功后可以输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>4.为了我们的代码是最新的状态 和 提交时不会产生冲突，我们先执行下pull操作，将远程仓库最新代码拉到我们本地来，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><blockquote><p>（origin就是我们上面设置的仓库名，master代表主分支，你可以把分支理解为一块区域，我们最终编写完成的代码都要整合到master分支里面去。然后，我们还可创建一些其他分支，去保存我们正在编写中，或者尚未测试的代码。）</p></blockquote><p>执行完后，你可以查看目录下的文件，这时我们本地的文件就和远程仓库里面master分支里的文件一样了。</p><p>5.接下来我们来模拟写代码并上传到远程仓库去。<br>我们新建一个 a.js文件，并编辑一些内容进去。首先将a文件添加到暂存区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git add a.js //（add后面可以带多个文件名字，用空格隔开；或者输入 . 代表全部）</span><br><span class="line"></span><br><span class="line">//然后再提交到本地仓库中去</span><br><span class="line"></span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line"></span><br><span class="line">//然后我们需要把它push到远程仓库中去。输入</span><br><span class="line"></span><br><span class="line">git push origin master  //push到origin的master主分支里面，成功后会显示提示消息</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="fen-zhi-de-shi-yong">分支的使用</span><a href="#fen-zhi-de-shi-yong" class="header-anchor">#</a></h2><p><strong>mster代表主分支，最终的代码都整合到这里面去，我们可以看下</strong><br><img src="https://img-blog.csdnimg.cn/fcc0d993653e42e7a48a10d25328f11e.png" alt="在这里插入图片描述"></p><p><strong>这里只有一个主分支master。<br>有一种情况就是，一个项目多人开发，我的任务需要开发一个功能，我没办法短时间内就开发测试等等一系列完成。所以我可以新建一个分支，然后把每次完成的代码都上传到这个分支里面去，最后等到所有操作都完成后，我再把这个分支整合到master中去。下面看步骤</strong></p><p>1.首先查看当前分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p>-a代表查看本地和远程的分支，此时我们看到都只有一个master分支<br><img src="https://img-blog.csdnimg.cn/8e219832c5df4eef8c7da9dce7cd1829.png" alt="在这里插入图片描述"></p><p>2.新建分支dev</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure><p>-b代表同时切换到dev分支下面去，这时你可以再去查看分支</p><p>3.然后我们重新写一个b.js文件，再执行add，commit，最后push</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add b.js</span><br><span class="line"></span><br><span class="line">git commit -m &quot;dev&quot;</span><br><span class="line"></span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure><p><strong>注意push时要到dev分支</strong></p><p>成功后我们去coding看已经有了dev，并且dev下有b.js，而master没有b.js<br><img src="https://img-blog.csdnimg.cn/ca05925c026f48d4af3cc08ced1632da.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>master：<br><img src="https://img-blog.csdnimg.cn/abc1cba6a233436a8a4731ec90324646.png" alt="在这里插入图片描述"></p><p>我们可以再去看看分支情况，</p><p>git branch -a<br><img src="https://img-blog.csdnimg.cn/5323471b84664e88b25f3f6228da4e74.png" alt="在这里插入图片描述"></p><p>此时已经有了两个分支，且当前位于dev分之下<br>切换分支可以用 <strong>git checkout [branch-name]</strong></p><h2><span id="zheng-he-fen-zhi">整合分支</span><a href="#zheng-he-fen-zhi" class="header-anchor">#</a></h2><p><strong>当我们在dev下折腾完成后，最终要整合到master中去，看步骤</strong></p><p>1.切换本地分支到master</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>2.将远程仓库的最新代码pull下来！！因为期间其他人可能已经提交代码到远程master了，所以你首先得更新下自己本地的master代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>假如有改动过，那么执行后会显示改动的信息</p><p>3.然后再把本地的dev代码整合到master，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure><p>merge整合操作，把dev整合到当前分之下（当前分支为master）。会提示增加了东西<br><img src="https://img-blog.csdnimg.cn/249f2d65516c483a9517f8ce5affb72f.png" alt="在这里插入图片描述"></p><p>4.由于当前的东西已经在本地仓库里面了，所以最后我们再执行push，到远程仓库的master</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>成功后你可看到，master下已经有b.js文件了<br><img src="https://img-blog.csdnimg.cn/1f2c3d8b692b42619534a683d2c3f21a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;config-xiang-guan-ming-ling&quot;&gt;config相关命令&lt;/span&gt;&lt;a href=&quot;#config-xiang-guan-ming-ling&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span</summary>
      
    
    
    
    <category term="git" scheme="http://example.com/categories/git/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="运维" scheme="http://example.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
    <category term="代码管理" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>python</title>
    <link href="http://example.com/2022/01/14/python/"/>
    <id>http://example.com/2022/01/14/python/</id>
    <published>2022-01-13T16:00:00.000Z</published>
    <updated>2022-01-18T08:49:00.552Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="suo-yu-wen-ti">所遇问题</span><a href="#suo-yu-wen-ti" class="header-anchor">#</a></h1><h2><span id="shu-chu-ge-shi-you-wen-ti">输出格式有问题</span><a href="#shu-chu-ge-shi-you-wen-ti" class="header-anchor">#</a></h2><p>背景：python2.7，IDE：VSCode<br>源码：<br><img src="https://img-blog.csdnimg.cn/aad38ed43cf14169a81178f15d5cab6b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>two.txt:<br><img src="https://img-blog.csdnimg.cn/30f55f74a6f04008af34c386d4ac4631.png" alt="在这里插入图片描述"></p><p>输出：<br><img src="https://img-blog.csdnimg.cn/006fd38c10064562b5261b067cd0d0e8.png" alt="在这里插入图片描述"><br>预期应该为商品，单价，数量。</p><p>修改最后一行的print<br><img src="https://img-blog.csdnimg.cn/be1c33ec8b6e4593806ab989758d5641.png" alt="在这里插入图片描述"></p><h2><span id="da-bao-pip-install-bao">打包pip install 包</span><a href="#da-bao-pip-install-bao" class="header-anchor">#</a></h2><blockquote><p>背景：内网需要安装python和一些包，无法连互联网，只能外网下载再u盘拷过去。</p></blockquote><ol><li>在外网机器Python的安装目录中新建一个文件夹，如packages：<br><img src="https://img-blog.csdnimg.cn/f86df46c2cc4468fa89c15c1708df6fe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>进入到packages文件夹下，shift按住，鼠标右键“在此处打开命令行”，输入pip<br>list查看系统中安装了哪些python包，如下：<br><img src="https://img-blog.csdnimg.cn/730bff4d9f30437790528bf4db3797cb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>把所有包名及版本号，重定向到requirements.txt中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip freeze &gt;requirements.txt</span><br></pre></td></tr></table></figure></li><li>然后下载系统中已经安装的所有包到一个目录下，比如在packages的packages中，使用如下命令,此时packages下有两个文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip download -r requirements.txt -d packages</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/1db7754fe1984892849f3d5adca5bc5b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ol start="5"><li>内网安装。先复制刚才外网机器上的文件夹pacjages到内网机器对应的目录<br><img src="https://img-blog.csdnimg.cn/8a4c18aa77c040dd925733f93ade928e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>进入到D:\Python37\packages下，打开命令行，执行安装</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --no-index --find-links=packages -r requirements.txt </span><br></pre></td></tr></table></figure><p>如果失败，可以一个一个安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install XXXX包名</span><br></pre></td></tr></table></figure><h2><span id="python2-7-xie-zai-shi-bai-wen-ti">python2.7 卸载失败问题</span><a href="#python2-7-xie-zai-shi-bai-wen-ti" class="header-anchor">#</a></h2><blockquote><p>背景：使用.msi文件进行卸载，出现以下情况：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/bcd0965e3e1c4c929422fa9b879729cb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>解决方法：<br>找到出问题的版本，个人当时出问题的版本是2.7.10。官网下载msi文件。<br><img src="https://img-blog.csdnimg.cn/93c843b909ec45ec85865dbf3c2ae945.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>依次运行。</p><h2><span id="open-han-shu-chuan-can-shu-chu-cuo">open函数传参数出错</span><a href="#open-han-shu-chuan-can-shu-chu-cuo" class="header-anchor">#</a></h2><blockquote><p>背景：python2.7，open函数传递参数。<br>自定义函数，函数里面调用open函数</p></blockquote><p><img src="https://img-blog.csdnimg.cn/4c36a39430c747eb86e933b2ae67b809.png" alt="在这里插入图片描述"><br>如果不在路径前面加r，就会报错。按理说应该是<br>open(file_path,mode)</p><p>后面写出函数，拼接的时候老出错。<br><strong>解决办法：</strong></p><blockquote><p>路径使用/<br>‘C:/Users/76585/Desktop/compare/one.txt’</p></blockquote><p>open函数可以正常使用open(path,mode)</p><h2><span id="python-bian-ma-cuo-wu-de-jie-jue-ban-fa-syntaxerror-non-ascii-character-xe5-in-file">Python编码错误的解决办法SyntaxError: Non-ASCII character ‘\xe5’ in file</span><a href="#python-bian-ma-cuo-wu-de-jie-jue-ban-fa-syntaxerror-non-ascii-character-xe5-in-file" class="header-anchor">#</a></h2><blockquote><p>原因：python的默认编码文件是用的ASCII码，而你的python文件中使用了中文等非英语字符</p></blockquote><p>解决办法：</p><p>在Python源文件的最开始一行，加入一句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#coding=UTF-8（等号换为”:“也可以）</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#-*- coding:UTF-8 -*-</span><br></pre></td></tr></table></figure><h2><span id="runtimeerror-dictionary-changed-size-during-iteration">RuntimeError: dictionary changed size during iteration</span><a href="#runtimeerror-dictionary-changed-size-during-iteration" class="header-anchor">#</a></h2><p>在字典遍历过程中修改字典元素，报错 RuntimeError: dictionary changed size during iteration</p><p>得知遍历时不能修改字典元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for k in func_dict.keys():</span><br><span class="line">    if func_dict[k] is np.nan:</span><br><span class="line">        del func_dict[k]</span><br><span class="line">        continue</span><br></pre></td></tr></table></figure><p><strong>解决办法：将遍历条件改为列表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for k in list(func_dict.keys()):</span><br><span class="line">    if func_dict[k] is np.nan:</span><br><span class="line">        del func_dict[k]</span><br><span class="line">        continue</span><br></pre></td></tr></table></figure><h2><span id="vscode-code-runner-wu-fa-yun-xing-chu-zheng-que-de-jie-guo">VScode code runner无法运行出正确的结果</span><a href="#vscode-code-runner-wu-fa-yun-xing-chu-zheng-que-de-jie-guo" class="header-anchor">#</a></h2><p>背景：<br>内网电脑上，通过python程序对文件进行读写操作，但是没有出现相应的结果。单步调试可以出正确的结果。</p><p>分析：<br>通过print 输出可以发现问题。命令行运行py文件可以得到正确的结果，说明原因出在code runner上面。</p><p>解决办法：<br>1.首选项找到设置<br><img src="https://img-blog.csdnimg.cn/84c82a81f052455385019bbc37bc93b2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>2.输入code-runner，找到 Executor Map<br><img src="https://img-blog.csdnimg.cn/b22a0f9e154642e0843ce47974245361.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>3.选择这个，（将设置复制为id）<br><img src="https://img-blog.csdnimg.cn/a78e8887588e4e0591da5a2f391335aa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/59d97e84f5384682828af42b5d5f03a1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>将复制的内容粘贴到里面</p><p><img src="https://img-blog.csdnimg.cn/0bdfe664d55944f3b118f82861f2a31a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>修改其中python字段的python值替换为vscode左下角的python解释器：<br>结果如下;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;python&quot;: &quot;C:\\Python27\\python.exe -u&quot; //注意转义符</span><br><span class="line">//下面这个也可以</span><br><span class="line"></span><br><span class="line">&quot;python&quot;: &quot;\&quot;C:/Python27/python.exe\&quot; -u&quot;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/6eef8ba7ef9e47a9bbef68a0918f3b94.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1><span id="ji-zhu-zhi-shi-dian">技术知识点</span><a href="#ji-zhu-zhi-shi-dian" class="header-anchor">#</a></h1><h2><span id="bian-li-wen-jian-jia-xia-de-wen-jian-ming">遍历文件夹下的文件名</span><a href="#bian-li-wen-jian-jia-xia-de-wen-jian-ming" class="header-anchor">#</a></h2><blockquote><p>#方法1：使用os.listdir</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">for filename in os.listdir(r&#x27;c:\windows&#x27;):</span><br><span class="line">    print(&quot;文件夹名字&quot;,filename)</span><br></pre></td></tr></table></figure><blockquote><p>#方法2：使用glob模块，可以设置文件过滤</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import glob</span><br><span class="line">for filename in glob.glob(r&#x27;c:\windows\*.exe&#x27;):</span><br><span class="line">    print(&quot;是.exe的文件名&quot;,filename)</span><br></pre></td></tr></table></figure><blockquote><p>#方法3：非递归</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">for dirpath, dirnames, filenames in os.walk(&#x27;D:&#x27;):</span><br><span class="line">    print(&#x27;文件路径&#x27;, dirpath)</span><br><span class="line">    print(&#x27;文件夹名字&#x27;,dirnames)</span><br><span class="line">    for filename in filenames:</span><br><span class="line">        print(&#x27;文件名&#x27;, filename)</span><br></pre></td></tr></table></figure><h2><span id="zi-fu-chuan-cao-zuo">字符串操作</span><a href="#zi-fu-chuan-cao-zuo" class="header-anchor">#</a></h2><h3><span id="zi-fu-chuan-qie-ge">字符串切割</span><a href="#zi-fu-chuan-qie-ge" class="header-anchor">#</a></h3><p>注：使用前需要引入包（import re）<br>功能：split能够按照所能匹配的字串将字符串进行切分，返回切分后的字符串列表<br>形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.split(pattern, string[, maxsplit=0, flags=0])</span><br></pre></td></tr></table></figure><p>pattern:匹配的字符串<br>string:需要切分的字符串<br>maxsplit:分隔次数，默认为0(即不限次数)<br>flags:标志位，用于控制正则表达式的匹配方式，比如：是否区分大小写，，，如下图所示</p><p>具体分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//传入某个文件的绝对路径（file_path），根据 &#x27;\&#x27;进行分割，将结果存入列表，再取出最后一个，就是文件名。</span><br><span class="line">new_line= re.split(r&#x27;[/]&#x27;,str(file_path))</span><br><span class="line">file_name=new_line[-1]</span><br></pre></td></tr></table></figure><h3><span id="ti-huan-zi-fu-chuan-zhong-de-pi-pei-xiang">替换字符串中的匹配项</span><a href="#ti-huan-zi-fu-chuan-zhong-de-pi-pei-xiang" class="header-anchor">#</a></h3><p><strong>re.sub()</strong> </p><pre><code>def sub(pattern, repl, string, count=0, flags=0):    &quot;&quot;&quot;Return the string obtained by replacing the leftmost    non-overlapping occurrences of the pattern in string by the    replacement repl.  repl can be either a string or a callable;    if a string, backslash escapes in it are processed.  If it is    a callable, it&#39;s passed the match object and must return    a replacement string to be used.&quot;&quot;&quot;    return _compile(pattern, flags).sub(repl, string, count)</code></pre><p>从上面的代码中可以看到re.sub()方法中含有5个参数，下面进行一一说明（加粗的为必须参数）：<br>（1）<strong>pattern</strong>：该参数表示正则中的模式字符串；<br>（2）<strong>repl</strong>：该参数表示要替换的字符串（即匹配到pattern后替换为repl），也可以是个函数；<br>（3）<strong>string</strong>：该参数表示要被处理（查找替换）的原始字符串；<br>（4）count：可选参数，表示是要替换的最大次数，而且必须是非负整数，该参数默认为0，即所有的匹配都会被替换；<br>（5）flags：可选参数，表示编译时用的匹配模式（如忽略大小写、多行模式等），数字形式，默认为0。</p><p>使用案例：<br><strong>1.匹配单一数字</strong><br>（1）只匹配单一数字</p><pre><code>&gt;&gt;&gt; import re&gt;&gt;&gt; s&quot;大家好，我是一个程序员小白。I &#39;m so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn&quot;&gt;&gt;&gt; re.sub(r&#39;[0-9]&#39;, &#39;*&#39;, s)&quot;大家好，我是一个程序员小白。I &#39;m so glad to introduce myself, and I’m ** years old.   Today is ****/**/**. It is a wonderful DAY! @HHHHello,,,#***ComeHere***...**？AA？zz？——http://welcome.cn&quot;</code></pre><p>上面 re.sub(r’[0-9]’, ‘*’, s) 这句话则表示只匹配单一数字，并将每一个数字替换为一个星号 。</p><p>（2）只匹配单一字母</p><pre><code>&gt;&gt;&gt; s&quot;大家好，我是一个程序员小白。I &#39;m so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn&quot;&gt;&gt;&gt; re.sub(r&#39;[a-z]&#39;, &#39;*&#39;, s)&quot;大家好，我是一个程序员小白。I &#39;* ** **** ** ********* ******, *** I’* 18 ***** ***.   T**** ** 2020/01/01. I* ** * ********* DAY! @HHHH****,,,#111C***H***222...66？AA？**？——****://*******.**&quot;&gt;&gt;&gt; re.sub(r&#39;[A-Z]&#39;, &#39;*&#39;, s)&quot;大家好，我是一个程序员小白。* &#39;m so glad to introduce myself, and *’m 18 years old.   *oday is 2020/01/01. *t is a wonderful ***! @****ello,,,#111*ome*ere222...66？**？zz？——http://welcome.cn&quot;&gt;&gt;&gt; re.sub(r&#39;[A-Za-z]&#39;, &#39;*&#39;, s)&quot;大家好，我是一个程序员小白。* &#39;* ** **** ** ********* ******, *** *’* 18 ***** ***.   ***** ** 2020/01/01. ** ** * ********* ***! @********,,,#111********222...66？**？**？——****://*******.**&quot;</code></pre><p>上面 re.sub(r’[a-z]’, ‘<em>‘, s) 这句话则表示只匹配单一小写字母，并将每一个小写字母替换为一个星号 。<br>上面 re.sub(r’[A-Z]’, ‘</em>‘, s) 这句话则表示只匹配单一大写字母，并将每一个大写字母替换为一个星号 。<br>上面 re.sub(r’[A-Za-z]’, ‘*’, s) 这句话则表示只匹配单一字母，并将每一个字母替换为一个星号 。</p><p>（3）匹配单一数字和字母</p><pre><code>&gt;&gt;&gt; s&quot;大家好，我是一个程序员小白。I &#39;m so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn&quot;&gt;&gt;&gt; re.sub(r&#39;[0-9A-Z]&#39;, &#39;*&#39;, s)&quot;大家好，我是一个程序员小白。* &#39;m so glad to introduce myself, and *’m ** years old.   *oday is ****/**/**. *t is a wonderful ***! @****ello,,,#****ome*ere***...**？**？zz？——http://welcome.cn&quot;&gt;&gt;&gt; re.sub(r&#39;[0-9a-z]&#39;, &#39;*&#39;, s)&quot;大家好，我是一个程序员小白。I &#39;* ** **** ** ********* ******, *** I’* ** ***** ***.   T**** ** ****/**/**. I* ** * ********* DAY! @HHHH****,,,#***C***H******...**？AA？**？——****://*******.**&quot;&gt;&gt;&gt; re.sub(r&#39;[0-9A-Za-z]&#39;, &#39;*&#39;, s)&quot;大家好，我是一个程序员小白。* &#39;* ** **** ** ********* ******, *** *’* ** ***** ***.   ***** ** ****/**/**. ** ** * ********* ***! @********,,,#**************...**？**？**？——****://*******.**&quot;</code></pre><p>上面 re.sub(r’[0-9A-Z]’, ‘<em>‘, s) 这句话则表示只匹配单一数字和大写字母，并将每一个数字和大写字母替换为一个星号 。<br>上面 re.sub(r’[0-9a-z]’, ‘</em>‘, s) 这句话则表示只匹配单一数字和小写字母，并将每一个数字和小写字母替换为一个星号 。<br>上面 re.sub(r’[0-9A-Za-z]’, ‘*’, s) 这句话则表示只匹配单一数字和字母，并将每一个数字和字母替换为一个星号 。</p><p><strong>2.匹配多个数字或字母</strong><br>注意：这里的所说的多个指的是大于等于一个。</p><p>（1）匹配多个数字</p><pre><code>&gt;&gt;&gt; s&quot;大家好，我是一个程序员小白。I &#39;m so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn&quot;&gt;&gt;&gt; re.sub(r&#39;[0-9]+&#39;, &#39;*&#39;, s)&quot;大家好，我是一个程序员小白。I &#39;m so glad to introduce myself, and I’m * years old.   Today is */*/*. It is a wonderful DAY! @HHHHello,,,#*ComeHere*...*？AA？zz？——http://welcome.cn&quot;</code></pre><p>上面 re.sub(r’[0-9]+’, ‘*’, s) 这句话则表示匹配多个连续的数字，并将多个连续的数字替换为一个星号 。</p><p>（2）匹配多个字母</p><pre><code>&gt;&gt;&gt; s&quot;大家好，我是一个程序员小白。I &#39;m so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn&quot;&gt;&gt;&gt; re.sub(r&#39;[a-z]+&#39;, &#39;*&#39;, s)&quot;大家好，我是一个程序员小白。I &#39;* * * * * *, * I’* 18 * *.   T* * 2020/01/01. I* * * * DAY! @HHHH*,,,#111C*H*222...66？AA？*？——*://*.*&quot;&gt;&gt;&gt; re.sub(r&#39;[A-Z]+&#39;, &#39;*&#39;, s)&quot;大家好，我是一个程序员小白。* &#39;m so glad to introduce myself, and *’m 18 years old.   *oday is 2020/01/01. *t is a wonderful *! @*ello,,,#111*ome*ere222...66？*？zz？——http://welcome.cn&quot;&gt;&gt;&gt; re.sub(r&#39;[a-zA-Z]+&#39;, &#39;*&#39;, s)&quot;大家好，我是一个程序员小白。* &#39;* * * * * *, * *’* 18 * *.   * * 2020/01/01. * * * * *! @*,,,#111*222...66？*？*？——*://*.*&quot;</code></pre><p>上面 re.sub(r’[a-z]+’, ‘<em>‘, s) 这句话则表示匹配多个连续的小写字母，并将多个连续的小写字母替换为一个星号 。<br>上面 re.sub(r’[A-Z]+’, ‘</em>‘, s) 这句话则表示匹配多个连续的大写字母，并将多个连续的大写字母替换为一个星号 。<br>上面 re.sub(r’[A-Za-z]+’, ‘*’, s) 这句话则表示匹配多个连续的字母，并将多个连续的字母替换为一个星号 。</p><p>（3）匹配多个数字和字母</p><pre><code>&gt;&gt;&gt; s&quot;大家好，我是一个程序员小白。I &#39;m so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn&quot;&gt;&gt;&gt; re.sub(r&#39;[0-9a-zA-Z]+&#39;, &#39;*&#39;, s)&quot;大家好，我是一个程序员小白。* &#39;* * * * * *, * *’* * * *.   * * */*/*. * * * * *! @*,,,#*...*？*？*？——*://*.*&quot;</code></pre><p>上面 re.sub(r’[0-9A-Za-z]+’, ‘*’, s) 这句话则表示匹配多个连续的数字和字母，并将多个连续的数字、连续的字母、连续的数字和字母替换为一个星号 。</p><p><strong>3.匹配其他</strong></p><p>（1）匹配非数字</p><pre><code>&gt;&gt;&gt; s&quot;大家好，我是一个程序员小白。I &#39;m so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn&quot;&gt;&gt;&gt; re.sub(r&#39;[^0-9]&#39;, &#39;*&#39;, s)&#39;********************************************************18***********************2020*01*01**************************************111********222***66**************************&#39;&gt;&gt;&gt; re.sub(r&#39;[^0-9]+&#39;, &#39;*&#39;, s)&#39;*18*2020*01*01*111*222*66*&#39;</code></pre><p>上面 re.sub(r’[^0-9]’, ‘<em>‘, s) 这句话则表示匹配单个非数字，并将单个非数字替换为一个星号 。<br>上面 re.sub(r’[^0-9]+’, ‘</em>‘, s) 这句话则表示匹配多个连续的非数字，并将多个连续的非数字替换为一个星号 。</p><p>（2）匹配非字母</p><pre><code>&gt;&gt;&gt; s&quot;大家好，我是一个程序员小白。I &#39;m so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn&quot;&gt;&gt;&gt; re.sub(r&#39;[^a-z]&#39;, &#39;*&#39;, s)&#39;*****************m*so*glad*to*introduce*myself**and***m****years*old*****oday*is**************t*is*a*wonderful***********ello********ome*ere************zz***http***welcome*cn&#39;&gt;&gt;&gt; re.sub(r&#39;[^A-Z]&#39;, &#39;*&#39;, s)&#39;**************I*************************************I*******************T********************I*****************DAY***HHHH***********C***H************AA***********************&#39;&gt;&gt;&gt; re.sub(r&#39;[^A-Za-z]&#39;, &#39;*&#39;, s)&#39;**************I**m*so*glad*to*introduce*myself**and*I*m****years*old****Today*is*************It*is*a*wonderful*DAY***HHHHello*******ComeHere*********AA*zz***http***welcome*cn&#39;&gt;&gt;&gt; re.sub(r&#39;[^a-z]+&#39;, &#39;*&#39;, s)&#39;*m*so*glad*to*introduce*myself*and*m*years*old*oday*is*t*is*a*wonderful*ello*ome*ere*zz*http*welcome*cn&#39;&gt;&gt;&gt; re.sub(r&#39;[^A-Z]+&#39;, &#39;*&#39;, s)&#39;*I*I*T*I*DAY*HHHH*C*H*AA*&#39;&gt;&gt;&gt; re.sub(r&#39;[^A-Za-z]+&#39;, &#39;*&#39;, s)&#39;*I*m*so*glad*to*introduce*myself*and*I*m*years*old*Today*is*It*is*a*wonderful*DAY*HHHHello*ComeHere*AA*zz*http*welcome*cn&#39;</code></pre><p>上面 re.sub(r’[^a-z]’, ‘<em>‘, s) 这句话则表示匹配单个非小写字母，并将单个非小写字母替换为一个星号 。<br>上面 re.sub(r’[^A-Z]’, ‘</em>‘, s) 这句话则表示匹配单个非大写字母，并将单个非大写字母替换为一个星号 。<br>上面 re.sub(r’[^A-Za-z]’, ‘<em>‘, s) 这句话则表示匹配单个非字母，并将单个非字母替换为一个星号 。<br>上面 re.sub(r’[^a-z]+’, ‘</em>‘, s) 这句话则表示匹配多个连续的非小写字母，并将多个连续的非小写字母替换为一个星号 。<br>上面 re.sub(r’[^A-Z]+’, ‘<em>‘, s) 这句话则表示匹配多个连续的非大写字母，并将多个连续的非大写字母替换为一个星号 。<br>上面 re.sub(r’[^A-Za-z]+’, ‘</em>‘, s) 这句话则表示匹配多个连续的非字母，并将多个连续的非字母替换为一个星号 。</p><p>（3）匹配非数字和非字母</p><pre><code>&gt;&gt;&gt; s&quot;大家好，我是一个程序员小白。I &#39;m so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn&quot;&gt;&gt;&gt; re.sub(r&#39;[^0-9A-Za-z]&#39;, &#39;*&#39;, s)&#39;**************I**m*so*glad*to*introduce*myself**and*I*m*18*years*old****Today*is*2020*01*01**It*is*a*wonderful*DAY***HHHHello****111ComeHere222***66*AA*zz***http***welcome*cn&#39;&gt;&gt;&gt; re.sub(r&#39;[^0-9A-Za-z]+&#39;, &#39;*&#39;, s)&#39;*I*m*so*glad*to*introduce*myself*and*I*m*18*years*old*Today*is*2020*01*01*It*is*a*wonderful*DAY*HHHHello*111ComeHere222*66*AA*zz*http*welcome*cn&#39;</code></pre><p>上面 re.sub(r’[^0-9A-Za-z]’, ‘<em>‘, s) 这句话则表示匹配单个非数字和非字母，并将单个非数字和非字母替换为一个星号 。<br>上面 re.sub(r’[^0-9A-Za-z]+’, ‘</em>‘, s) 这句话则表示匹配多个连续的非数字和非字母，并将多个连续的非数字和非字母替换为一个星号 。</p><p>（4）匹配固定形式<br>a.只保留字母和空格，将 repl 设置为空字符即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&quot;大家好，我是一个程序员小白。I &#x27;m so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn&quot;</span><br><span class="line">&gt;&gt;&gt; re.sub(r&#x27;[^a-z ]&#x27;, &#x27;&#x27;, s)</span><br><span class="line">&#x27; m so glad to introduce myself and m  years old   oday is  t is a wonderful  elloomeerezzhttpwelcomecn&#x27;</span><br><span class="line">&gt;&gt;&gt; re.sub(r&#x27;[^a-z ]+&#x27;, &#x27;&#x27;, s)</span><br><span class="line">&#x27; m so glad to introduce myself and m  years old   oday is  t is a wonderful  elloomeerezzhttpwelcomecn&#x27;</span><br><span class="line">&gt;&gt;&gt; re.sub(r&#x27;[^A-Za-z ]&#x27;, &#x27;&#x27;, s)</span><br><span class="line">&#x27;I m so glad to introduce myself and Im  years old   Today is  It is a wonderful DAY HHHHelloComeHereAAzzhttpwelcomecn&#x27;</span><br><span class="line">&gt;&gt;&gt; re.sub(r&#x27;[^A-Za-z ]+&#x27;, &#x27;&#x27;, s)</span><br><span class="line">&#x27;I m so glad to introduce myself and Im  years old   Today is  It is a wonderful DAY HHHHelloComeHereAAzzhttpwelcomecn&#x27;</span><br></pre></td></tr></table></figure><p>如果要使句子语义和结构更完整，则要先将其余字符替换为空格（即repl设置为空格），然后去除多余的空格，如下：</p><pre><code>&gt;&gt;&gt; s1 = re.sub(r&#39;[^A-Za-z ]+&#39;, &#39; &#39;, s)&gt;&gt;&gt; s1&#39; I  m so glad to introduce myself  and I m   years old    Today is   It is a wonderful DAY   HHHHello ComeHere AA zz http welcome cn&#39;&gt;&gt;&gt; re.sub(r&#39;[ ]+&#39;, &#39; &#39;, s1)&#39; I m so glad to introduce myself and I m years old Today is It is a wonderful DAY HHHHello ComeHere AA zz http welcome cn&#39;</code></pre><p>b.去除以 @ 开头的英文单词</p><pre><code>&gt;&gt;&gt; s&quot;大家好，我是一个程序员小白。I &#39;m so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn&quot;&gt;&gt;&gt; re.sub(r&#39;@[A-Za-z]+&#39;, &#39;&#39;, s)&quot;大家好，我是一个程序员小白。I &#39;m so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! ,,,#111ComeHere222...66？AA？zz？——http://welcome.cn&quot;</code></pre><p>c.去除以 ？结尾的英文单词和数字（注意这是中文问号）</p><pre><code>&gt;&gt;&gt; s&quot;大家好，我是一个程序员小白。I &#39;m so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn&quot;&gt;&gt;&gt; re.sub(r&#39;[A-Za-z]+？&#39;, &#39;&#39;, s)&quot;大家好，我是一个程序员小白。I &#39;m so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？——http://welcome.cn&quot;&gt;&gt;&gt; re.sub(r&#39;[0-9A-Za-z]+？&#39;, &#39;&#39;, s)&quot;大家好，我是一个程序员小白。I &#39;m so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...——http://welcome.cn&quot;</code></pre><p>d.去除原始字符串中的URL</p><pre><code>&gt;&gt;&gt; s&quot;大家好，我是一个程序员小白。I &#39;m so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn&quot;&gt;&gt;&gt; re.sub(r&#39;http[:.]+\S+&#39;, &#39;&#39;, s)&quot;大家好，我是一个程序员小白。I &#39;m so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——&quot;</code></pre><h3><span id="zi-fu-chuan-ti-qu-ti-qu-shu-zi">字符串提取–提取数字</span><a href="#zi-fu-chuan-ti-qu-ti-qu-shu-zi" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">re.findall(r&#x27;\d+&#x27;, str(string))</span><br><span class="line">// &#x27;\d&#x27;是正则表达式，+表示匹配多个，如果不加，就是单个的数字</span><br></pre></td></tr></table></figure><h3><span id="zi-fu-chuan-xiang-si-du-bi-jiao">字符串相似度比较</span><a href="#zi-fu-chuan-xiang-si-du-bi-jiao" class="header-anchor">#</a></h3><p>python自带比较相似度的模块，difflib。比较两个字符串的模块是difflib.SequenceMatcher，使用起来很简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import difflib</span><br><span class="line"> </span><br><span class="line">def string_similar(s1, s2):</span><br><span class="line">    return difflib.SequenceMatcher(None, s1, s2).quick_ratio()</span><br><span class="line"> </span><br><span class="line">print string_similar(&#x27;爱尔眼科沪滨医院&#x27;, &#x27;沪滨爱尔眼科医院&#x27;)</span><br><span class="line">print string_similar(&#x27;安定区妇幼保健站&#x27;, &#x27;定西市安定区妇幼保健站&#x27;)</span><br><span class="line">print string_similar(&#x27;广州市医院&#x27;, &#x27;广东省中医院&#x27;)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.0</span><br><span class="line">0.842105263158</span><br><span class="line">0.606060606061</span><br></pre></td></tr></table></figure><p>其中None的位置是一个函数，用来去掉自己不想算在内的元素。比如我想把空格排除在外：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seq = difflib.SequenceMatcher(lambda x:x=&quot; &quot;, a, b)</span><br><span class="line">ratio = seq.ratio()</span><br></pre></td></tr></table></figure><h2><span id="lie-biao-xiang-guan-cao-zuo">列表相关操作</span><a href="#lie-biao-xiang-guan-cao-zuo" class="header-anchor">#</a></h2><h3><span id="liang-ge-lie-biao-qu-jiao-ji">两个列表取交集</span><a href="#liang-ge-lie-biao-qu-jiao-ji" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=[i for i in list2 if i  in list1]</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(set(a).intersection(b))</span><br></pre></td></tr></table></figure><h3><span id="lie-biao-qu-bing-ji">列表取并集</span><a href="#lie-biao-qu-bing-ji" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(set(a).union(b))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(set(a) | set(b))</span><br></pre></td></tr></table></figure><p><strong>多个列表取并集：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(set(a).intersection(b,c)) </span><br></pre></td></tr></table></figure><h3><span id="lie-biao-qu-chai-ji">列表取差集</span><a href="#lie-biao-qu-chai-ji" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(set(a).difference(b))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(set(a).difference(b,c)) # 求特定1个list(a)中有，其他list(b、c)都没有的元素&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3><span id="lie-biao-pai-xu-geng-xiang-xi-cao-zuo-jian-wen-dang">列表排序（更详细操作见文档）</span><a href="#lie-biao-pai-xu-geng-xiang-xi-cao-zuo-jian-wen-dang" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file_list.sort(key=lambda x:int(x[9:-4]))</span><br><span class="line">//根据关键字来排序，lambda是一个函数的简写。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//下面两个写法是一样的</span><br><span class="line">g = lambda x:x+1</span><br><span class="line"></span><br><span class="line"> def g(x):</span><br><span class="line">     return x+1</span><br></pre></td></tr></table></figure><h3><span id="lie-biao-ti-huan-yuan-su-geng-xiang-xi-cao-zuo-jian-wen-dang">列表替换元素（更详细操作见文档）</span><a href="#lie-biao-ti-huan-yuan-su-geng-xiang-xi-cao-zuo-jian-wen-dang" class="header-anchor">#</a></h3><p>1.直接替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//假设要把列表中的a元素替换为b</span><br><span class="line">//首先得到a的索引，将这个索引的值赋为b</span><br><span class="line">list[list.index(a)]=b</span><br></pre></td></tr></table></figure><p>2.条件替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> lst = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]</span><br><span class="line"></span><br><span class="line"> rep = [&#x27;4&#x27; if x == &#x27;2&#x27; else x for x in lst]</span><br><span class="line"></span><br><span class="line"> rep</span><br><span class="line"></span><br><span class="line">[&#x27;1&#x27;, &#x27;4&#x27;, &#x27;3&#x27;]</span><br></pre></td></tr></table></figure><p>3.批量替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> lst = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;]</span><br><span class="line"></span><br><span class="line">pattern = [&#x27;3&#x27;, &#x27;4&#x27;]</span><br><span class="line"></span><br><span class="line">rep = [&#x27;d&#x27; if x in pattern else x for x in lst]</span><br><span class="line"></span><br><span class="line">rep</span><br><span class="line"></span><br><span class="line">[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;d&#x27;, &#x27;d&#x27;, &#x27;5&#x27;]</span><br></pre></td></tr></table></figure><p>4.映射替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> lst = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;]</span><br><span class="line"></span><br><span class="line"> pattern = &#123;&#x27;3&#x27;:&#x27;three&#x27;, &#x27;4&#x27;:&#x27;four&#x27;&#125;</span><br><span class="line"></span><br><span class="line"> rep = [pattern[x] if x in pattern else x for x in lst]</span><br><span class="line"></span><br><span class="line">rep</span><br><span class="line"></span><br><span class="line">[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;three&#x27;, &#x27;four&#x27;, &#x27;5&#x27;]</span><br></pre></td></tr></table></figure><h2><span id="xml-xiang-guan-cao-zuo">XML相关操作</span><a href="#xml-xiang-guan-cao-zuo" class="header-anchor">#</a></h2><h3><span id="chuang-jian-yi-ge-xml-wen-dang">创建一个XML文档</span><a href="#chuang-jian-yi-ge-xml-wen-dang" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import xml.dom.minidom</span><br><span class="line">import re,os</span><br><span class="line"></span><br><span class="line">list=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;str_scheme_name&#x27;, &#x27;str_limiter&#x27;]</span><br><span class="line">doc = xml.dom.minidom.Document() </span><br><span class="line">root = doc.createElement(&#x27;version-check&#x27;)</span><br><span class="line">doc.appendChild(root)</span><br><span class="line"></span><br><span class="line">for i in list:</span><br><span class="line">    var_name = doc.createElement(i)</span><br><span class="line"></span><br><span class="line">    version=doc.createElement(&#x27;version&#x27;)</span><br><span class="line">    version.setAttribute(&#x27;v&#x27;,&#x27;100&#x27;)</span><br><span class="line">    version.appendChild(doc.createTextNode(i))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    var_name.appendChild(version)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    root.appendChild(var_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fp = open(&#x27;C:/Users/76585/Desktop/shell/cfdname2/tow.xml&#x27;, &#x27;w&#x27;)</span><br><span class="line">doc.writexml(fp, indent=&#x27;\t&#x27;, addindent=&#x27;\t&#x27;, newl=&#x27;\n&#x27;, encoding=&quot;utf-8&quot;)</span><br></pre></td></tr></table></figure><h3><span id="dui-xian-you-xml-wen-dang-jin-xing-xiu-gai">对现有XML文档进行修改</span><a href="#dui-xian-you-xml-wen-dang-jin-xing-xiu-gai" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tree=ET.parse(&#x27;C:/Users/76585/Desktop/shell/cfdname2/tow.xml&#x27;)</span><br><span class="line">         root=tree.getroot()</span><br><span class="line"></span><br><span class="line">// b是一个列表</span><br><span class="line">         for i in b:</span><br><span class="line">             newnode=ET.Element(i)</span><br><span class="line"></span><br><span class="line">             version=ET.Element(&#x27;version&#x27;)</span><br><span class="line">             version.attrib=&#123;&quot;v&quot;:end&#125;</span><br><span class="line">             version.text=i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             newnode.append(version)</span><br><span class="line">             # newnode.text=end  </span><br><span class="line">             root.append(newnode)    </span><br><span class="line"></span><br><span class="line">         tree.write(&#x27;C:/Users/76585/Desktop/shell/cfdname2/tow.xml&#x27;)</span><br></pre></td></tr></table></figure><h2><span id="pan-duan-mu-lu-xia-de-kong-wen-jian-jia-bing-shan-chu">判断目录下的空文件夹并删除</span><a href="#pan-duan-mu-lu-xia-de-kong-wen-jian-jia-bing-shan-chu" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 导入os</span><br><span class="line">import os</span><br><span class="line"># 让用户自行输入路径</span><br><span class="line">path=input(&#x27;请输入文件目录路径&#x27;)</span><br><span class="line"># 获取当前目录下的所有文件夹名称  得到的是一个列表</span><br><span class="line">folders=os.listdir(path)</span><br><span class="line"></span><br><span class="line"># # 遍历列表</span><br><span class="line">for folder in folders:</span><br><span class="line">    # 将上级路径path与文件夹名称folder拼接出文件夹的路径</span><br><span class="line">    folder2=os.listdir(path+&#x27;\\&#x27;+folder)</span><br><span class="line">    print(folder2)</span><br><span class="line">    # 若文件夹为空</span><br><span class="line">    if folder2==[]:</span><br><span class="line">        # 则打印此空文件的名称</span><br><span class="line">        print(folder)</span><br><span class="line">        # 并将此空文件夹删除</span><br><span class="line">        os.rmdir(path+&#x27;\\&#x27;+folder)</span><br></pre></td></tr></table></figure><h2><span id="shen-kao-bei-deep-copy">深拷贝–deep copy</span><a href="#shen-kao-bei-deep-copy" class="header-anchor">#</a></h2><p>背景：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict_min[&#x27;name&#x27;]=new_line[1]</span><br><span class="line">dict_mid[new_line[1]]=dict_min</span><br></pre></td></tr></table></figure><p>上面这段代码中，newline[1]发生变化时，dict_min发生变化，从而导致dict_mid受到影响。具体的效果<br><img src="https://img-blog.csdnimg.cn/27eafe4c3413473b8de9f92567056d70.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>name的值会依次被后面的值覆盖，但我们不希望之前的收到影响。</p><p>解决办法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict_min[&#x27;name&#x27;]=new_line[1]</span><br><span class="line">dict_tmp=copy.deepcopy(dict_min)      </span><br><span class="line">dict_mid[new_line[1]]=dict_tmp</span><br></pre></td></tr></table></figure><p>看下深拷贝的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import copy</span><br><span class="line">&gt;&gt;&gt; origin = [1, 2, [3, 4]]</span><br><span class="line">#origin 里边有三个元素：1， 2，[3, 4]</span><br><span class="line">&gt;&gt;&gt; cop1 = copy.copy(origin)</span><br><span class="line">&gt;&gt;&gt; cop2 = copy.deepcopy(origin)</span><br><span class="line">&gt;&gt;&gt; cop1 == cop2</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; cop1 is cop2</span><br><span class="line">False </span><br><span class="line">#cop1 和 cop2 看上去相同，但已不再是同一个object</span><br><span class="line">&gt;&gt;&gt; origin[2][0] = &quot;hey!&quot; </span><br><span class="line">&gt;&gt;&gt; origin</span><br><span class="line">[1, 2, [&#x27;hey!&#x27;, 4]]</span><br><span class="line">&gt;&gt;&gt; cop1</span><br><span class="line">[1, 2, [&#x27;hey!&#x27;, 4]]</span><br><span class="line">&gt;&gt;&gt; cop2</span><br><span class="line">[1, 2, [3, 4]]</span><br><span class="line">#把origin内的子list [3, 4] 改掉了一个元素，观察 cop1 和 cop2</span><br></pre></td></tr></table></figure><p>可以看到 cop1，也就是 shallow copy 跟着 origin 改变了。而 cop2 ，也就是 deep copy 并没有变。</p><p>似乎 deep copy 更加符合我们对「复制」的直觉定义: 一旦复制出来了，就应该是独立的了。如果我们想要的是一个字面意义的「copy」，那就直接用 deep_copy 即可。</p><p>那么为什么会有 shallow copy 这样的「假」 copy 存在呢？ 这就是有意思的地方了。</p><p><strong>python的数据存储方式</strong><br>Python 存储变量的方法跟其他 OOP 语言不同。它与其说是把值赋给变量，不如说是给变量建立了一个到具体值的 reference。</p><p>当在 Python 中 a = something 应该理解为给 something 贴上了一个标签 a。当再赋值给 a 的时候，就好象把 a 这个标签从原来的 something 上拿下来，贴到其他对象上，建立新的 reference。 这就解释了一些 Python 中可能遇到的诡异情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; b = a</span><br><span class="line">&gt;&gt;&gt; a = [4, 5, 6] //赋新的值给 a</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">[1, 2, 3]</span><br><span class="line"># a 的值改变后，b 并没有随着 a 变</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; a = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; b = a</span><br><span class="line">&gt;&gt;&gt; a[0], a[1], a[2] = 4, 5, 6 //改变原来 list 中的元素</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">[4, 5, 6]</span><br><span class="line"># a 的值改变后，b 随着 a 变了</span><br></pre></td></tr></table></figure><p>上面两段代码中，a 的值都发生了变化。区别在于，第一段代码中是直接赋给了 a 新的值（从 [1, 2, 3] 变为 [4, 5, 6]）；而第二段则是把 list 中每个元素分别改变。</p><p>而对 b 的影响则是不同的，一个没有让 b 的值发生改变，另一个变了。怎么用上边的道理来解释这个诡异的不同呢？</p><p>首次把 [1, 2, 3] 看成一个物品。a = [1, 2, 3] 就相当于给这个物品上贴上 a 这个标签。而 b = a 就是给这个物品又贴上了一个 b 的标签。</p><p>第一种情况：</p><p>a = [4, 5, 6] 就相当于把 a 标签从 [1 ,2, 3] 上撕下来，贴到了 [4, 5, 6] 上。</p><p>在这个过程中，[1, 2, 3] 这个物品并没有消失。 b 自始至终都好好的贴在 [1, 2, 3] 上，既然这个 reference 也没有改变过。 b 的值自然不变。</p><p>第二种情况：</p><p>a[0], a[1], a[2] = 4, 5, 6 则是直接改变了 [1, 2, 3] 这个物品本身。把它内部的每一部分都重新改装了一下。内部改装完毕后，[1, 2, 3] 本身变成了 [4, 5, 6]。</p><p>而在此过程当中，a 和 b 都没有动，他们还贴在那个物品上。因此自然 a b 的值都变成了 [4, 5, 6]。</p><p>搞明白这个之后就要问了，<strong>对于一个复杂对象的浅copy，在copy的时候到底发生了什么？</strong><br>再看一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import copy</span><br><span class="line">&gt;&gt;&gt; origin = [1, 2, [3, 4]]</span><br><span class="line">#origin 里边有三个元素：1， 2，[3, 4]</span><br><span class="line">&gt;&gt;&gt; cop1 = copy.copy(origin)</span><br><span class="line">&gt;&gt;&gt; cop2 = copy.deepcopy(origin)</span><br><span class="line">&gt;&gt;&gt; cop1 == cop2</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; cop1 is cop2</span><br><span class="line">False </span><br><span class="line">#cop1 和 cop2 看上去相同，但已不再是同一个object</span><br><span class="line">&gt;&gt;&gt; origin[2][0] = &quot;hey!&quot; </span><br><span class="line">&gt;&gt;&gt; origin</span><br><span class="line">[1, 2, [&#x27;hey!&#x27;, 4]]</span><br><span class="line">&gt;&gt;&gt; cop1</span><br><span class="line">[1, 2, [&#x27;hey!&#x27;, 4]]</span><br><span class="line">&gt;&gt;&gt; cop2</span><br><span class="line">[1, 2, [3, 4]]</span><br><span class="line">#把origin内的子list [3, 4] 改掉了一个元素，观察 cop1 和 cop2</span><br></pre></td></tr></table></figure><p>学过docker的人应该对镜像这个概念不陌生，我们可以把镜像的概念套用在copy上面。</p><p>copy对于一个复杂对象的子对象并不会完全复制，什么是复杂对象的子对象呢？就比如序列里的嵌套序列，字典里的嵌套序列等都是复杂对象的子对象。对于子对象，python会把它当作一个公共镜像存储起来，所有对他的复制都被当成一个引用，所以说当其中一个引用将镜像改变了之后另一个引用使用镜像的时候镜像已经被改变了。</p><p>所以说看这里的origin[2]，也就是 [3, 4] 这个 list。根据 shallow copy 的定义，在 cop1[2] 指向的是同一个 list [3, 4]。那么，如果这里我们改变了这个 list，就会导致 origin 和 cop1 同时改变。这就是为什么上边 origin[2][0] = “hey!” 之后，cop1 也随之变成了 [1, 2, [‘hey!’, 4]]。</p><p>deepcopy的时候会将复杂对象的每一层复制一个单独的个体出来。<br>这时候的 origin[2] 和 cop2[2] 虽然值都等于 [3, 4]，但已经不是同一个 list了。即我们寻常意义上的复制。</p><h2><span id="bian-liang-lei-xing-pan-duan">变量类型判断</span><a href="#bian-liang-lei-xing-pan-duan" class="header-anchor">#</a></h2><blockquote><p>1、isinstance(参数1,参数2)<br><br><br>描述：该函数用来判断一个变量（参数1）是否是已知的变量类型(参数2) 类似于type()</p><p>参数1：变量</p><p>参数2：可以是直接或间接类名、基本类型或者由它们组成的元组。</p><p>返回值: 如果对象的类型与参数二的类型（classinfo）相同则返回 True，否则返回 False</p></blockquote><h2><span id="json-xiang-guan-cao-zuo">json相关操作</span><a href="#json-xiang-guan-cao-zuo" class="header-anchor">#</a></h2><p><strong>dumps和dump 序列化方法</strong><br>dumps只完成了序列化为str，<br>dump必须传文件描述符，将序列化的str保存到文件中<br>下面使用实际的例子依次介绍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">key=&#123; &quot;people&quot;: [</span><br><span class="line">&#123; &quot;Name&quot;: &quot;Brett&quot;, &quot;名字&quot;:&quot;McLaughlin&quot;, &#x27;1&#x27;: 1 &#125;,</span><br><span class="line">&#123; &quot;Name&quot;: &quot;Jason&quot;, &quot;名字&quot;:&quot;Hunter&quot;, &#x27;2&#x27;: 1&#125;,</span><br><span class="line">&#123; &quot;Name&quot;: &quot;Elliotte&quot;, &quot;名字&quot;:&quot;Harold&quot;, &#x27;3&#x27;: 1 &#125;</span><br><span class="line">]&#125;</span><br><span class="line">print(json.dumps(key,sort_keys=True,indent =4,ensure_ascii=False))</span><br></pre></td></tr></table></figure><p>输出效果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;people&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;1&quot;: 1,</span><br><span class="line">            &quot;Name&quot;: &quot;Brett&quot;,</span><br><span class="line">            &quot;名字&quot;: &quot;McLaughlin&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;2&quot;: 1,</span><br><span class="line">            &quot;Name&quot;: &quot;Jason&quot;,</span><br><span class="line">            &quot;名字&quot;: &quot;Hunter&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;3&quot;: 1,</span><br><span class="line">            &quot;Name&quot;: &quot;Elliotte&quot;,</span><br><span class="line">            &quot;名字&quot;: &quot;Harold&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常简便的将所需要的数据流畅的保存下来了，下面我们介绍相关的参数：<br>（1）indent=4：缩进，python中默认缩进是4个，前端和css默认是2个<br>（2）sort_keys=True/False：以key为标准，按key的a-z字母排序<br>（3）separators=(‘，’，‘：’)：减少空格，增加传输速度，参数是要保留的标点符号，json只保留 逗号和冒号就行。<br>下面我们将其保存在json的文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">with open(&quot;E:\\测试.json&quot;, &quot;w+&quot;,encoding=&#x27;utf-8_sig&#x27;)as f:</span><br><span class="line">    json.dump(key,f,sort_keys=True,indent =4,ensure_ascii=False)</span><br><span class="line"> </span><br><span class="line">//另外一种写法</span><br><span class="line">f= open(&quot;E:\\测试.json&quot;, &quot;w&quot;,encoding=&#x27;utf-8_sig&#x27;)  //可能会报encoding的相关错，去掉就好</span><br></pre></td></tr></table></figure><p><strong>loads和load 反序列化方法</strong><br>loads 只完成了反序列化，<br>load 只接收文件描述符，完成了读取文件和反序列化<br>同样用上述例子介绍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key_1=json.dumps(key,sort_keys=True,indent =4,ensure_ascii=False)</span><br><span class="line">print(json.loads(key_1))</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;people&#x27;: [&#123;&#x27;1&#x27;: 1, &#x27;Name&#x27;: &#x27;Brett&#x27;, &#x27;名字&#x27;: &#x27;McLaughlin&#x27;&#125;, &#123;&#x27;2&#x27;: 1, &#x27;Name&#x27;: &#x27;Jason&#x27;, &#x27;名字&#x27;: &#x27;Hunter&#x27;&#125;, &#123;&#x27;3&#x27;: 1, &#x27;Name&#x27;: &#x27;Elliotte&#x27;, &#x27;名字&#x27;: &#x27;Harold&#x27;&#125;]&#125;</span><br></pre></td></tr></table></figure><p>即将其反输出<br>下面读取json文件也是一样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&quot;E:\\测试.json&quot;, &quot;r+&quot;,encoding=&#x27;utf-8_sig&#x27;)as f:</span><br><span class="line">    data=json.load(f)</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure><h2><span id="zi-dian-xiang-guan-cao-zuo">字典相关操作</span><a href="#zi-dian-xiang-guan-cao-zuo" class="header-anchor">#</a></h2><h3><span id="ru-he-jian-cha-zi-dian-python-zhong-shi-fou-cun-zai-mou-ge-zhi">如何检查字典(Python)中是否存在某个值</span><a href="#ru-he-jian-cha-zi-dian-python-zhong-shi-fou-cun-zai-mou-ge-zhi" class="header-anchor">#</a></h3><p>d = {‘1’: ‘one’, ‘3’: ‘three’, ‘2’: ‘two’, ‘5’: ‘five’, ‘4’: ‘four’}</p><p>我需要一种方法来找出这个字典中是否存在诸如“one”或“two”这样的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&#x27;1&#x27;: &#x27;one&#x27;, &#x27;3&#x27;: &#x27;three&#x27;, &#x27;2&#x27;: &#x27;two&#x27;, &#x27;5&#x27;: &#x27;five&#x27;, &#x27;4&#x27;: &#x27;four&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; &#x27;one&#x27; in d.values()</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h2><span id="qiang-zhi-jie-shu-cheng-xu">强制结束程序</span><a href="#qiang-zhi-jie-shu-cheng-xu" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.exit()</span><br></pre></td></tr></table></figure><h2><span id="python-zhi-xing-shell-jiao-ben">python执行shell脚本</span><a href="#python-zhi-xing-shell-jiao-ben" class="header-anchor">#</a></h2><h3><span id="os-system-command">os.system(“command”)</span><a href="#os-system-command" class="header-anchor">#</a></h3><p>这是python自带的执行shell命令的方法，其中最后一个0是这个命令的返回值，为0表示命令执行成功。但是使用system()无法将执行的结果保存起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">print(os.system(&quot;touch a.txt&quot;)) //需要用引号将命令括起来</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="os-popen-command-fang-fa">os.popen(“command”)方法</span><a href="#os-popen-command-fang-fa" class="header-anchor">#</a></h3><p>上面的os.system()方法没办法查看shell命令返回的结果，通过 os.popen() 返回的是 file read 的对象，对其进行读取 read() 的操作可以看到执行的输出。</p><p>注意：os.popen() 返回的是一个文件对象f哦！！！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">f=os.popen(&quot;ls -l&quot;)  # 返回的是一个文件对象</span><br><span class="line">print(f.read())            # 通过文件的read()读取所返回的内容</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r-- 1 tengjian tengjian  0 11月  5 09:32 a.txt</span><br><span class="line">-rw-rw-r-- 1 tengjian tengjian 81 11月  5 09:32 python_shell.py</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>对于有返回值的shell命令，建议使用 os.popen()<br>对于没有返回值的shell命令，建议使用 os.system()</strong></p><h1><span id="zhi-shi-dian">知识点</span><a href="#zhi-shi-dian" class="header-anchor">#</a></h1><h2><span id="from-import-he-import-de-qu-bie">from import和import的区别</span><a href="#from-import-he-import-de-qu-bie" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import Module # 引入模块</span><br><span class="line">from Module import Other # 引入模块中的类、函数或者变量</span><br><span class="line">from Module import * # 引入模块中的所有‘公开’成员</span><br></pre></td></tr></table></figure><br><p><strong>举例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from datetime import datetime</span><br><span class="line"></span><br><span class="line">#引入 datetime 模块中的 datetime 类,然后就可以通过datetime这个类调用now() 方法了</span><br><span class="line"></span><br><span class="line">#即,内部可以通过datetime.now()来调用</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">#引入datetime 模块,然后通过这个模块来调用模块中的类datetime和类datetime中的方法now()</span><br><span class="line"></span><br><span class="line">#即：内部可以通过datetime.datetime.now()来调用</span><br><span class="line"></span><br><span class="line">也就是说，有一个模块datetime,这个模块中有一个类datetime,在这个类中有一个方法now()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;suo-yu-wen-ti&quot;&gt;所遇问题&lt;/span&gt;&lt;a href=&quot;#suo-yu-wen-ti&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;shu-chu-ge-shi-you-wen-ti&quot;&gt;输出</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>前端知识</title>
    <link href="http://example.com/2022/01/14/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2022/01/14/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/</id>
    <published>2022-01-13T16:00:00.000Z</published>
    <updated>2022-01-16T15:13:51.346Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="react">React</span><a href="#react" class="header-anchor">#</a></h1><h2><span id="qi-dong-liu-cheng">启动流程</span><a href="#qi-dong-liu-cheng" class="header-anchor">#</a></h2><p>重点关注三个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">src/App.js //实现 React 组件</span><br><span class="line"></span><br><span class="line">src/index.js // React 世界的入口</span><br><span class="line"></span><br><span class="line">public/index.html //挂载的页面</span><br></pre></td></tr></table></figure><p>1.index.html</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个是一个模板文件，里面有过id为root的div标签，会被index.js文件中的JSX替换这个DOM节点。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c8637d56e86b4868a275d4a01a1db9c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>2.index.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">关键就是这个ReactDOM.render()</span><br><span class="line"></span><br><span class="line">简单来说，ReactDOM.render() 会使用你的 JSX 来替换你的 HTML 中的一个 DOM 节点。这</span><br><span class="line">样你就可以很容易地把 React 集成到每一个其他的应用中。ReactDOM.render() 可以在你的</span><br><span class="line">应用中被多次使用。你可以在多个地方使用它来加载简单的 JSX 语法、单个 React 组件、</span><br><span class="line">多个 React 组件或者整个应用。但是在一个纯 React 的应用中，你只会使用一次用来加载你</span><br><span class="line">的整个组件树。</span><br><span class="line">ReactDOM.render() 有两个传入参数。第一个是准备渲染的 JSX。第二个参数指定了 React</span><br><span class="line">应用在你的 HTML 中的放置的位置。这个位置是一个 id=&#x27;root&#x27; 的元素。你可以在文件</span><br><span class="line">public/index.html 中找到这个 id 属性</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5a6381d4f99b4a56b00f07e3ee28f9c7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>3.App.js<br>在inde.js文件里面，ReactDOM.render() 总会很好地渲染你的 App 组件。一般来说，某个组件叫xxx，那么他的代码就叫xxx.js。要想知道页面被渲染成什么样，就看看里面内容。<br><img src="https://img-blog.csdnimg.cn/378a772ce66d41e9b70b563c6319a470.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2><span id="react-router-dom-lu-you">react-router-dom路由</span><a href="#react-router-dom-lu-you" class="header-anchor">#</a></h2><p><a href="https://www.jianshu.com/p/8954e9fb0c7e">原文章链接</a><br>来源：简书</p><p><strong>使用背景：使用React构建的单页面应用，要想实现页面间的跳转，首先想到的就是使用路由。在React中，常用的有两个包可以实现这个需求，那就是react-router和react-router-dom。本文主要针对react-router-dom进行说明。</strong></p><h3><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor">#</a></h3><p>首先进入项目目录，使用npm安装react-router-dom：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install react-router-dom --save-dev //这里可以使用cnpm代替npm命令；</span><br><span class="line"></span><br><span class="line">//--save-dev 标记表示该 node 包只是用作开发环境的一部分，并不会被作为你产品代码的一</span><br><span class="line">部分发布。哪种 node 包适用这个场景呢？设想你需要一些 node 包辅助测试你的应用，然</span><br><span class="line">后需要通过 npm 来安装这些包，但是不希望他们混入产品代码里面。测试过程应该只会发</span><br><span class="line">生在开发阶段，而不是在线上部署运行的时候。因为那个时候已经用不到测试代码了，你</span><br><span class="line">的应用应该已经被测试完而且可以被你的用户使用了。这可能是你唯一的使用 --save-dev</span><br><span class="line">的场景。</span><br></pre></td></tr></table></figure><h3><span id="ji-ben-cao-zuo">基本操作</span><a href="#ji-ben-cao-zuo" class="header-anchor">#</a></h3><p>然后我们新建两个页面，分别命名为“home”和“detail”。在页面中编写如下代码：<br>detail.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default class Home extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a&gt;去detail&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>home.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default class Home extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a&gt;回到home&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再新建一个路由组件，命名为“Router.js”，并编写如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123;HashRouter, Route, Switch&#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line">import Home from &#x27;../home&#x27;;</span><br><span class="line">import Detail from &#x27;../detail&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const BasicRoute = () =&gt; (</span><br><span class="line">    &lt;HashRouter&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route exact path=&quot;/detail&quot; component=&#123;Detail&#125;/&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">    &lt;/HashRouter&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">export default BasicRoute;</span><br></pre></td></tr></table></figure><p>如上代码定义了一个纯路由组件，将两个页面组件Home和Detail使用Route组件包裹，外面套用Switch作路由匹配，当路由组件检测到地址栏与Route的path匹配时，就会自动加载响应的页面。<br>然后在入口文件中——我这里指定的是index.js——编写如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">import Router from &#x27;./router/router&#x27;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Router/&gt;,</span><br><span class="line">  document.getElementById(&#x27;root&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这里相当于向页面返回了一个路由组件。我们先运行项目看一下效果，在地址栏输入“<a href="http://localhost:3000/#/%E2%80%9D%EF%BC%9A">http://localhost:3000/#/”：</a><br><img src="https://img-blog.csdnimg.cn/37aee935c7534aa39a98acfcf884e278.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>输入“<a href="http://localhost:3000/#/detail%E2%80%9D%EF%BC%9A">http://localhost:3000/#/detail”：</a><br><img src="https://img-blog.csdnimg.cn/891f1a191f764e2295b057870300cd76.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>通过a标签跳转</strong><br>可以看到其实路由已经开始工作了，接下来我们再来做页面间的跳转。在home.js和detail.js中，我们修改如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    export default class Home extends React.Component &#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                &lt;a href=&#x27;#/detail&#x27;&gt;去detail&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>home.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default class Home extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a href=&#x27;#/&#x27;&gt;回到home&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新打包运行，在浏览器地址栏输入“<a href="http://localhost:3000/%E2%80%9D%EF%BC%8C%E8%AF%95%E8%AF%95%E7%9C%8B%E9%A1%B5%E9%9D%A2%E8%83%BD%E5%90%A6%E6%AD%A3%E5%B8%B8%E8%B7%B3%E8%BD%AC%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%8D%E8%83%BD%EF%BC%8C%E8%AF%B7%E6%8C%89%E6%AD%A5%E9%AA%A4%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%A3%80%E6%9F%A5%E4%BB%A3%E7%A0%81%E6%98%AF%E5%90%A6%E6%9C%89%E8%AF%AF%E3%80%82%E4%BB%A5%E4%B8%8A%E6%98%AF%E4%BD%BF%E7%94%A8a%E6%A0%87%E7%AD%BE%E7%9A%84href%E8%BF%9B%E8%A1%8C%E9%A1%B5%E9%9D%A2%E9%97%B4%E8%B7%B3%E8%BD%AC%EF%BC%8C%E6%AD%A4%E5%A4%96react-router-dom%E8%BF%98%E6%8F%90%E4%BE%9B%E4%BA%86%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E8%B7%B3%E8%BD%AC%E9%A1%B5%E9%9D%A2%E3%80%82">http://localhost:3000/”，试试看页面能否正常跳转。如果不能，请按步骤一步一步检查代码是否有误。以上是使用a标签的href进行页面间跳转，此外react-router-dom还提供了通过函数的方式跳转页面。</a></p><p><strong>通过函数跳转</strong></p><p>首先我们需要修改router.js中的两处代码：<br>然后在home.js中：<br>import React from ‘react’;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">import &#123;HashRouter, Route, Switch, hashHistory&#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line">...</span><br><span class="line">&lt;HashRouter history=&#123;hashHistory&#125;&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在a标签下面添加一个按钮并加上onClick事件，通过this.props.history.push这个函数跳转到detail页面。在路由组件中加入的代码就是将history这个对象注册到组件的props中去，然后就可以在子组件中通过props调用history的push方法跳转页面。</p><p>很多场景下，我们还需要在页面跳转的同时传递参数，在react-router-dom中，同样提供了两种方式进行传参。</p><p>链接：<a href="https://www.jianshu.com/p/8954e9fb0c7e">https://www.jianshu.com/p/8954e9fb0c7e</a><br>来源：简书</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default class Home extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a href=&#x27;#/detail&#x27;&gt;去detail&lt;/a&gt;</span><br><span class="line">                &lt;button onClick=&#123;() =&gt; this.props.history.push(&#x27;detail&#x27;)&#125;&gt;通过函数跳转&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>url传参</strong><br>在router.js中，修改如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;Route exact path=&quot;/detail/:id&quot; component=&#123;Detail&#125;/&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后修改detail.js，使用this.props.match.params获取url传过来的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">    console.log(this.props.match.params);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在地址栏输入“<a href="http://localhost:3000/#/detail/3%E2%80%9D%EF%BC%8C%E6%89%93%E5%BC%80%E6%8E%A7%E5%88%B6%E5%8F%B0%EF%BC%9A">http://localhost:3000/#/detail/3”，打开控制台：</a><br><img src="https://img-blog.csdnimg.cn/d803a9af4817410c8649c09bbf06cdea.png" alt="在这里插入图片描述"><br>可以看到传过去的id=3已经被获取到了。react-router-dom就是通过“/:”去匹配url传递的参数。</p><p><strong>隐式传参</strong><br>此外还可以通过push函数隐式传参。</p><p>修改home.js代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default class Home extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a href=&#x27;#/detail/3&#x27;&gt;去detail&lt;/a&gt;</span><br><span class="line">                    &lt;button onClick=&#123;() =&gt; this.props.history.push(&#123;</span><br><span class="line">                        pathname: &#x27;/detail&#x27;,</span><br><span class="line">                        state: &#123;</span><br><span class="line">                            id: 3</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)&#125;&gt;通过函数跳转&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在detail.js中，就可以使用this.props.history.location.state获取home传过来的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    //console.log(this.props.match.params);</span><br><span class="line">    console.log(this.props.history.location.state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳转后打开控制台可以看到参数被打印：<br><img src="https://img-blog.csdnimg.cn/972fb5894c804e8c9203fc6d304cf0c5.png" alt="在这里插入图片描述"><br><strong>嵌套路由</strong></p><p>嵌套路由的适用场景还是比较多的，接下来就来介绍一下实现方法。<br>首先在Vue中实现嵌套路由，只需要将配置文件写成children嵌套，然后在需要展示子路由的位置加上<router-view></router-view>即可。React中应该如何实现呢？其实原理和Vue类似，只需要在父级路由中包含子路由即可。这样说可能很多同学会一头雾水，直接上代码（不使用上面的例子）：</p><p>首先定义父级组件MainLayout</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#x27;./MainLayout.scss&#x27;;</span><br><span class="line"></span><br><span class="line">const &#123; Header, Sider, Content &#125; = Layout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default class MainLayout extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&#x27;main-layout&#x27;&gt;</span><br><span class="line">                父组件</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义子组件Home：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;useState&#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123;Modal, Select&#125; from &quot;antd&quot;;</span><br><span class="line">import &#123;connect&#125; from &#x27;react-redux&#x27;;</span><br><span class="line">import &#123;addCount&#125; from &#x27;../../servers/home&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Home(props) &#123;</span><br><span class="line">    const [visible, setVisible] = useState(false);</span><br><span class="line">    const &#123;countNum: &#123;count&#125;, dispatch&#125; = props;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            子组件</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Home;</span><br></pre></td></tr></table></figure><p>然后将它们添加进路由router.js，并且关联父子关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123;HashRouter, Route, Switch&#125; from &quot;react-router-dom&quot;;</span><br><span class="line">import Home from &#x27;../pages/Home/Home&#x27;;</span><br><span class="line">import MainLayout from &#x27;../layout/MainLayout&#x27;;</span><br><span class="line"></span><br><span class="line">const BasicRouter = () =&gt; (</span><br><span class="line">    &lt;HashRouter&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=&quot;/index&quot; component=&#123;</span><br><span class="line">                &lt;MainLayout&gt;</span><br><span class="line">                  &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">                  &lt;Route exact path=&quot;/index&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">                  &lt;Route path=&quot;/index/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">                &lt;/MainLayout&gt;</span><br><span class="line">             &#125;/&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">    &lt;/HashRouter&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default BasicRouter;</span><br></pre></td></tr></table></figure><p>在MainLayout中，修改如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#x27;./MainLayout.scss&#x27;;</span><br><span class="line"></span><br><span class="line">const &#123; Header, Sider, Content &#125; = Layout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default class MainLayout extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&#x27;main-layout&#x27;&gt;</span><br><span class="line">                &#123;this.props.children&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，一个嵌套路由就完成了。</p><h1><span id="javascript">Javascript</span><a href="#javascript" class="header-anchor">#</a></h1><h2><span id="jian-tou-han-shu">箭头函数</span><a href="#jian-tou-han-shu" class="header-anchor">#</a></h2><p>箭头函数本质还是函数，我们来看看他与JavaScript中普通函数的区别，先看看写法上的区别。<br><img src="https://img-blog.csdnimg.cn/2b6243000b0d48f69f6baf1e77293818.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>解释</strong><br>写箭头函数，我们记住一个顺序就好，参数、箭头、函数体、这个顺序记住就足够了，参数、箭头、函数体、这三个是必须的，函数名可以没有，但这三项必须有，一些简写的方式也是简写这三项里的东西。</p><p><strong>简写</strong><br>1、只有一个参数时，() 可省略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//不简写</span><br><span class="line">var demo = (x) =&gt;&#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//简写</span><br><span class="line">var demo = x =&gt;&#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、函数体只有一句时， {} 可以省略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//不简写</span><br><span class="line">var demo = (x) =&gt;&#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//简写</span><br><span class="line">var demo = x =&gt; console.log(x);</span><br></pre></td></tr></table></figure><p>3、函数体只有一条返回语句时，{} 和 return 都可以省略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//不简写</span><br><span class="line">var demo = (x) =&gt; &#123;</span><br><span class="line">     return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//简写</span><br><span class="line">var demo = (x) =&gt; x;   </span><br><span class="line"></span><br><span class="line">//注意别写成这样  </span><br><span class="line">var demo = (x) =&gt;&#123; x &#125;;  </span><br><span class="line">//或者 这样  </span><br><span class="line">var demo = (x) =&gt; return  x;  </span><br><span class="line">//要省略就都省略，不省略就都不省，别省一半,不然会出错的。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>箭头函数放 参数 的地方就在 () 内，<br>没有参数，() 必须写，<br>一个参数，() 可写可不写，<br>多个参数，() 必须写。</p><p>箭头函数放 函数体 的地方在 {}内，<br>函数体 就 一句 {} 可写可不写，<br>函数体 不止一句，{} 必须写。</p><p>如果不知道，() {} 写不写，该不该省略，那就写，写了不会错。</p><p><strong>箭头函数 如果要返回一个对象，要简写的话， 需要用()包住这个对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//不简写</span><br><span class="line">var demo = () =&gt;&#123; </span><br><span class="line">    return &#123;x:1&#125;;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">//简写</span><br><span class="line">var demo = () =&gt;(&#123;x:1&#125;);</span><br></pre></td></tr></table></figure><p>为什么会这样？因为如果不加 () ，那{ } 就表示的是语法块，不是表示一个对象，而加上()，按照规范来说，() 里面 { } 就会被解析为对象了。</p><p>对于 {x:1} 这个情况，他不仅可以表示一个对象，这个对象有个x属性，值为1，也可以表示为语法块中含有 名为 x 的 label，忘记 label语法的话，可以看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label">这里</a><br>如果不是很明白，可以看看这个<a href="https://www.zhihu.com/question/40902815">回答</a>，应该会理解的更加深刻。<br>所以这也解释了为什么会出现下面代码中的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 不报错</span><br><span class="line">var demo = () =&gt;&#123;x:1&#125;;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">var demo = (y) =&gt;&#123;y,x:1&#125;;</span><br></pre></td></tr></table></figure><p><strong>对象的方法用 箭头函数写时，this 的指向 可能和你想的不一样</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.name=&#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">    show_name:() =&gt;&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">obj.show_name(); //window</span><br></pre></td></tr></table></figure><p>JavaScript使用的是函数作用域，在上面这段代码中对象的括号是不能封闭作用域的，所以此时的this还是指向window。<br>我们换成普通函数看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.name=&#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">    show_name: function ()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">obj.show_name();  //obj</span><br></pre></td></tr></table></figure><p>换成普通函数，this 就不是指向window，而是指向 obj 对象了</p><p>箭头函数 与 普通函数 其他的区别</p><blockquote><p>1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。<br> 2、箭头函数 this不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。<br>  3、箭头函数 不能用 new关键字来实例化对象，不然会报错。<br>  4、箭头函数没有arguments对象。</p></blockquote><p>1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.name = &#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">    show_name:function ()&#123;</span><br><span class="line">        function fn ()&#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.show_name();  // window</span><br></pre></td></tr></table></figure><p>声明一个 obj 对象，有一个name属性 与 show_name方法，上面这段代码，我的本意是想显示 obj对象的name， 但是没和我想的一样，一般我们会用 一个变量 self 或者 that 之类的留住this,像这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">window.name = &#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">    show_name:function ()&#123;</span><br><span class="line">        //留住this</span><br><span class="line">        var that = this;</span><br><span class="line">        function fn ()&#123;</span><br><span class="line">            console.log(that.name);</span><br><span class="line">        &#125;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.show_name();  //obj</span><br></pre></td></tr></table></figure><p>通常来说，箭头函数内部的this就是外层代码块的this</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.name = &#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">    show_name:function ()&#123;</span><br><span class="line">        var fn = () =&gt; &#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.show_name(); //obj</span><br></pre></td></tr></table></figure><p>2、箭头函数 this 不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.name = &#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">function show_name()&#123;</span><br><span class="line">    //这里 show_name 是一个普通的全局函数，所以他的this指window</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">//用了 call 方法，把 show_nam 的this 指向了 obj 对象</span><br><span class="line">show_name.call(obj);  //obj</span><br></pre></td></tr></table></figure><p>箭头函数 this 不可变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.name = &#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">var show_name = () =&gt; &#123;</span><br><span class="line">    //这里 show_name 是箭头函数，他的this指window，并且不会变</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">//用了 call 方法，但是 this 没变，所以打印了 window</span><br><span class="line">show_name.call(obj);  //window</span><br></pre></td></tr></table></figure><p>3、箭头函数 不能用 new 关键字来实例化对象，不然会报错，箭头函数的this 不可变，new 也改变不了 this的 指向，而且更为重要的是，箭头函数内部并没有 [[Construct]] 方法，所以会没有原型属性（prototype），所以箭头函数没法当构造函数。</p><p><img src="https://img-blog.csdnimg.cn/7803115884ae4f6ab5f8d4cd73cfe038.png" alt="在这里插入图片描述"><br>4、箭头函数没有arguments对象，不能通过arguments对象访问传入参数，但是可以用rest参数实现<br>。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters">不了解的看这里</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var demo = (...theArgs) =&gt; theArgs;</span><br><span class="line">demo(1,2,3); //[1,2,3]</span><br></pre></td></tr></table></figure><p><strong>总结</strong><br>在来看一遍 箭头函数 与 普通函数，除了写法上的区别</p><blockquote><p>1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。<br>2、箭头函数 this不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。<br>3、箭头函数 不能用 new关键字来实例化对象，不然会报错。<br>4、箭头函数没有arguments对象。</p></blockquote><p>可以看出，最重要的区别还是 在 this 上，所以要想用好 箭头函数，还是要对 this 有一定认识的。</p><h1><span id="html">Html</span><a href="#html" class="header-anchor">#</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;react&quot;&gt;React&lt;/span&gt;&lt;a href=&quot;#react&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;qi-dong-liu-cheng&quot;&gt;启动流程&lt;/span&gt;&lt;a href=&quot;#qi-d</summary>
      
    
    
    
    <category term="前端开发" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
