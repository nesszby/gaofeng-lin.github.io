<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Welcome to my Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-15T07:47:11.320Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Gaofeng Lin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端知识</title>
    <link href="http://example.com/2022/01/15/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2022/01/15/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86/</id>
    <published>2022-01-15T07:40:47.822Z</published>
    <updated>2022-01-15T07:47:11.320Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#react">React</a><ul><li><a href="#qi-dong-liu-cheng">启动流程</a></li><li><a href="#react-router-dom-lu-you">react-router-dom路由</a><ul><li><a href="#an-zhuang">安装</a></li><li><a href="#ji-ben-cao-zuo">基本操作</a></li></ul></li></ul></li><li><a href="#javascript">Javascript</a><ul><li><a href="#jian-tou-han-shu">箭头函数</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="react">React</span><a href="#react" class="header-anchor">#</a></h1><h2><span id="qi-dong-liu-cheng">启动流程</span><a href="#qi-dong-liu-cheng" class="header-anchor">#</a></h2><p>重点关注三个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">src/App.js //实现 React 组件</span><br><span class="line"></span><br><span class="line">src/index.js // React 世界的入口</span><br><span class="line"></span><br><span class="line">public/index.html //挂载的页面</span><br></pre></td></tr></table></figure><p>1.index.html</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个是一个模板文件，里面有过id为root的div标签，会被index.js文件中的JSX替换这个DOM节点。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c8637d56e86b4868a275d4a01a1db9c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>2.index.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">关键就是这个ReactDOM.render()</span><br><span class="line"></span><br><span class="line">简单来说，ReactDOM.render() 会使用你的 JSX 来替换你的 HTML 中的一个 DOM 节点。这</span><br><span class="line">样你就可以很容易地把 React 集成到每一个其他的应用中。ReactDOM.render() 可以在你的</span><br><span class="line">应用中被多次使用。你可以在多个地方使用它来加载简单的 JSX 语法、单个 React 组件、</span><br><span class="line">多个 React 组件或者整个应用。但是在一个纯 React 的应用中，你只会使用一次用来加载你</span><br><span class="line">的整个组件树。</span><br><span class="line">ReactDOM.render() 有两个传入参数。第一个是准备渲染的 JSX。第二个参数指定了 React</span><br><span class="line">应用在你的 HTML 中的放置的位置。这个位置是一个 id=&#x27;root&#x27; 的元素。你可以在文件</span><br><span class="line">public/index.html 中找到这个 id 属性</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5a6381d4f99b4a56b00f07e3ee28f9c7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>3.App.js<br>在inde.js文件里面，ReactDOM.render() 总会很好地渲染你的 App 组件。一般来说，某个组件叫xxx，那么他的代码就叫xxx.js。要想知道页面被渲染成什么样，就看看里面内容。<br><img src="https://img-blog.csdnimg.cn/378a772ce66d41e9b70b563c6319a470.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2><span id="react-router-dom-lu-you">react-router-dom路由</span><a href="#react-router-dom-lu-you" class="header-anchor">#</a></h2><p><a href="https://www.jianshu.com/p/8954e9fb0c7e">原文章链接</a><br>来源：简书</p><p><strong>使用背景：使用React构建的单页面应用，要想实现页面间的跳转，首先想到的就是使用路由。在React中，常用的有两个包可以实现这个需求，那就是react-router和react-router-dom。本文主要针对react-router-dom进行说明。</strong></p><h3><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor">#</a></h3><p>首先进入项目目录，使用npm安装react-router-dom：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install react-router-dom --save-dev //这里可以使用cnpm代替npm命令；</span><br><span class="line"></span><br><span class="line">//--save-dev 标记表示该 node 包只是用作开发环境的一部分，并不会被作为你产品代码的一</span><br><span class="line">部分发布。哪种 node 包适用这个场景呢？设想你需要一些 node 包辅助测试你的应用，然</span><br><span class="line">后需要通过 npm 来安装这些包，但是不希望他们混入产品代码里面。测试过程应该只会发</span><br><span class="line">生在开发阶段，而不是在线上部署运行的时候。因为那个时候已经用不到测试代码了，你</span><br><span class="line">的应用应该已经被测试完而且可以被你的用户使用了。这可能是你唯一的使用 --save-dev</span><br><span class="line">的场景。</span><br></pre></td></tr></table></figure><h3><span id="ji-ben-cao-zuo">基本操作</span><a href="#ji-ben-cao-zuo" class="header-anchor">#</a></h3><p>然后我们新建两个页面，分别命名为“home”和“detail”。在页面中编写如下代码：<br>detail.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default class Home extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a&gt;去detail&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>home.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default class Home extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a&gt;回到home&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再新建一个路由组件，命名为“Router.js”，并编写如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123;HashRouter, Route, Switch&#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line">import Home from &#x27;../home&#x27;;</span><br><span class="line">import Detail from &#x27;../detail&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const BasicRoute = () =&gt; (</span><br><span class="line">    &lt;HashRouter&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route exact path=&quot;/detail&quot; component=&#123;Detail&#125;/&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">    &lt;/HashRouter&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">export default BasicRoute;</span><br></pre></td></tr></table></figure><p>如上代码定义了一个纯路由组件，将两个页面组件Home和Detail使用Route组件包裹，外面套用Switch作路由匹配，当路由组件检测到地址栏与Route的path匹配时，就会自动加载响应的页面。<br>然后在入口文件中——我这里指定的是index.js——编写如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">import Router from &#x27;./router/router&#x27;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Router/&gt;,</span><br><span class="line">  document.getElementById(&#x27;root&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这里相当于向页面返回了一个路由组件。我们先运行项目看一下效果，在地址栏输入“<a href="http://localhost:3000/#/%E2%80%9D%EF%BC%9A">http://localhost:3000/#/”：</a><br><img src="https://img-blog.csdnimg.cn/37aee935c7534aa39a98acfcf884e278.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>输入“<a href="http://localhost:3000/#/detail%E2%80%9D%EF%BC%9A">http://localhost:3000/#/detail”：</a><br><img src="https://img-blog.csdnimg.cn/891f1a191f764e2295b057870300cd76.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>通过a标签跳转</strong><br>可以看到其实路由已经开始工作了，接下来我们再来做页面间的跳转。在home.js和detail.js中，我们修改如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    export default class Home extends React.Component &#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                &lt;a href=&#x27;#/detail&#x27;&gt;去detail&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>home.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default class Home extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a href=&#x27;#/&#x27;&gt;回到home&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新打包运行，在浏览器地址栏输入“<a href="http://localhost:3000/%E2%80%9D%EF%BC%8C%E8%AF%95%E8%AF%95%E7%9C%8B%E9%A1%B5%E9%9D%A2%E8%83%BD%E5%90%A6%E6%AD%A3%E5%B8%B8%E8%B7%B3%E8%BD%AC%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%8D%E8%83%BD%EF%BC%8C%E8%AF%B7%E6%8C%89%E6%AD%A5%E9%AA%A4%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%A3%80%E6%9F%A5%E4%BB%A3%E7%A0%81%E6%98%AF%E5%90%A6%E6%9C%89%E8%AF%AF%E3%80%82%E4%BB%A5%E4%B8%8A%E6%98%AF%E4%BD%BF%E7%94%A8a%E6%A0%87%E7%AD%BE%E7%9A%84href%E8%BF%9B%E8%A1%8C%E9%A1%B5%E9%9D%A2%E9%97%B4%E8%B7%B3%E8%BD%AC%EF%BC%8C%E6%AD%A4%E5%A4%96react-router-dom%E8%BF%98%E6%8F%90%E4%BE%9B%E4%BA%86%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E8%B7%B3%E8%BD%AC%E9%A1%B5%E9%9D%A2%E3%80%82">http://localhost:3000/”，试试看页面能否正常跳转。如果不能，请按步骤一步一步检查代码是否有误。以上是使用a标签的href进行页面间跳转，此外react-router-dom还提供了通过函数的方式跳转页面。</a></p><p><strong>通过函数跳转</strong></p><p>首先我们需要修改router.js中的两处代码：<br>然后在home.js中：<br>import React from ‘react’;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">import &#123;HashRouter, Route, Switch, hashHistory&#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line">...</span><br><span class="line">&lt;HashRouter history=&#123;hashHistory&#125;&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在a标签下面添加一个按钮并加上onClick事件，通过this.props.history.push这个函数跳转到detail页面。在路由组件中加入的代码就是将history这个对象注册到组件的props中去，然后就可以在子组件中通过props调用history的push方法跳转页面。</p><p>很多场景下，我们还需要在页面跳转的同时传递参数，在react-router-dom中，同样提供了两种方式进行传参。</p><p>链接：<a href="https://www.jianshu.com/p/8954e9fb0c7e">https://www.jianshu.com/p/8954e9fb0c7e</a><br>来源：简书</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default class Home extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a href=&#x27;#/detail&#x27;&gt;去detail&lt;/a&gt;</span><br><span class="line">                &lt;button onClick=&#123;() =&gt; this.props.history.push(&#x27;detail&#x27;)&#125;&gt;通过函数跳转&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>url传参</strong><br>在router.js中，修改如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;Route exact path=&quot;/detail/:id&quot; component=&#123;Detail&#125;/&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后修改detail.js，使用this.props.match.params获取url传过来的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">    console.log(this.props.match.params);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在地址栏输入“<a href="http://localhost:3000/#/detail/3%E2%80%9D%EF%BC%8C%E6%89%93%E5%BC%80%E6%8E%A7%E5%88%B6%E5%8F%B0%EF%BC%9A">http://localhost:3000/#/detail/3”，打开控制台：</a><br><img src="https://img-blog.csdnimg.cn/d803a9af4817410c8649c09bbf06cdea.png" alt="在这里插入图片描述"><br>可以看到传过去的id=3已经被获取到了。react-router-dom就是通过“/:”去匹配url传递的参数。</p><p><strong>隐式传参</strong><br>此外还可以通过push函数隐式传参。</p><p>修改home.js代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default class Home extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a href=&#x27;#/detail/3&#x27;&gt;去detail&lt;/a&gt;</span><br><span class="line">                    &lt;button onClick=&#123;() =&gt; this.props.history.push(&#123;</span><br><span class="line">                        pathname: &#x27;/detail&#x27;,</span><br><span class="line">                        state: &#123;</span><br><span class="line">                            id: 3</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)&#125;&gt;通过函数跳转&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在detail.js中，就可以使用this.props.history.location.state获取home传过来的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    //console.log(this.props.match.params);</span><br><span class="line">    console.log(this.props.history.location.state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳转后打开控制台可以看到参数被打印：<br><img src="https://img-blog.csdnimg.cn/972fb5894c804e8c9203fc6d304cf0c5.png" alt="在这里插入图片描述"><br><strong>嵌套路由</strong></p><p>嵌套路由的适用场景还是比较多的，接下来就来介绍一下实现方法。<br>首先在Vue中实现嵌套路由，只需要将配置文件写成children嵌套，然后在需要展示子路由的位置加上<router-view></router-view>即可。React中应该如何实现呢？其实原理和Vue类似，只需要在父级路由中包含子路由即可。这样说可能很多同学会一头雾水，直接上代码（不使用上面的例子）：</p><p>首先定义父级组件MainLayout</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#x27;./MainLayout.scss&#x27;;</span><br><span class="line"></span><br><span class="line">const &#123; Header, Sider, Content &#125; = Layout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default class MainLayout extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&#x27;main-layout&#x27;&gt;</span><br><span class="line">                父组件</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义子组件Home：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;useState&#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123;Modal, Select&#125; from &quot;antd&quot;;</span><br><span class="line">import &#123;connect&#125; from &#x27;react-redux&#x27;;</span><br><span class="line">import &#123;addCount&#125; from &#x27;../../servers/home&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Home(props) &#123;</span><br><span class="line">    const [visible, setVisible] = useState(false);</span><br><span class="line">    const &#123;countNum: &#123;count&#125;, dispatch&#125; = props;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            子组件</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Home;</span><br></pre></td></tr></table></figure><p>然后将它们添加进路由router.js，并且关联父子关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123;HashRouter, Route, Switch&#125; from &quot;react-router-dom&quot;;</span><br><span class="line">import Home from &#x27;../pages/Home/Home&#x27;;</span><br><span class="line">import MainLayout from &#x27;../layout/MainLayout&#x27;;</span><br><span class="line"></span><br><span class="line">const BasicRouter = () =&gt; (</span><br><span class="line">    &lt;HashRouter&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=&quot;/index&quot; component=&#123;</span><br><span class="line">                &lt;MainLayout&gt;</span><br><span class="line">                  &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">                  &lt;Route exact path=&quot;/index&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">                  &lt;Route path=&quot;/index/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">                &lt;/MainLayout&gt;</span><br><span class="line">             &#125;/&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">    &lt;/HashRouter&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default BasicRouter;</span><br></pre></td></tr></table></figure><p>在MainLayout中，修改如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#x27;./MainLayout.scss&#x27;;</span><br><span class="line"></span><br><span class="line">const &#123; Header, Sider, Content &#125; = Layout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default class MainLayout extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&#x27;main-layout&#x27;&gt;</span><br><span class="line">                &#123;this.props.children&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，一个嵌套路由就完成了。</p><h1><span id="javascript">Javascript</span><a href="#javascript" class="header-anchor">#</a></h1><h2><span id="jian-tou-han-shu">箭头函数</span><a href="#jian-tou-han-shu" class="header-anchor">#</a></h2><p>箭头函数本质还是函数，我们来看看他与JavaScript中普通函数的区别，先看看写法上的区别。<br><img src="https://img-blog.csdnimg.cn/2b6243000b0d48f69f6baf1e77293818.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>解释</strong><br>写箭头函数，我们记住一个顺序就好，参数、箭头、函数体、这个顺序记住就足够了，参数、箭头、函数体、这三个是必须的，函数名可以没有，但这三项必须有，一些简写的方式也是简写这三项里的东西。</p><p><strong>简写</strong><br>1、只有一个参数时，() 可省略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//不简写</span><br><span class="line">var demo = (x) =&gt;&#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//简写</span><br><span class="line">var demo = x =&gt;&#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、函数体只有一句时， {} 可以省略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//不简写</span><br><span class="line">var demo = (x) =&gt;&#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//简写</span><br><span class="line">var demo = x =&gt; console.log(x);</span><br></pre></td></tr></table></figure><p>3、函数体只有一条返回语句时，{} 和 return 都可以省略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//不简写</span><br><span class="line">var demo = (x) =&gt; &#123;</span><br><span class="line">     return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//简写</span><br><span class="line">var demo = (x) =&gt; x;   </span><br><span class="line"></span><br><span class="line">//注意别写成这样  </span><br><span class="line">var demo = (x) =&gt;&#123; x &#125;;  </span><br><span class="line">//或者 这样  </span><br><span class="line">var demo = (x) =&gt; return  x;  </span><br><span class="line">//要省略就都省略，不省略就都不省，别省一半,不然会出错的。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>箭头函数放 参数 的地方就在 () 内，<br>没有参数，() 必须写，<br>一个参数，() 可写可不写，<br>多个参数，() 必须写。</p><p>箭头函数放 函数体 的地方在 {}内，<br>函数体 就 一句 {} 可写可不写，<br>函数体 不止一句，{} 必须写。</p><p>如果不知道，() {} 写不写，该不该省略，那就写，写了不会错。</p><p><strong>箭头函数 如果要返回一个对象，要简写的话， 需要用()包住这个对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//不简写</span><br><span class="line">var demo = () =&gt;&#123; </span><br><span class="line">    return &#123;x:1&#125;;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">//简写</span><br><span class="line">var demo = () =&gt;(&#123;x:1&#125;);</span><br></pre></td></tr></table></figure><p>为什么会这样？因为如果不加 () ，那{ } 就表示的是语法块，不是表示一个对象，而加上()，按照规范来说，() 里面 { } 就会被解析为对象了。</p><p>对于 {x:1} 这个情况，他不仅可以表示一个对象，这个对象有个x属性，值为1，也可以表示为语法块中含有 名为 x 的 label，忘记 label语法的话，可以看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label">这里</a><br>如果不是很明白，可以看看这个<a href="https://www.zhihu.com/question/40902815">回答</a>，应该会理解的更加深刻。<br>所以这也解释了为什么会出现下面代码中的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 不报错</span><br><span class="line">var demo = () =&gt;&#123;x:1&#125;;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">var demo = (y) =&gt;&#123;y,x:1&#125;;</span><br></pre></td></tr></table></figure><p><strong>对象的方法用 箭头函数写时，this 的指向 可能和你想的不一样</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.name=&#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">    show_name:() =&gt;&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">obj.show_name(); //window</span><br></pre></td></tr></table></figure><p>JavaScript使用的是函数作用域，在上面这段代码中对象的括号是不能封闭作用域的，所以此时的this还是指向window。<br>我们换成普通函数看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.name=&#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">    show_name: function ()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">obj.show_name();  //obj</span><br></pre></td></tr></table></figure><p>换成普通函数，this 就不是指向window，而是指向 obj 对象了</p><p>箭头函数 与 普通函数 其他的区别</p><blockquote><p>1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。<br> 2、箭头函数 this不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。<br>  3、箭头函数 不能用 new关键字来实例化对象，不然会报错。<br>  4、箭头函数没有arguments对象。</p></blockquote><p>1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.name = &#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">    show_name:function ()&#123;</span><br><span class="line">        function fn ()&#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.show_name();  // window</span><br></pre></td></tr></table></figure><p>声明一个 obj 对象，有一个name属性 与 show_name方法，上面这段代码，我的本意是想显示 obj对象的name， 但是没和我想的一样，一般我们会用 一个变量 self 或者 that 之类的留住this,像这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">window.name = &#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">    show_name:function ()&#123;</span><br><span class="line">        //留住this</span><br><span class="line">        var that = this;</span><br><span class="line">        function fn ()&#123;</span><br><span class="line">            console.log(that.name);</span><br><span class="line">        &#125;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.show_name();  //obj</span><br></pre></td></tr></table></figure><p>通常来说，箭头函数内部的this就是外层代码块的this</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.name = &#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">    show_name:function ()&#123;</span><br><span class="line">        var fn = () =&gt; &#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.show_name(); //obj</span><br></pre></td></tr></table></figure><p>2、箭头函数 this 不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.name = &#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">function show_name()&#123;</span><br><span class="line">    //这里 show_name 是一个普通的全局函数，所以他的this指window</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">//用了 call 方法，把 show_nam 的this 指向了 obj 对象</span><br><span class="line">show_name.call(obj);  //obj</span><br></pre></td></tr></table></figure><p>箭头函数 this 不可变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.name = &#x27;window&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&#x27;obj&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">var show_name = () =&gt; &#123;</span><br><span class="line">    //这里 show_name 是箭头函数，他的this指window，并且不会变</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">//用了 call 方法，但是 this 没变，所以打印了 window</span><br><span class="line">show_name.call(obj);  //window</span><br></pre></td></tr></table></figure><p>3、箭头函数 不能用 new 关键字来实例化对象，不然会报错，箭头函数的this 不可变，new 也改变不了 this的 指向，而且更为重要的是，箭头函数内部并没有 [[Construct]] 方法，所以会没有原型属性（prototype），所以箭头函数没法当构造函数。</p><p><img src="https://img-blog.csdnimg.cn/7803115884ae4f6ab5f8d4cd73cfe038.png" alt="在这里插入图片描述"><br>4、箭头函数没有arguments对象，不能通过arguments对象访问传入参数，但是可以用rest参数实现<br>。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters">不了解的看这里</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var demo = (...theArgs) =&gt; theArgs;</span><br><span class="line">demo(1,2,3); //[1,2,3]</span><br></pre></td></tr></table></figure><p><strong>总结</strong><br>在来看一遍 箭头函数 与 普通函数，除了写法上的区别</p><blockquote><p>1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。<br>2、箭头函数 this不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。<br>3、箭头函数 不能用 new关键字来实例化对象，不然会报错。<br>4、箭头函数没有arguments对象。</p></blockquote><p>可以看出，最重要的区别还是 在 this 上，所以要想用好 箭头函数，还是要对 this 有一定认识的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#react&quot;&gt;React&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#qi-dong-liu-cheng&quot;&gt;启动流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#react-</summary>
      
    
    
    
    <category term="前端开发" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/09/1/"/>
    <id>http://example.com/2022/01/09/1/</id>
    <published>2022-01-09T13:14:29.792Z</published>
    <updated>2022-01-09T13:14:10.891Z</updated>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta http-equiv="X-UA-Compatible" content="IE=edge">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title></head><body>    <h1><span id="hello-world">hello world</span><a href="#hello-world" class="header-anchor">#</a></h1></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/08/1/"/>
    <id>http://example.com/2022/01/08/1/</id>
    <published>2022-01-08T08:01:18.144Z</published>
    <updated>2022-01-08T08:01:09.895Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#1">1.一级目录</a></p><p><a href="#1.1">1.1二级目录</a>　　</p><p><a href="#1.1.1">1.1.1三级目录</a></p><h2><span id="yi-ji-mu-lu"> 一级目录 </span><a href="#yi-ji-mu-lu" class="header-anchor">#</a></h2><h4><span id="er-ji-mu-lu"> 二级目录 </span><a href="#er-ji-mu-lu" class="header-anchor">#</a></h4><h5><span id="san-ji-mu-lu"> 三级目录 </span><a href="#san-ji-mu-lu" class="header-anchor">#</a></h5>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1.一级目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#1.1&quot;&gt;1.1二级目录&lt;/a&gt;
　　&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#1.1.1&quot;&gt;1.1.1三级目录&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;yi-ji-mu-lu&quot;&gt; 一级目录 &lt;</summary>
      
    
    
    
    
  </entry>
  
</feed>
